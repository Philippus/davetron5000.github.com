
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="XXX">

  
  <meta name="description" content="
  
  
  
    
      
  
    † What Makes an Awesome Command-Line App?
  
  
    
      








  




    
  


  I wrote an article in the lates...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/page8/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <div class="blog-index">
  
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/05/02/what-makes-and-awesome-command-line-app.html">† What Makes an Awesome Command-Line App?</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-05-02T09:40:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>I wrote an article in the latest <a href="http://pragprog.com/magazines/2012-05/content">PragPub magazine</a> called <a href="http://pragprog.com/magazines/2012-05/what-makes-an-awesome-commandline-application">What Makes an Awesome Command-line Application?</a>.  Check it out!  If you want a more code-focused and detailed version, see <a href="http://www.naildrivin5.com/blog/2012/04/01/the-nine-facets-of-an-awesome-command-line-app.html">The Nine Facets of an Awesome Command-Line App</a> and, of course, <a href="http://www.pragprog.com/titles/dccar">my book</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/04/24/five-months-of-ebook-sales.html">&#10106;&#10144; Five Months of eBook Sales</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-04-24T10:00:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>I really enjoyed reading <a href="http://www.twitter.com/jstorimer">Jesse Storimer&#39;s</a> recent post, <a href="http://jstorimer.com/2012/04/20/4-months-of-ebook-sales.html">4 Months of ebook Sales</a>, about the sales of his book <a href="http://workingwithunixprocesses.com/">&quot;Working with Unix Processes&quot;</a>.  His feelings echo my own regarding my book, <a href="http://pragprog.com/titles/dccar/">&quot;Build Awesome Command-Line Applications in Ruby&quot;</a>: </p>

<blockquote>
<p>I&#39;m ecstatic with the results so far, but I have no idea how they compare.</p>
</blockquote>

<p>Our books complement each other quite well, and came out around the same time.  He wrote his largely on his own, going the self-publishing route, while I wrote mine with the <a href="http://pragprog.com/">Pragmatic Programmers</a>.  I thought I&#39;d write a similar piece from my experience going the &quot;traditional&quot; route.</p>

<!-- more -->

<h3>Beginning</h3>

<p>I wrote an initial draft of &quot;Build Awesome Command-Line Applications in Ruby&quot; over November 2010, as part of <a href="http://forums.pragprog.com/forums/235">PragProWriMo</a>.  I
wrote almost every day, and had about 170 pages of Markdown written at the end.  I hadn&#39;t thought too far ahead, but in January of 2011, I decided to submit it to the Prags and see if they were interested.</p>

<p>To my surprise and excitement they decided to go forward with it!  I had no idea what to expect, but figured that since I had a good 75% of a &quot;real&quot; book done, it shouldn&#39;t be too much more work for me to finish up the first draft and clean it up.  Boy was I wrong.  </p>

<p>I spent the next 11 months on the book, reaching &quot;done&quot; by February of this year.  That may seem like a long time (it certainly did to me).  The reason it took &quot;so long&quot; was entirely due to working with a publisher and editor, but I don&#39;t mean that as a negative.  It actually <em>needed</em> to take that long, and the book I shipped was markedly better than anything I would&#39;ve done on my own.</p>

<h3>Developing</h3>

<p>The Prags don&#39;t just take your manuscript, spell-check it and ship it.  They assign a <em>development editor</em> to each book.  I had no idea what this was; I thought editors fixed spelling and grammar mistakes.  Instead, John Osborn, my editor, provided deep and insightful feedback on every aspect of the book.  Did the sections flow together?  Are the titles consistent? Did the examples make sense?  Of course, I had created plenty of passive voice, subject/verb disagreement and other &quot;advanced grammar mishaps&quot; to keep John quite busy.</p>

<p>Identifying these issues in your own work is hard.  It&#39;s also just not possible to get real, usable feedback on your work.
Friends and colleagues just won&#39;t give you the brutal, honest feedback you sometimes need.  It had been a long time since I&#39;ve
been given this sort of feedback, and it hurt a bit (at first) to read comments like these:</p>

<ul>
<li>&quot;The overall premise of the book is not immediately clear.&quot;</li>
<li>&quot;The audience level remains unclear.&quot;</li>
<li>&quot;After a while...it just gets wearing. Why should I bother to read yet one more example when I know that I’ll be told this was the wrong way to do it?&quot;</li>
</ul>

<p>These came after John and I had spent a lot of time working my initial manuscript into something publishable, and had gotten a
lot of positive feedback from the tech reviewers.  Based on the publisher feedback, we were looking at an almost total rewrite, and I wasn&#39;t too happy about it.  But, I really believed in the book and wasn&#39;t about to quit now, so I trusted the publishers.  Recognizing their experience, I treated this as a learning opportunity.  So we persevered.</p>

<h3>Persevering</h3>

<p>Three chapters later, it was so clear to me that I had been wrong that I couldn&#39;t believe I had felt otherwise.   And, I never would&#39;ve gotten there without such honest feedback and a literal <em>team</em> of professionals<a name="back-1"></a><sup><a href="#1">1</a></sup> working to make my book
as good as it could be.  In the end, the book bears little resemblance to what I had produced during PragProWriMo, and, while I
probably could&#39;ve gotten that into a &quot;sellable&quot; shape, it would not have been nearly as good.</p>

<p>So, a total of 15 months of work, including an almost total rewrite, all on my own time, with no money up front.  Was it worth
it? Absolutely. But, how has it been selling?</p>

<p>On the one hand, I&#39;m not sure.  I don&#39;t know how many copies of my book will &quot;pay for&quot; the development costs, or how many will
make the publishers &quot;happy&quot; with the result (I&#39;ve put off asking in case the answer is &quot;way more than you&#39;ve sold&quot;).  I do know that I&#39;ve sold more than I thought I would, and although I&#39;d love to sell
more, I&#39;m really happy with how it&#39;s done.</p>

<h3>Performing</h3>

<p>As of this post, I&#39;ve sold around 3,000 copies from the Pragmatic Programmers online store<a name="back-2"></a><sup><a href="#2">2</a></sup>.  I don&#39;t yet know how many I&#39;ve sold from other channels such as Amazon or Barnes &amp; Noble -- hopefully a lot -- but sales from the Prags&#39; store alone feels like more than I was expecting.</p>

<p>Of course, I don&#39;t make as much per book as Jesse does<a name="back-3"></a><sup><a href="#3">3</a></sup>; that team I mentioned doesn&#39;t come free.  But, being featured on the Pragmatic Programmers&#39; website is unbeatable promotion.  This certainly drove a lot of sales.  It&#39;s my hope that sales are higher than they would&#39;ve been had the Prags published a version of the book I had originally written, but there&#39;s no way to know for sure.</p>

<p>Now, I don&#39;t mean to imply Jesse&#39;s book is poorly written; it&#39;s not at all.  Would it be better if it were edited professionally?
I suppose that depends on what you mean?  Would it be better <em>written</em>?  Certainly; most writing improves with editing and revising.
Would it have sold more?  Would it have sold enough to cover the costs and time of editing?  Again, there&#39;s no way to know.</p>

<p>So where does this leave us?  I know that working with John and the Prags has made me a better writer, but would I be confident enough to &quot;go it alone&quot;?   Given my lack of notability, I feel I benefit greatly from having my work published and distributed by the Prags.  Further, knowing my writing style and abilities as I do, my work will be much higher quality with a team of professionals in my corner.</p>

<p>That being said, I&#39;d still love to try self-publishing at some point, but I&#39;d really love to read a book by Jesse developed with the Pragmatic Programmers.  </p>

<hr>

<footer class='footnotes'>
<ol>
<li>
<a name='1'></a>
<sup>1</sup>In addition to John, Dave, and Andy, the Prags employ copy editors, sysadmins, indexers, and probably many others that I don't even know about that turn my XML and code into a beautiful book to read on paper as well as every reading device there is.<a href='#back-1'>↩</a>
</li>
<li>
<a name='2'></a>
<sup>1</sup>The breakdown is about 10% paper/90% electronic, which seems about right.<a href='#back-1'>↩</a>
</li>
<li>
<a name='3'></a>
<sup>1</sup>It's worth pointing out that the Prag's contract is <strong>very</strong> generous compared to most other publishers.<a href='#back-1'>↩</a>
</li>
</ol></footer>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/04/11/methadone-1-dot-0-with-awesome-tutorial.html">Methadone 1.0 with Awesome Tutorial</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-04-11T10:39:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p><a href="http://www.github.com/davetron5000/methadone">Methadone</a> is the ultimate command-line library for Ruby apps.  All the power of <code>OptionParser</code>, none of the verbosity, with a smattering of tools to help you write amazing apps right from the get-go.  In seconds, you have a fully functioning skeleton of an app, with integration and unit test coverage, documentation, and in-line help.  I created most of it while writing [my book][clibook], and have been feverishly polishing it since the book came out.</p>

<p>Today is its first official release at 1.0.  Woot!</p>

<p><img src="/images/methadone_tutorial.jpg" alt="&#39;Cover for the Methadone Tutorial iBook&#39;"></p>

<p>I&#39;ve also released a tutorial as an &quot;enhanced&quot; iBook, <a href="http://itunes.apple.com/us/book/kick-bash-habit-ruby-methadone/id515825242?ls=1">available now</a> from the iBookstore as a free download.  This isn&#39;t just a big ream of code and text, but a step-by-step walkthrough, with screencasts, on how to use Methadone, along with some detailed discussion on some of Methadone&#39;s more useful features.  It&#39;s all presented beautifully as a &quot;textbook&quot;-style iBook that looks great on an iPad 1 and stunning on the new iPad, thanks to iBooks Author and the retina display.</p>

<p>Read the tutorial, <a href="http://rdoc.info/github/davetron5000/methadone/master/frames">read the RDoc</a>, install the library, and feel free to <a href="http://www.github.com/davetron5000/methadone/issues">submit patches</a>.</p>

<hr>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/04/05/i-heartily-endorse-ruby-off-rails.html">I heartily endorse Ruby off Rails</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-04-05T12:35:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p><a href="http://jessewolgamott.com/">Jesse Wolgamott</a> has launched a training course called <a href="https://rubyoffrails.com/">Ruby Off Rails</a>, which is geared toward helping existing programmers learn Ruby first, and <em>not</em> Rails.  </p>

<p>I heartily endorse this and highly recommend this approach if you want to &quot;get into Rails&quot;.</p>

<!-- more -->

<p>When I first heard about Rails, I bought a copy of <a href="http://pragprog.com/book/rails4/agile-web-development-with-rails">Agile Web Development with Rails</a> and was instantly confused as to what I was looking at.  What were all those <code>@</code> signs for?  Why are there pipes after the <code>do</code> keyword?  Where were all these methods coming from?</p>

<p>The answer was: Learn you a Ruby.</p>

<p>I am not the type programmer to just copy/paste code I don&#39;t understand.  I don&#39;t like &quot;magic<a name="back-1"></a><sup><a href="#1">1</a></sup>&quot;.  I want to know, or at least have an inkling of, how the tools I&#39;m using work.  And there&#39;s no hope in understanding Rails without understanding Ruby.</p>

<p>I sold the book, and, using a Ruby book available on <a href="http://www.safaribooksonline.com/">Safari</a>, started to learn Ruby the language.  I ignored Rails, and didn&#39;t even think about it.  Instead, all of the <a href="http://www.awesomecommandlineapps.com">command line apps</a> that I would historically write in Perl, I wrote in Ruby.  I wrote a <em>lot</em> of Perl in Ruby at first<a name="back-2"></a><sup><a href="#2">2</a></sup>.</p>

<p>Eventually, I figured out how the language worked and, when it came time to do some serious Rails programming, I wasn&#39;t surprised by much.  I mostly just had to learn to navigate the documentation.  Even when I didn&#39;t know how something worked, I could usually have a guess, and I was usually right.  When I wasn&#39;t, I learned something new about Ruby.</p>

<p>It probably wouldn&#39;t have taken so long if I&#39;d taken a more focused approach like what Ruby Off Rails is doing (and, LivingSocial&#39;s <a href="http://hungryacademy.com/">Hungry Academy</a> as well, which starts with just Ruby before moving to Rails).</p>

<p>If you&#39;re tired of slinging Java/C#/PHP, but can&#39;t seem to get focused to learn Rails or Ruby, Ruby Off Rails seems like a good way to go.  It&#39;s not very expensive, and it&#39;s geared around writing code, not learning API documentation.</p>

<hr>

<footer class='footnotes'>
<ol>
<li>
<a name='1'></a>
<sup>1</sup>I consider <em>magic</em> in programming to be something that <strong>you</strong> don't understand.  Everything is knowable<a href='#back-1'>↩</a>
</li>
<li>
<a name='2'></a>
<sup>1</sup>I think the <strong>main</strong> reason I came to Ruby instead of Python was because Ruby had the <code>=~</code> operator and Python didn't, and that irritated me, because it's so awersomely helfpul<a href='#back-1'>↩</a>
</li>
</ol></footer>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/04/02/a-protocol-for-code-reviews.html">A Protocol for Code Reviews</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-04-02T20:30:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><blockquote>
<p>Anyone have a (formal / step-by-step) protocol for code reviews?</p>
</blockquote>

<p>Yes, I do.  At <a href="http://www.heyitsopower.com">Opower</a>, we were pretty serious about code reviews.  We didn&#39;t review every commit, but we did review a lot, and, after a while, fell into a pretty decent routine.  This is an adaptation of that that I think is pretty decent.</p>

<!-- more -->

<h2>Prepare</h2>

<p>The code authors should send out the diff, either as a pull request, or whatever the equivalent is in the tool of choice.  This should include:</p>

<ul>
<li>What the purpose of the change is</li>
<li>Links to any supporting tickets, documentation, etc.</li>
<li>A Place To Start</li>
</ul>

<p>With all that, the reviewers should get an email, inviting them to review the code.  This is important, because you need to identify the people whose feedback you want.  Don&#39;t just email <code>people_who_installed_ruby@theuniverse.com</code>; email people who either <em>should</em> see your change, or whose feedback you want.</p>

<h3>A Place to Start?</h3>

<p>Depending on the complexity of the change, this could be the name of the class/method where one should start reading, or a full-blown design document explaining the approach and structure of the change.  The point is that the reviewers have <em>no clue</em> how your code works, and need somewhere to get going.</p>

<h2>Asynchronous Review</h2>

<p>This is &quot;review by online tool&quot;, e.g. Github Pull Requests.  To make this work, you <em>must</em> have a tool that allows per-line commenting and discussion.  The reviewers will start at the Place to Start, review the code, and comment on things.  Reviewers should comment on anything they see fit, and they should follow <a href="http://twitter.com/#!/wilw/statuses/5966220832">Wheaton&#39;s Rule</a>: Don&#39;t be a dick.  The review<strong>ee</strong> promises not to take anything personally.  This can be hard to do, especially if you are new to the team, or inexperienced.  I&#39;d recommend that for first-time employees, skip this and go to the <em>Synchronous Review</em> as it can be less intimidating.</p>

<h3>Responding to comments</h3>

<p>The reviewee should absolutely respond to comments.  I would expect comments to be one of these three responses:</p>

<ul>
<li>You are right, I will change that.</li>
<li>You are wrong, because of <em>some explanation</em>, and perhaps I&#39;ll drop some comments or better-name my variables before I push this to make it clear.</li>
<li>I&#39;m confused, can you elaborate?</li>
</ul>

<h3>Uploading changes</h3>

<p>As important as it is that your review tool allow per-line comments, it&#39;s equally important that your review tool allow new changes to be added to the review <em>without blowing away the comments</em>.  Reviewers should be able to tell that you&#39;ve made changes based on their feedback and see if it makes sense</p>

<h3>Stylistic Comments</h3>

<p>Early reviews at Opower wasted an inordinate amount of time on stylistic things.  We eventually adopted a house style and our reviews moved on to important things.  You are not a special butterfly and you are not a snowflake who can only express him or herself through your clever variable names and indenting style.  Follow the house style, or at least the style of the code you are in so you can <em>get better feedback on your code</em> instead of arguing about where commas should go.</p>

<h2>Synchronous Review</h2>

<p>If there are too many &quot;I&#39;m confused&quot; comments, or the overall design/approach of the solution seems undesirable, it can greatly help if you hold a meeting with the interested parties to talk out the issues in the review, rather than creating an endless stream of comments in the review tool.</p>

<p>This review should be attended <em>only</em> by those with an interest in the outcome.  It should be timeboxed to hopefully 30 minutes, but not more than an hour, and the end result should be a &quot;todo&quot; list for the reviewee to correct the issues.  The ability to project the code on the screen is a plus, and the code authors best know how to navigate their codebase.  Senior developers have a responsibility to school them on this during the review.  It&#39;s the only way you&#39;ll learn. The issues would be of the form:</p>

<ul>
<li>Code author didn&#39;t understand the problem, and a larger rework is indicated</li>
<li>Reviewers didn&#39;t understand the solution, and, after explaining, the author either reworks the code to be more understandable, or provides documentation to clear things up</li>
</ul>

<h2>Completion</h2>

<p>When the code is done to the satisfaction of those involved, the final commit should contain a link to the review in the review tool. This is crucial for future archaeologists  that might want to know what&#39;s going on; seeing the discussion can be helpful.</p>

<h2>Doing this with Github</h2>

<p>Github&#39;s pull requests are less than ideal for this, depending on how you work.  Primarily, a reviewer wants to see the diff between the current system and how the system would look with the new code applied.  Last I checked, this view in Github doesn&#39;t allow per-line commenting, making it almost useless (see update, 11/21).</p>

<p>What I&#39;d recommend is to squash the commit onto a branch specifically for the review (e.g. <code>reviews/TICKETNUM-DESCRIPTION</code>).  When the code author needs to add changes in response to the review, just add those diffs to the branch.  When everything is done, squash all <em>that</em>, and merge it.  One diff, one thing to deal with and understand.  </p>

<p>If you really want the sausage-making to be part of mainline history, then merge your changes plus one additional change representing all changes you made based on the review, with the message being a link to the review branch in Github.</p>

<h2>Doing this with Crucible</h2>

<p><a href="http://www.atlassian.com/software/crucible/overview">Crucible</a> was tailor-made for this, and all you need to do is choose changesets and have at it.  You can add diffs as needed, and the commenting system is rich.  Crucible is not as polished and slick as Github, but it works great.</p>

<h2>Conclusion</h2>

<p>This may sound like a lot, but it&#39;s <em>really</em> lightweight, once you start doing it, and it&#39;s way better than zillions of emails or
long, horrible meetings.  Just try it.</p>

<h2>Update, 11/21</h2>

<p>Github pull requests actually <em>do</em> let you comment per line on the diff view.  This wasn&#39;t always the case, and is still not the case for non-pull request branches.  I
still feel like Github&#39;s PR mechanism isn&#39;t totally awesome, especially because it can be hard to see what someone&#39;s done to address code review comments, and, if you
force-push, all hell breaks loose, but it&#39;s gotten better.</p>

<p>Also, it seems that Crucible is <a href="https://confluence.atlassian.com/display/CRUCIBLE/End+of+Support+Announcements+for+Crucible">going the way of the dodo</a>, so scratch that.  Maybe I need to re-write this post every 6 months?!</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/04/01/the-nine-facets-of-an-awesome-command-line-app.html">The Nine Facets of an Awesome Command-Line App</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-04-01T11:51:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>When creating the outline for [my book]<a href="now%20officially%20published%20and%20in%20print!">clibook</a>, I decided to organize it around the
nine facets of an awesome command-line app.  [Each chapter][toc] focuses on one of these facets.  They state that an awesome
command-line app should:</p>

<ul>
<li>have a clear and concise purpose</li>
<li>be easy to use</li>
<li>be helpful</li>
<li>play well with others</li>
<li>delight casual users</li>
<li>make configuration easy for advanced users</li>
<li>install and distribute painlessly</li>
<li>be well-tested and as bug free as possible</li>
<li>be easy to maintain</li>
</ul>

<p>In this post, I&#39;ll illustrate each of these facets (along with a test of the tenth chapter on color and formatting), via a code
walkthrough of a simple command-line app I created for work.</p>

<!-- more -->

<p>LivingSocial (where I [work]) processes thousands of credit card transactions per day, across a highly distributed, asynchronous system.  When things go wrong, the log files are the first place I look to find answers.  This means that <code>grep</code> is my go-to tool for analysis.  Even though <code>grep</code> can highlight search terms in output, with long and complex log lines, it can be hard to pick out just what I&#39;m looking for.  I needed a tool to just highlight text, but not actually &quot;grep out&quot; non-matching lines.</p>

<h2>To the command-line!</h2>

<p>So, in just a few short hours, [hl][hl] was born.  I wrote it using TDD, and, even though it&#39;s barely 100 lines of code, it hits all the notes of an awesome command-line app (if I do say so myself :).  Let&#39;s go through all nine of our &quot;facets of an awesome command-line app&quot; and see what the fuss is about.</p>

<h2>Have a Clear &amp; Concise Purpose</h2>

<p>The best way to have a clear &amp; concise purpose is to do one thing, and one thing only.  <code>hl</code> highlights search terms in any output to assist with visual scanning of output.  It doesn&#39;t highlight multiple terms, and it doesn&#39;t remove non-matching lines.  It just highlights terms.  One thing, and one thing only.</p>

<h2>Be Easy to Use</h2>

<p>This is a <em>big</em> topic, but here&#39;s an example of using <code>hl</code>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grep 987876736 my_logs.log | hl credit_card_token
</code></pre></div>
<p><code>hl</code> does what it&#39;s asked, by default, without a lot of fuss, just like any other UNIX command.  It has options, but you never
need to worry about them in most cases.  Of course, if you <em>are</em> curious about those options, that leads to our next facet.</p>

<h2>Be Helpful</h2>

<p><code>hl</code> is based on [methadone][methadone], which is a proxy to [OptionParser][optionparser], which is <em>the</em> tool to use for parsing the command-line in Ruby.  It&#39;s very powerful, and generates a canonical, documented UI for your app:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ bin/hl --help
Usage: hl [options] [search_term] [filename]

Highlight terms in output without grepping out lines

v1.0.0

Options:
    -c, --color COLOR                Color to use for highlighting
                                     (red|green|yellow|blue|magenta|cyan|white)
                                     (default: yellow)
    -b, --[no-]bright                Use bright colors
    -n, --[no-]inverse               Inverse highlight
    -u, --[no-]underline             Underline highlight
    -p, --regexp PATTERN             Search term as explicit option
    -i, --[no-]ignore-case           Ignore case in match
        --version                    Show help/version info

Default values can be placed in the HL_OPTS environment variable
</code></pre></div>
<p>Note how much <code>OptionParser</code> gives us:</p>

<ul>
<li>Ability to describe our app, its version, and basic invocation syntax</li>
<li>Nicely formatted list of options and descriptions</li>
<li>Ability to accept &quot;negatable&quot; options (we&#39;ll talk about that in a second)</li>
</ul>

<p>Further, I&#39;ve gone to the trouble to make sure that <code>--color</code> clearly indicates the acceptable values as well as the default.  Finally, I&#39;ve made sure that all options are available in short-form (for easy typing on the command line) and long-form (for clarity when scripting and configuring our app).</p>

<p>Here&#39;s the code that makes this happen (if you aren&#39;t familiar with methadone, the method <code>on</code> behaves almost exactly like the <code>on</code> method in <code>OptionParser</code>):</p>

<p>```ruby bin/hl</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &#39;optparse&#39;
require &#39;methadone&#39;
require &#39;hl&#39;</p>

<p>class App
  include Methadone::Main
  include Methadone::CLILogging</p>

<p>main do |keyword,*filenames|
    # main logic here
  end</p>

<p>description &quot;Highlight terms in output without grepping out lines&quot;</p>

<p>options[:color] = &#39;yellow&#39;
  colors = [&#39;red&#39;, &#39;green&#39;, &#39;yellow&#39;, &#39;blue&#39;, &#39;magenta&#39;, &#39;cyan&#39;, &#39;white&#39;]
  on(&quot;-c COLOR&quot;,       &quot;--color&quot;,&quot;Color to use for highlighting&quot;,colors,&quot;(#{colors.join(&#39;|&#39;)})&quot;)
  on(&quot;--[no-]bright&quot;,     &quot;-b&quot;,  &quot;Use bright colors&quot;)
  on(&quot;--[no-]inverse&quot;,    &quot;-n&quot;,  &quot;Inverse highlight&quot;)
  on(&quot;--[no-]underline&quot;,  &quot;-u&quot;,  &quot;Underline highlight&quot;)
  on(&quot;--regexp PATTERN&quot;,  &quot;-p&quot;,  &quot;Search term as explicit option&quot;)
  on(&quot;--[no-]ignore-case&quot;,&quot;-i&quot;,  &quot;Ignore case in match&quot;)</p>

<p>arg :search_term, :optional
  arg :filename, :optional</p>

<p>version Hl::VERSION</p>

<p>defaults<em>from</em>env<em>var &#39;HL</em>OPTS&#39;</p>

<p>go!
end
```</p>

<p>Methods like <code>arg</code>, <code>version</code>, and <code>description</code> are helpers from methadone (see the [intro][methadone_intro] for more), but note how <em>little</em> code it takes just to make a great and polished UI. </p>

<p>The second part of a helpful app is to include more detailed documentation.  For a command-line app, this is expected to be in the form of a man page.  If you installed <code>hl</code> with RubyGems, try this:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">$ </span>gem man hl
</code></pre></div>
<p>You should see a nicely formatted man page (which also happens [to be the <code>README</code>][hl-readme] for the github project)!  Creating a man page is extremely simple thanks to [ronn][ronn].  <code>ronn</code> converts Markdown to troff, the format used by the man system.  Just add this to your Rakefile:</p>

<p>```ruby Rakefile Snippet
require &#39;methadone&#39;
require &#39;fileutils&#39;</p>

<p>include Methadone::SH
include FileUtils</p>

<p>task :man do 
  sh &#39;ronn --markdown --roff man/hl.1.ronn&#39;
  mv &#39;man/hl.1.markdown&#39;,&#39;README.md&#39;
end
```</p>

<p>And, your gemspec just needs:</p>

<p><code>ruby Gemspec
  s.add_development_dependency(&#39;ronn&#39;)
  s.add_dependency(&#39;gem-man&#39;)
</code></p>

<p>You&#39;ll also need to include the generated file <code>man/hl.1</code> in your <code>files</code> in your gemspec, but if you&#39;re using the gemspec created by Bundler, this happens automatically as long as the file is in source control.</p>

<p>That&#39;s <em>it</em>.   Now your app has a great UI <em>and</em> a man page, and all you had to do was drop a few lines of code and write a short Markdown file (which you&#39;d write anyway, since you <em>are</em> making a README, right?).</p>

<p>In addition to being helpful to humans, awesome command-line apps should be helpful to other commands.</p>

<h2>Play well with others</h2>

<p>An app that &quot;plays well with others&quot; on the command line, basically means that it acts as a <em>filter</em>. Text comes in, gets processed, the processed text goes out.  The expectation is that text from any other &quot;well playing&quot; program can be input into our program, and that our program&#39;s output can be piped into another program as input.</p>

<p>Since the purpose of our app is to add ANSI escape codes to the output for assistance with <em>human</em> visual scanning, we can&#39;t claim that our <em>output</em> plays well with others; it&#39;s not designed to.  But, we can still play well with the output from <em>other</em> apps.</p>

<p>We saw that <code>hl</code> was designed to take input from a tool like <code>grep</code>.  <code>hl</code> can also highlight terms from any number of files given to it on the command line.  You can do this transparently in Ruby using the awesome [ARGF][argf], however Methadone doesn&#39;t support ARGF (a sad fact I learned while writing this app, and something [I&#39;ll address][argfbug] in the near future), so here&#39;s how did it (a few comments added to indicate what&#39;s going on):</p>

<p>```ruby Treating STDIN and a file list as the same source of data</p>

<h1>filenames is a possibly empty list of strings</h1>

<p>files = if filenames.empty?
          [STDIN]
        else
          filenames.map { |<em>| File.open(</em>) }
        end</p>

<h1>files is now an Array of open IO objects</h1>

<p>begin
  # highlighting code
ensure
  # we close the files since we didn&#39;t open them in &quot;block&quot; form; closing STDIN is OK to do
  # since we know our app will soon exit
  files &amp;&amp; files.map(&amp;:close)
end
```</p>

<p>Again, ARGF handles this transparently, but the point is, we want the standard input and a provided list of files to be treated the same by our program, and this is how I did it.</p>

<p>Since our app is similar in concept to grep, I thought it would be nice if users familiar with grep could be instantly familiar
with <code>hl</code>.</p>

<h2>Delight Casual Users</h2>

<p>This is a &quot;level up&quot; from &quot;being easy to use&quot;.  The idea behind the term &quot;delight&quot; is to provide a level of polish and attention to detail that your users will appreciate if they&#39;re observant, but hopefully not even notice, because your app &quot;just works&quot;.</p>

<p>Since <code>hl</code>, like <code>grep</code>, is used for filtering and examining text files,  I chose my command-line options to match <code>grep</code>&#39;s where i could.  Initially, I had the short-form of <code>--inverse</code> as <code>-i</code>.  When I later added the ability to do a case-insensitive match, I realized that <code>-i</code> is the option to <code>grep</code> for &quot;case-insensitive&quot;.  I quickly changed <code>--inverse</code> to have <code>-n</code> as its short-form, and made <code>-i</code> and <code>--ignore-case</code> the options for case-insensitivity.  These are the same values that <code>grep</code> uses, so a user who might subconciously type <code>hl -i</code> expecting a case-insensitive match will get it.</p>

<p>Further, I allowed the user to specify the search term either as a command-line argument, or as the argument to <code>-p</code> or <code>--regexp</code>, which are the option names <code>grep</code> uses.  It&#39;s a basic principle of design that things that are the same should be <em>exactly</em> the same, so I used <code>grep</code> as my guide when <code>hl</code> implemented similar features.</p>

<p>Of course, power users love to customize things.</p>

<h2>Make Configuration Easy</h2>

<p>In the book, I talk about using YAML as a configuration format for an <code>.rc</code> file.  This can be very useful for complex apps, but another technique that&#39;s handy is to allow an environment variable to hold default options.  <code>grep</code> does this via <code>GREP_OPTS</code> and if you were paying attenion, you noticed this line in <code>bin/hl</code>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="n">defaults_from_env_var</span> <span class="s1">&#39;HL_OPTS&#39;</span>
</code></pre></div>
<p>This tells methadone to look at the environment variable <code>HL_OPTS</code> (as well as the command line) for any options.  These options are placed first in <code>ARGV</code>, essentially like so:</p>

<p><code>ruby Putting command-line options from the environment into ARGV
String(ENV[@env_var]).split(/\s+/).each do |arg|
  ::ARGV.unshift(arg)
end
</code></p>

<p>(Note the use of <code>String</code> to make sure that <code>nil</code> gets turned into the empty string, saving us an <code>if</code> statement).  Methadone does this before parsing <code>ARGV</code>.  Using <code>unshift</code> means that any options the <em>user</em> specifies will come <em>after</em> those in <code>HL_OPTS</code> and therefore take precendence:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ export HL_OPTS=--color=cyan
$ grep foo some_log.txt | hl --color=magenta
</code></pre></div>
<p>This is the same as</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grep foo some_log.txt | hl --color-cyan --color=magenta
</code></pre></div>
<p>This is also why I&#39;ve provided the &quot;negatable&quot; forms.  Suppose you generally wanted inverse:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ export HL_OPTS=--inverse
</code></pre></div>
<p>If you wanted to run <code>hl</code> <em>without</em> inverse, but there was no negatable option, the only way to turn it off would be to unset the environment variable.  With the negatable forms, it&#39;s simple:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grep foo some_log.txt | hl --no-inverse
</code></pre></div>
<p>Since the user&#39;s command-line options take precedence, things work out, but you can still configure your defaults.</p>

<p>Finally, I&#39;d recommend that you use the long-form options in your configuration.  In other words, if you prefer bright and inverted highlights, do this:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ export HL_OPTS=&#39;--inverse --bright&#39;
</code></pre></div>
<p>As opposed to</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ export HL_OPTS=-nb
</code></pre></div>
<p>The second form is more compact, but your configuration is going to be <em>read</em> more than written, and, 6 months from now when you are going through your <code>.bashrc</code>, you&#39;re going to appreciate seeing things spelled out; you&#39;ll know instantly what the configuration does and don&#39;t have to wonder about what <code>-n</code> means.</p>

<h2>Distribute Painlessly</h2>

<p>RubyGems:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ gem install hl
$ hl --help
</code></pre></div>
<p>That is all.</p>

<h2>Be well-tested</h2>

<p>I wrote <code>hl</code> entirely using [TDD][tdd] and entirely using [aruba][aruba].  Here&#39;s a sampling:</p>
<div class="highlight"><pre><code class="language-cucumber" data-lang="cucumber"><span class="nf">  </span><span class="k">Scenario:</span><span class="nf"> Highlights with case insensitivity</span>
<span class="k">    Given </span><span class="nf">a file named &quot;</span><span class="s">test_file</span><span class="nf">&quot; with the word &quot;</span><span class="s">FOO bar foo</span><span class="nf">&quot; in it</span>
<span class="nf">    </span><span class="k">When </span><span class="nf">I successfully run `hl -i foo ../../test_file`</span>
<span class="nf">    </span><span class="k">Then </span><span class="nf">the entire contents of &quot;</span><span class="s">test_file</span><span class="nf">&quot; should be output</span>
<span class="nf">    </span><span class="k">But </span><span class="nf">the word &quot;</span><span class="s">foo</span><span class="nf">&quot; should be highlighted in yellow</span>
<span class="nf">    </span><span class="k">And </span><span class="nf">the word &quot;</span><span class="s">FOO</span><span class="nf">&quot; should be highlighted in yellow</span>
</code></pre></div>
<p>It was very easy to do this, although aruba could use a man page for easier reference.  I had to jump into its source too many times to get reminded of the syntax of the steps it provides.  Aruba also strips out ANSI escape sequences, which made testing <code>hl</code> a bit tricky.  There appears to be an option to <em>prevent</em> this, but I couldn&#39;t get it to work, so I just used Aruba&#39;s internal API:</p>

<p><code>ruby asserting highlighted output
Then /^the word &quot;([^&quot;]*)&quot; should be highlighted in (.*$)$/ do |keyword,color|
  # #color is provided by rainbow, which we&#39;ll talk about in a bit
  expected = keyword.color(color.to_sym)
  # assert_partial_output and all_stdout are provided by aruba
  assert_partial_output(expected,all_stdout)
end
</code></p>

<p>I still recommend aruba and cucumber, as it forces you to think about how users will use your app first, not how to implement it.  In fact, my initial implementation was a big hacky mess of stuff inside the <code>main</code> block.  Once the tests were in place, I refactored it to be a lot cleaner.</p>

<h2>Be Easy to Maintain</h2>

<p>As I just mentioned, I was able to use my tests to refactor my code.  As such, the main block of <code>hl</code> is pretty simple:</p>

<p>```ruby main block in hl
main do |keyword,*filenames|
  if options[:regexp]
    Array(filenames).unshift(keyword)
    keyword = options[:regexp]
  end</p>

<p>exit_now! &#39;search term or --regexp/-p required&#39; if keyword.nil?</p>

<p>keyword = keyword.dup
  highlighter = Hl::Highlighter.new(options)</p>

<p>puts highlighter.highlight(filenames,keyword)
end
```</p>

<p>This is the sort of logic you want in your <code>main</code> block:</p>

<ul>
<li>Handling the keyword-from-argument and keyword-from-command-line-option case</li>
<li>Simple error checking</li>
<li>Duping the keyword (since it comes in frozen)</li>
<li>Calling our <code>Highlighter</code> class to do the real work</li>
</ul>

<p>We defer all non-UI logic to the <code>Highlighter</code> class.  I decided to make each instance of the class able to highlight any files repeatedly based on a configuration, so the constructor takes in the formatting options, and the method <code>highlight</code> takes the list of filenames and the search term.</p>

<p>The actual highlighting is made possible via lots of list comprehension:</p>

<p><code>ruby Learn you some list comprehensions
files.map { |_| _.readlines}.flatten.map { |_| highlight_matches(regexp,_) }.join(&quot;&quot;)
</code></p>

<p>If you aren&#39;t comfortable with this use of chained calls, it can be very powerful.  What this does is:</p>

<ul>
<li>Map each file to an array of its contents as lines.  <code>[foo,bar]</code> becomes <code>[ [&#39;first line of foo\n&#39;,&#39;second line of foo\n&#39;],[&#39;first line of bar\n&#39;],[&#39;second line of bar\n&#39;]]</code></li>
<li>Flatten that array of arrays to just one list of all lines of all files.  Our example array becomes: <code>[ &#39;first line of foo\n&#39;,&#39;second line of foo\n&#39;,&#39;first line of bar\n&#39;,&#39;second line of bar\n&#39;]</code></li>
<li>map those lines to the lines with the search term highlighted.  Supposing we wanted to highlight the word &quot;line&quot;, our array becomes: <code>[ &#39;first \e[33mline\e[0m of foo\n&#39;,&#39;second \e[33mline\e[0m of foo\n&#39;,&#39;first \e[33mline\e[0m of bar\n&#39;,&#39;second \e[33mline\e[0m of bar\n&#39;]</code></li>
<li>join them all together into one big string
<code>&quot;first \e[33mline\e[0m of foo\nsecond \e[33mline\e[0m of foo\nfirst \e[33mline\e[0m of bar\nsecond \e[33mline\e[0m of bar\n&quot;</code></li>
</ul>

<p>Granted, this approach will probably have trouble with extremely large input, but <code>hl</code> was designed to work with the output of <code>grep</code>, so hopefully we won&#39;t have too much (I&#39;ve already decided I need it [to work with <code>tail</code>][streaming-bug] ).</p>

<h2>Breaking the rules</h2>

<p>Color and formatting <em>are not</em> typically associated with awesome command-line apps; too much of it makes an app hard to use with other apps.  But, the whole purpose of <code>hl</code> is to colorize output, so for that, I used [rainbow][rainbow], which is a pretty
simple enhancement to <code>String</code> that allows coloring and formatting.  We can see it in action in the <code>highlight_string</code> method of <code>Highlighter</code>:</p>

<p><code>ruby highlight_string
def highlight_string(string)
  string = string.color(@options[&#39;color&#39;].to_sym)
  string = string.inverse if @options[:inverse]
  string = string.bright if @options[:bright]
  string = string.underline if @options[:underline]
  string
end
</code></p>

<p>Each method called on <code>string</code> is a method provided by Rainbow.  These methods return a new string with the appropriate ANSI escape codes added.</p>

<h2>In Conclusion</h2>

<p>Hopefully, you&#39;ve seen that it&#39;s really <em>not that hard</em> to make an awesome command-line app.  I was able to write <code>hl</code> in just a few hours, using TDD and the end result is a highly polished, well-documented, easily installable and maintainable piece of software that will be a part of my command-line arsenal for quite a while.  You can do this, too.  There&#39;s a lot more detail and in-depth explanations [in my book][clibook], which you should buy right now :)</p>

<p>[clibook]: http://bit.ly/cli-hl-blog-post
[work]: http://www.livingsocial.com
[hl]: https://github.com/davetron5000/hl
[toc]: http://www.awesomecommandlineapps.com
[methadone]: https://github.com/davetron5000/methadone
[optionparser]: http://ruby-doc.org/stdlib-1.9.3/libdoc/optparse/rdoc/OptionParser.html
[ronn]: https://github.com/rtomayko/ronn
[argf]: http://ruby-doc.org/core-1.9.3/ARGF.html
[argfbug]: https://github.com/davetron5000/methadone/issues/34
[tdd]: http://en.wikipedia.org/wiki/Test-driven<em>development
[aruba]: https://github.com/cucumber/aruba
[rainbow]: https://github.com/sickill/rainbow
[methadone</em>intro]: http://www.naildrivin5.com/blog/2011/12/19/methadone-the-awesome-cli-library.html
[hl-readme]: https://github.com/davetron5000/hl/blob/master/README.md
[streaming-bug]: https://github.com/davetron5000/hl/issues/1</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/03/23/slides-from-my-talk-on-jruby-and-threads.html">Slides from my Talk on JRuby and Threads</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-03-23T11:49:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><script src="http://speakerdeck.com/embed/4f6cca6eaa99e4002200aea3.js"></script>

<p><a href="https://github.com/davetron5000/jruby-and-threads-talk">Here&#39;s a link to download</a> from my talk on JRuby and Threads.</p>

<p>If you just want the &quot;exercises&quot;, here they are:</p>

<!-- more -->

<h2>Echo Server</h2>

<ul>
<li>Listen on a port</li>
<li>Respond to each request in a new Thread</li>
<li><strong>Extra Credit</strong>: Record stats on requests in a shared data structure</li>
</ul>

<h2>Connection Pool</h2>

<ul>
<li>Allow N clients to access X shared instances of, say, Redis (where N &gt; X)</li>
<li>Clients &quot;check out&quot; a connection and get exclusive access</li>
<li>Clients &quot;check in&quot; when done</li>
<li>Instances get re-used</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/03/19/trailer-for-my-book.html">Trailer for my Book</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-03-19T08:14:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>The trailer for <a href="http://pragprog.com/titles/dccar">my book</a>, check it out:</p>

<iframe width="640" height="480" src="http://www.youtube.com/embed/cNkPSCCODdc" frameborder="0" allowfullscreen></iframe>

<p>It&#39;s a nonsensical journey through the computer, ending on the command-line.  It&#39;s got drama, special effects, and a stern
soundtrack :)</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/02/23/something-fun-im-working-on.html">Something fun I'm working on</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-02-23T20:58:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p><img src="http://distilleryimage9.instagram.com/ea3ca4185e8a11e180c9123138016265_7.jpg" alt="image"></p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/02/22/quote-mocking-and-dynamic-typing.html">Quote: Mocking and Dynamic Typing</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-02-22T09:15:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><blockquote>
<p>When mocking and dynamic typing travel in the same cart, the riders believe nothing can stand in their way. Their movements become headlong - faster and faster and faster. They put aside all thoughts of obstacles and forget the precipice does not show itself to the man in a blind rush until it&#39;s to late.</p>
</blockquote>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="9">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="7">Newer &rarr;</a>
    
  </div>
</div>

</body></html>
