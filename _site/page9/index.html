
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="XXX">

  
  <meta name="description" content="
  
  
  
    
      
  
    &#10106;&#10144; Mountain Lion Does Not Concern Me
  
  
    
      








  




    
  


  Apple has just announc...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/page9/index.html">
  <link href="/favicon.png" rel="icon">
  <link href="" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <div class="blog-index">
  
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/02/19/mountain-lion-does-not-concern-me.html">&#10106;&#10144; Mountain Lion Does Not Concern Me</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-02-19T12:09:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>Apple has just announced <a href="http://www.apple.com/macosx/mountain-lion/">Mountain Lion</a>, the next version of OS X, due out in the summer.  Although it&#39;s more of an incremental upgrade than Lion was<a name="back-1"></a><sup><a href="#1">1</a></sup>, one of the most interesting features is <a href="http://www.apple.com/macosx/mountain-lion/security.html">Gatekeeper</a>.  Gatekeeper, in brief, prevents unsigned code from running on OS X.  Although it can be disabled, it&#39;s on by default, and many feel this is the beginning of the end for users having full control of their computers.  I feel the opposite: it&#39;s <em>not</em> a slippery slope, and it&#39;s actually a <em>great</em> feature.<br>
&lt;!-- more --&gt;</p>

<p>With the release of the <a href="http://www.apple.com/mac/app-store/">Mac App Store</a>, it was clear that Apple wanted users managing third-party software much as they do on iOS devices: blessed apps vetted by Apple.  <a href="http://www.marco.org">Marco Arment</a> has written <a href="http://www.marco.org/2011/02/04/ode-to-the-app-review-team">in detail</a> about how this approval process isn&#39;t that bad and that it&#39;s a net gain for users:</p>

<blockquote>
<p>First and foremost, the review process has created a level of consumer confidence and risk-taking that has enabled the entire iOS app market to be far bigger and healthier than anyone expected. Average people — the same people who have been yelled at for decades for clicking on the wrong button on the wrong incomprehensible dialog box and messing up their computers — can (and do) confidently buy large quantities of inexpensive apps impulsively, without having to worry that any of them will “break” their iPhones or iPads, rip them off, destroy their data, or require them to embarrassingly visit the corporate IT department, the Geek Squad, or their computer-savvy relatives (us) for help. Part of this is due to the highly sandboxed architecture enforced by the OS, but a big part is the app review process.</p>
</blockquote>

<p>When Lion was released, there was a general feeling of fear amongst developers that, someday soon, the App Store would be the <em>only</em> way to get apps onto your Mac.  This would, in turn, destroy many useful apps that would just never make it through the review process (and, presumably, make development on a Mac much more difficult or impossible).  With what we know about Mountain Lion, it&#39;s clear that this dystopian future is not what Apple has in mind.  Gatekeeper is the proof.</p>

<p><a href="http://www.daringfireball.net">John Gruber</a> sums Gatekeeper up nicely in his <a href="http://daringfireball.net/2012/02/mountain_lion">piece on Mountain Lion</a> (emphasis mine):</p>

<blockquote>
<p>It’s a system whereby developers can sign up for <strong>free-of-charge Apple developer IDs</strong> which they can then use to cryptographically sign their applications. If an app is found to be malware, Apple can revoke that developer’s certificate, rendering the app (along with any others from the same developer) inert on any Mac where it’s been installed. In effect, it offers all the security benefits of the App Store, except for the process of approving apps by Apple.</p>
</blockquote>

<p>Finally, the feature can be entirely disabled:</p>

<p><img src="http://images.apple.com/macosx/mountain-lion/images/security_settings.jpg" alt="&#39;Mountain Lion Security Preferences&#39;"></p>

<p>I think Apple would prefer &quot;Mac App Store only&quot; as the default.  Honestly, so would I.  I&#39;d love to send my parents or sister a Mac that they simply <em>can&#39;t fuck up</em>.  <em>Many</em> grey hairs on my head are attributable to the trouble my family has gotten into with their PCs.  Granted, it&#39;s harder to get into this trouble with a Mac, but it&#39;s still possible.  And, as the Mac starts to take over <a href="http://www.asymco.com/2012/01/16/apple-is-the-top-personal-computer-vendor/">more and more of the PC market</a>, it will increasingly become a target for malware.</p>

<p>I think it&#39;s hard to argue that for &quot;regular&quot; users (and those of us doomed to support them), Gatekeeper is a net positive.</p>

<p>What about us developers?  Is this a win for us?  There&#39;s certainly a few unknowns:</p>

<ul>
<li>How does software installed via &quot;traditional&quot; means interact with this system?  If I download and compile the latest version of Ruby, but have Gatekeeper on, will it work?</li>
<li>What about software written in a scripting language?  What if I <code>gem install</code> a Ruby command-line application (something I have a <a href="http://www.awesomecommandlineapps.com">vested interest in being able to do</a>), will it work?</li>
<li>Will the option to &quot;allow applications downloaded from&hellip;anywhere&quot; go away in a future version of OS X?</li>
</ul>

<p>It&#39;s hard to predict the answers to these questions without knowing more about how Gatekeeper works.  I <em>do</em> think that the mere existence of Gatekeeper&#39;s allowance of signed-but-not-from-the-App-Store-apps demonstrates Apple&#39;s understanding that developers and &quot;power users&quot; are important to the platform.  Think about it: what&#39;s in it for Apple to disallow unsigned applications completely?  What would Apple have to gain by making it difficult (or impossible) to write non-Mac software on a Mac?</p>

<p>Don&#39;t forget, many iOS and Mac apps are backed by web services written using tools like Ruby on Rails, PHP, or Java.  If Apple were to make it difficult (or impossible) to write, say, a Rails app on a Mac, it would be much more difficult to write an iOS app; the developer would need a second machine to write the web service.  It just doesn&#39;t make sense.</p>

<p>So, I think Gatekeeper is a win for average users, a win for geeks, and <em>not a concern</em> for developers.    As such, I&#39;m in favor of it.</p>

<hr>

<footer class='footnotes'>
<ol>
<li>
<a name='1'></a>
<sup>1</sup>I think Apple's plan of updating OS X every year is a good one - more releases with smaller features is just a better way of doing things.  I also wonder if the price of OS X is going to drop even further, to say $9.99?<a href='#back-1'>↩</a>
</li>
</ol></footer>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/02/16/even-more-clean-tests-magic-values.html">Even More Clean Tests:Magic Values</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-02-16T18:50:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>In the [last][cleantest1] two [posts][cleantest2] about &quot;clean tests&quot;, we talked about the structure of a test, how to eliminate duplication, and how to make intent clear when using mocks.  We left off with a question of [magic values][magicvalues]: Why do we seem to use them in our tests, when we <em>know</em> they are wrong in production code?  Let&#39;s explore that and see how to eliminate their use in our tests without making the tests hard to understand.  </p>

<!-- more -->

<p>In non-test code, pretty much <em>any</em> literal that isn&#39;t 0, 1, -1, the empty string, <code>nil</code>/<code>null</code>, or some universal constant like 60 (number of seconds in a minute), is a <em>magic value</em>.  A naked literal just sitting out there with no context makes code hard to understand, and we usually whisk them away inside a constant or injected value.  Suppose we come across this code:</p>

<p><code>ruby Horrible Magic Values
if percentage &lt; 0.75
  show_graph
else
  show_no_data
end
</code></p>

<p>We want to know what <code>0.75</code> actually <em>means</em>.  If we&#39;d used a constant, it would be clearer, like so:</p>

<p><code>ruby No Magic, No Problems
if percentage &gt; THRESHOLD_FOR_DATA_DISPLAY
  show_graph
else
  show_no_data
end
</code></p>

<p>Now we know that we&#39;re comparing our percentage against a threshold and not some arbitrary value.</p>

<p>Tests, on the other hand, require a lot of literals, because we tend to be setting up very specific conditions, and that&#39;s much easier with an <em>example</em> of some input.  Here&#39;s a test for our <code>Saluation</code> class that we&#39;ve seen before:</p>

<p><code>ruby Magic Values in a Test
def test_full_name
  # Given
  person = Person.new(&quot;David&quot;,&quot;Copeland&quot;,:male)
  salutation = Salutation.new(person)
  # When
  greeting = salutation.greeting
  # Then
  assert_equal &quot;Hello, David!&quot;,greeting
end
</code></p>

<p>We have four magic values:</p>

<ul>
<li><code>&quot;David&quot;</code></li>
<li><code>&quot;Copeland&quot;</code></li>
<li><code>:male</code></li>
<li><code>&quot;Hello, David!&quot;</code></li>
</ul>

<p>Do these all need to be in there?  Which ones are actually relevant, and which are true magic values that we should eliminate?</p>

<p>You&#39;ll recall that in the [first post][cleantest1] on clean tests, we made this test clearer via <em>method extraction</em>, like so:</p>

<p>```ruby Clear test with methods
def test<em>full</em>name
  # Given
  person = person<em>with</em>full_name(&quot;David&quot;)
  salutation = Salutation.new(person)</p>

<p># When
  greeting = salutation.greeting</p>

<p># Then
  assert_equal &quot;Hello, David!&quot;,greeting
end
```</p>

<p>Essentially, we&#39;ve hidden the fact that the last name and gender don&#39;t matter inside the <code>person_with_full_name</code> method.  Some developers would object to this, preferring to have each test method stand on its own, without chasing down lots of helpers.  This is a fair point, so let&#39;s get rid of some irrelevant magic strings another way:</p>

<p>```ruby Clear test with no helpers or magic values
def test<em>full</em>name
  # Given
  person = Person.new(&quot;David&quot;,any<em>string,any</em>gender)
  salutation = Salutation.new(person)</p>

<p># When
  greeting = salutation.greeting</p>

<p># Then
  assert_equal &quot;Hello, David!&quot;,greeting
end</p>

<p>private </p>

<p>def any_string
  Faker::Lorum.words(5).join(&#39;&#39;)
end</p>

<p>def any_gender
  rand(2) == 1 ? :female : :male
end
```</p>

<p>We&#39;ve still got helper methods (<code>any_string</code> and <code>any_gender</code>), but they&#39;re tiny <em>and</em> they convey some information: the last name and the gender can be <em>anything</em>; they <em>don&#39;t matter</em>.  If you aren&#39;t familiar with [faker][faker], it&#39;s a handy gem for generating nonsense within certain parameters.  This is perfect for creating values that don&#39;t matter.</p>

<p>Does &quot;David&quot; matter?  It matters more than the last name and gender, since it will show up in our greeting, but the first name could just as easily be &quot;Mark&quot; or &quot;Mary&quot;.  So, let&#39;s eliminate this magic value as well:</p>

<p>```ruby Clear test with no magic values
def test<em>full</em>name
  # Given
  first<em>name = any</em>string
  person = Person.new(first<em>name,any</em>string,any_gender)
  salutation = Salutation.new(person)</p>

<p># When
  greeting = salutation.greeting</p>

<p># Then
  assert<em>equal &quot;Hello, #{first</em>name}!&quot;,greeting
end</p>

<p>private</p>

<p>def any_string
  Faker::Lorum.words(5).join(&#39;&#39;)
end</p>

<p>def any_gender
  rand(2) == 1 ? :female : :male
end
```</p>

<p>Now, we&#39;re talking!  Read the test, in English: &quot;first name is any string, a person has that as their first name, with any string as their last and any gender as their gender.  Make a salutation for that person, and get the greetting.  The greeting should equal &#39;Hello&#39; plus the first name&quot;.  We&#39;ve come <em>very</em> close to encoding a specification of our <code>Salutation</code> class without using a special test framework <em>or</em> magic values, and the <em>entire</em> test is in the test method.</p>

<p>Just to hammer this home, lets port over the test that handles the case when you have no first name:</p>

<p><code>ruby Could be clearer
def test_last_name_only_male
  # Given
  person = Person.new(nil,&quot;Copeland&quot;,:male)
  salutation = Salutation.new(person)
  # When
  greeting = salutation.greeting
  # Then
  assert_equal &quot;Hello, Mr. Copeland!&quot;,greeting
end
</code></p>

<p>Here, <code>:male</code> is <em>very</em> relevant, but <code>&quot;Copeland&quot;</code> doesn&#39;t particularly matter:</p>

<p><code>ruby Clear
def test_last_name_only_male
  # Given
  last_name = any_string
  person = Person.new(nil,last_name,:male)
  salutation = Salutation.new(person)
  # When
  greeting = salutation.greeting
  # Then
  assert_equal &quot;Hello, Mr. #{last_name}!&quot;,greeting
end
</code></p>

<p>With syntax highlighing, the relevant parts of the test literally <em>jump</em> out at you.  <code>:male</code> and <code>nil</code> are the <em>only</em> literals in this test, and they are therefore important.  </p>

<p>By removing as many magic values as possible, and replacing them with the <em>most general possible value</em> to satisfy the test, we can make it crystal clear what&#39;s going on in each test.</p>

<p>Can we carry this concept further?  Consider the variable <code>person</code> in the last test.  Is this variable relevant?  Somewhat.  It is as relevant as <code>salutation</code> or <code>greeting</code>?  No.  <code>salutation</code> is the object under test, and <code>greeting</code> is the value we&#39;re testing.  Further, <code>last_name</code> is a value that&#39;s part of the expected result.  To make <em>this</em> distinction clear, we can take advantage of Ruby&#39;s ability to define fields on the fly:</p>

<p><code>ruby Highlighting important values by promoting them to fields
def test_last_name_only_male
  # Given
  @last_name = any_string
  person = Person.new(nil,last_name,:male)
  @salutation = Salutation.new(person)
  # When
  @greeting = @salutation.greeting
  # Then
  assert_equal &quot;Hello, Mr. #{@last_name}!&quot;,@greeting
end
</code></p>

<p>This might seem superfluous in such a small test, but in a larger, more complex test (especially one dealing with a lot of mocks), this can be really helpful.  You know that so-called &quot;at&quot; variables are important, and their values are meaningful across the &quot;Given/When/Then&quot; of the test, however local variables or short-lived and can be skimmed over when first understanding the test.</p>

<h2>Setup/Teardown</h2>

<p>Let&#39;s have a brief word on setup and teardown methods.  I&#39;ve seen a lot of tests use the <code>setup</code> method to set up various mock expectations, or do other test-specific setup.  A problem arises when you need to add a test that doesn&#39;t require that setup, or perhaps requires some additional setup.  This causes two problems:</p>

<ul>
<li>You must now piece together what the &quot;Givens&quot; of a particular test are</li>
<li>You are setting up conditions that aren&#39;t relevant to all tests</li>
</ul>

<p>Using nested contexts in tools like [RSpec][rspec] exacerbates this greatly, and it&#39;s not uncommon to have setup code littered
throughout the file.</p>

<p>I would suggest you keep all test-specific setup out of the <code>setup</code> method entirely.  Ideally, you won&#39;t even have one.  Occasionally, you&#39;ll need to set up something around global variables that can&#39;t be easily injected into your code.  More commonly, you&#39;ll have a <code>teardown</code> method to make sure the next test has a clean slate (e.g. clean up temp files, restore configuration to default, etc.).  These are OK.  What you want to avoid is having any &quot;Givens&quot; or &quot;Thens&quot; inside these methods.</p>

<h2>Conclusion</h2>

<p>This brings us to the end of my whirlwind tour of clean tests.  The overall goal is to prioritize <em>comprehensibility</em> of tests without sacrificing too much ease of creation.  Your tests are going to be read and modified a <em>lot</em> more than written.  In summary:</p>

<ul>
<li>Structure your tests in three parts: Given (setup), When (action), Then (assertions).</li>
<li>Mock expectations <em>are assertions</em>, so put them in the &quot;Then&quot; block, and repeat the Given/When/Then if you need to due to your mocking framework.</li>
<li>Don&#39;t duplicate test code that&#39;s the same <em>by design</em>, but <em>do</em> duplicate it if it&#39;s the same by <em>happenstance</em>.</li>
<li>Values important to a test should be variables.</li>
<li>Values irrelevant to a test should be hidden in &quot;any&quot; style methods.</li>
<li>If these rules muddy your tests, break them.</li>
</ul>

<h2>Afterword</h2>

<p>I&#39;ve been working this way for several months, and developed the [clean_test][cleantest] gem to help.  I&#39;ll introduce that in a future blog post, but look at some of the [tests][methodone-tests] written using these techniques.  I tend to prefer knowledge be stored digitally, and not in my brain, so these techniques really help.  Try writing your next set of tests like this and see what you think!</p>

<p>[cleantest1]: http://www.naildrivin5.com/blog/2012/01/08/make-tests-clean-and-clear-without-duplication.html
[cleantest2]: http://www.naildrivin5.com/blog/2012/01/16/more-clean-tests-handling-mocks.html
[magicvalues]: http://en.wikipedia.org/wiki/Magic<em>number</em>(programming)
[cleantest]: https://github.com/davetron5000/clean<em>test
[methodone-tests]: https://github.com/davetron5000/methadone/blob/master/test/test</em>sh.rb
[faker]: http://faker.rubyforge.org/
[rspec]: http://rspec.info/</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/01/30/avoid-kingdom-of-nouns-with-procs.html">Avoid the Kingdom of Nouns with Procs</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-01-30T09:00:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>Hopefully you&#39;ve read Steve Yegge&#39;s excellent [kingdom of nouns][nouns] essay, in which he bemoans a pattern that exists in a lot of Java-base systems.  The tell-tale sign is a class named <code>ThingDoer</code> with a single method <code>doThing()</code>.  Systems like this don&#39;t arise simply because Java is the way it is, but when you follow [SOLID][solid] principles (particularly the [single responsibility][SRP] and [dependency inversion][DI] principles), your code ends up with lots of small classes that do one thing only.</p>

<p>In Java, you are basically stuck with this, but in Ruby (or any OO language that supports closures/blocks/functions), we can fight this by using Procs instead of classes.</p>

<!-- more -->

<h2>SOLIDifying some code</h2>

<p>First, let&#39;s take some code that needs refactoring and see what it looks like with classes.  We&#39;ll look at a very simple base class for handling events in a system based on [Resque][resque].  Our base class allows us to do two things that a generic Resque event can&#39;t: retry events later, and queue arbitrary events.  Let&#39;s have a look at the code<a name="back-1"></a><sup><a href="#1">1</a></sup>:</p>

<p>```ruby Base class for handle events
class Event::Base</p>

<p>def self.perform(params)
    self.new.perform(params)
  end</p>

<p>def perform(params)
    raise &quot;subclass must implement&quot;
  end</p>

<p>protected</p>

<p>def self.queue<em>event(klass,options)
    Resque.enque(klass,options.merge({ :queued</em>at =&gt; Time.now }))
  end</p>

<p>def self.requeue<em>later(params)
    new</em>params = { :attempt<em>number =&gt; 0 }.merge(params)
    new</em>params[:attempt_number] += 1</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">raise &quot;Requeued too many times&quot; if new_params[:attempt_number] &gt; 5

sleep(new_params[:attempt_number])
queue_event(class,new_params)
</code></pre></div>
<p>end
end
```</p>

<p>We might use this like so:</p>

<p><code>ruby Simple event class
class RenameEvent &lt; Event::base
  def perform(params)
    if person = Person.find_by_id(params[:person_id]).nil?
      requeue_later(params)
    else
      person.name = params[:name]
      person.save!
    end
  end
end
</code></p>

<p>Our base class is doing too much.  It&#39;s OK for it to provide the queuing and re-queuing functionality, but it shouldn&#39;t be implemented there.  Further, there&#39;s aspects of <em>how</em> the functionality is implemented that we might want to be able to change in our subclasses.  This is the perfect application for dependency inversion.</p>

<p>In our naive approach, we&#39;ll make one class for each function we have, namely:</p>

<ul>
<li>A class to queue events onto Resque, adding in the <code>queued_at</code> timestamp</li>
<li>A class to orchestrate requeuing events, failing after a certain number of attempts</li>
<li>A class to sleep and perform the actual requeuing</li>
<li>Our base class to provide access to these features</li>
</ul>

<p>Let&#39;s have a look:</p>

<p><code>ruby Queuer class
class Queuer
  def queue(klass,options)
    Resque.enque(klass,options.merge({ :queued_at =&gt; Time.now }))
  end
end
</code></p>

<p>```ruby Requeuer
class Requeuer
  def initialize(requeue<em>strategy,max</em>attempts=5)
    @requeue<em>strategy = requeue</em>strategy
    @max<em>attempts = max</em>attempts
  end</p>

<p>def requeue(klass,options)
    new<em>params = { :attempt</em>number =&gt; 0 }.merge(params)
    new<em>params[:attempt</em>number] += 1</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">raise &quot;Requeued too many times&quot; if new_params[:attempt_number] &gt; @max_attempts

@requeue_strategy.requeue(klass,new_params[:attempt_number],options)
</code></pre></div>
<p>end
end
```</p>

<p>```ruby RequeueStrategy
class RequeueStrategy
  def initialize(queuer)
    @queuer = queuer
  end</p>

<p>def requeue(klass,attempt<em>number,options)
    sleep(attempt</em>number)
    @queuer.queue(klass,options)
  end
end
```</p>

<p>Whew!  Now, to use all this, our base class becomes:</p>

<p>```ruby A now SOLID base class
class Event::Base</p>

<p>def initialize(requeuer=nil)
    @requeuer = requeuer || Requeuer.new(RequeueStrategy.new(Queuer.new))
  end</p>

<p>def self.perform(params)
    self.new.perform(params)
  end</p>

<p>def perform(params)
    raise &quot;subclass must implement&quot;
  end</p>

<p>protected</p>

<p>def requeue_later(params)
    @requeuer.requeue(self.class,params)
  end
end
```</p>

<p>Our base class is a <em>lot</em> cleaner, and we can now test it more easily without [mocks making things difficult][cleantest].</p>

<p>But, we&#39;re firmly in the Kingdom of Nouns, e.g. <code>queuer.queue()</code>.  We&#39;d like to keep our code nicely designed, but get rid of the superfluous naming and structure around the tiny bits of code we have.  Let&#39;s use Procs.</p>

<h2>Procs instead of classes</h2>

<p>The easiest class to convert to a <code>Proc</code> is going to be <code>Queuer</code>, since it has no real dependencies and is just a wrapper around a very simple line of code:</p>

<p>```ruby Base class using a Proc instead of Queuer
class Event::Base</p>

<p>QueueEvent = lambda { |klass,params|
    Resque.enque(klass,options.merge({ :queued_at =&gt; Time.now }))
  }</p>

<p>def initialize(requeuer=nil)
    @requeuer = requeuer || Requeuer.new(RequeueStrategy.new(QueueEvent))
  end</p>

<p>def self.perform(params)
    self.new.perform(params)
  end</p>

<p>def perform(params)
    raise &quot;subclass must implement&quot;
  end</p>

<p>protected</p>

<p>def requeue_later(params)
    @requeuer.requeue(self.class,params)
  end
end
```</p>

<p><code>RequeueStrategy</code> now becomes:</p>

<p>```ruby RequeueStrategy using a Proc instead of a class
class RequeueStrategy
  def initialize(queue<em>event)
    @queue</em>event = queue_event
  end</p>

<p>def requeue(klass,attempt<em>number,options)
    sleep(attempt</em>number)
    @queue_event.call(klass,options)
  end
end
```</p>

<p>Notice that we&#39;re using the name <code>queue_event</code> instead of <code>queuer</code>.  A Proc isn&#39;t, conceptually, a thing, but an action that we&#39;re passing around, so we name it as such.  </p>

<p>Of course, <code>RequeueStrategy</code> itself isn&#39;t much code; can we convert that?  The tricky part is that <code>RequeueStrategy</code> requires the ability to queue events and thus needs a <code>Queuer</code>.  We pass this in the constructor, which a <code>Proc</code> doesn&#39;t really have (at least conceptually).  Instead, we&#39;ll pass the queueing code in as a parameter to our newly re-made <code>SleepThenRequeue</code> <code>Proc</code>, which is now part of our base class.</p>

<p>```ruby Base class with RequeueStrategy now a Proc
class Event::Base</p>

<p>SleepThenRequeue = lambda { |queue<em>event,klass,attempt</em>num,options|
    sleep(attempt<em>number)
    queue</em>event.call(klass,options)
  }</p>

<p>QueueEvent = lambda { |klass,params|
    Resque.enque(klass,options.merge({ :queued_at =&gt; Time.now }))
  }</p>

<p>def initialize(requeuer=nil)
    @requeuer = requeuer || Requeuer.new(QueueEvent,SleepThenRequeue)
  end</p>

<p>def self.perform(params)
    self.new.perform(params)
  end</p>

<p>def perform(params)
    raise &quot;subclass must implement&quot;
  end</p>

<p>protected</p>

<p>def requeue_later(params)
    @requeuer.requeue(self.class,params)
  end
end
```</p>

<p>We now need to update <code>Requeuer</code> to hold onto the <code>QueueEvent</code> <code>Proc</code> so that it can pass it to the <code>SleepThenRequeue</code> <code>Proc</code>:</p>

<p>```ruby Requeuer updated
class Requeuer
  def initialize(queue<em>event,requeue</em>event,max<em>attempts=5)
    @queue</em>event = queue<em>event
    @requeue</em>event = requeue<em>event
    @max</em>attempts = max_attempts
  end</p>

<p>def requeue(klass,options)
    new<em>params = { :attempt</em>number =&gt; 0 }.merge(params)
    new<em>params[:attempt</em>number] += 1</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">raise &quot;Requeued too many times&quot; if new_params[:attempt_number] &gt; @max_attempts

@requeue_event.call(@queue_event,klass,new_params[:attempt_number],options)
</code></pre></div>
<p>end
end
```</p>

<p>Now, our system has all the flexbility, testability, and comprehensibility that we get from applying SOLID principles, but we don&#39;t have any of the baggage and boilerplate of making actual classes that are mere wrappers for simple functionality.  </p>

<h2>Taking Advantage</h2>

<p>Let&#39;s see how this works be implementing a second requeuing strategy.  Suppose a subclass wants to have retried events go onto a different queue, instead of sleeping and re-queuing.  To enable this, we first make our base class a bit more configurable by introducing the method <code>self.requeue_strategy</code>, which returns a <code>Proc</code>.  The base class&#39; implementation will simply return <code>SleepThenRequeue</code>.</p>

<p>```ruby Base class with multiple requeueing strategies
class Event::Base</p>

<p>QueueEvent = lambda { |klass,params|
    Resque.enque(klass,options.merge({ :queued_at =&gt; Time.now }))
  }</p>

<p>SleepThenRequeue = lambda { |queue<em>event,klass,attempt</em>num,options|
    sleep(attempt<em>number)
    queue</em>event.call(klass,options)
  }</p>

<p>def initialize(requeuer=nil)
    @requeuer = requeuer || Requeuer.new(QueueEvent,self.class.requeue_strategy)
  end</p>

<p>def self.perform(params)
    self.new.perform(params)
  end</p>

<p>def perform(params)
    raise &quot;subclass must implement&quot;
  end</p>

<p>protected</p>

<p>def self.requeue_strategy
    SleepThenRequeue
  end</p>

<p>def requeue_later(params)
    @requeuer.requeue(self.class,params)
  end
end
```</p>

<p>Now, our subclass can return something else, but it <em>won&#39;t</em> have to make an entire class to do so:</p>

<p>```ruby Event that uses a different requeue strategy
class SomeEvent &lt; Event::Base</p>

<p>protected</p>

<p>def self.requeue<em>strategy
    lambda { |queue</em>event,klass,attempt<em>num,options|
      queue</em>event.call(klass,options.merge(:queue =&gt; &#39;scheduled&#39;, 
                                           :for =&gt; Time.now + attempt_num.minutes)
    }
  end
```</p>

<p>Of course, we&#39;re not constrained by Procs; after all a <code>Proc</code> is just a structural type for an object that reponds to <code>call</code>.  If
we needed some really complex requeuing, we could make a class:</p>

<p><code>ruby Using a class if we need to
class ComplexRequeueingStrategy
  def call(queue_event,klass,attempt_num,options)
    # Do whatever
  end
end
</code></p>

<p>This results in a much more flexible system that keeps ceremony, boilerplate, and noise to a minimum; the majority of our code is
the &quot;business logic&quot; or &quot;necessary complexity&quot;.</p>

<h2>Conclusions</h2>

<p>Of course, we can take this too far.  Suppose we made <code>Requeuer</code> into a <code>Proc</code>.  It would start getting cumbersome, since it has so many dependent objects to manage; a class is actually helpful here<a name="back-2"></a><sup><a href="#2">2</a></sup>.  </p>

<p>Just because Ruby is object-oriented doesn&#39;t mean that every bit of functionality has to live inside a method of a class.  A <code>Proc</code> is tailor-made to hold functionality and pass it around, so don&#39;t be afraid to use it if the situation warrants.</p>

<p>[dip]: http://en.wikipedia.org/wiki/Dependency<em>inversion</em>principle
[solid]: http://en.wikipedia.org/wiki/SOLID<em>(object-oriented</em>design)
[resque]: https://github.com/defunkt/resque
[DI]: http://en.wikipedia.org/wiki/Dependency<em>injection
[SRP]: http://en.wikipedia.org/wiki/Single</em>responsibility_principle
[cleantest]: http://www.naildrivin5.com/blog/2012/01/16/more-clean-tests-handling-mocks.html
[nouns]: http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html</p>

<hr>

<footer class='footnotes'>
<ol>
<li>
<a name='1'></a>
<sup>1</sup>We have this awkward <code>self.process</code> because Resque calls a class method; we just create an instance and deal with that, as it's easier to test and implement as a normal class<a href='#back-1'>↩</a>
</li>
<li>
<a name='2'></a>
<sup>1</sup>In a more functional-oriented approach, this can be solved via <a href="http://en.wikipedia.org/wiki/Currying">currying</a>.  Accomplishing this cleanly in Ruby is an exercise for the reader.<a href='#back-1'>↩</a>
</li>
</ol></footer>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/01/16/more-clean-tests-handling-mocks.html">More Clean Tests: Handling Mocks &amp; Block-based asserts</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-01-16T11:58:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>In a <a href="http://www.naildrivin5.com/blog/2012/01/08/make-tests-clean-and-clear-without-duplication.html">previous post</a>, I talked
about the overall structure of a test and how that was important to understand the test itself.  A brief review:</p>

<ul>
<li><em>Given</em> - Establish the conditions under which the test will run</li>
<li><em>When</em> - Run the code under test</li>
<li><em>Then</em> - assert that the code did what you expect</li>
</ul>

<p>This structure becomes problematic when using either mock objects or block-based asserts.</p>

<!-- more -->

<h2>The Trouble with Mocks</h2>

<p>When using <a href="http://en.wikipedia.org/wiki/Mock_object">mock objects</a> in a test, you typically use a
mocking framework (like <a href="http://mocha.rubyforge.org/">mocha</a>) to modify the behavior of objects the class-under-test collaborates with.
You often test that the class-under-test made certain calls to its collaborators.  Let&#39;s look at an example.</p>

<p>Suppose we have an existing system and we wish to start recording some statistics, such as the number of times a method is called
or how long a method takes to run.  We&#39;ve created a class, <code>Statistics</code>, that has some class methods on it to do the recording:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Statistics</span>
  <span class="c1"># Add one to stat_name</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="n">stat_name</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>We want to start using this class in our <code>Salutation</code> class to keep track of the number of times we&#39;re calling <code>#greeting</code>.
In order to add this in, we need to test that <code>Salutation#greeting</code> is calling <code>Statistics.count</code>.  While we could set up a fake
statistics server and examine it during our test, it&#39;s more straightforward to use mocks.  </p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">SalutationTest</span> <span class="o">&lt;&lt;</span> <span class="no">TestCase</span>
  <span class="k">def</span> <span class="nf">test_that_we_log_statistics</span>
    <span class="n">saluation</span> <span class="o">=</span> <span class="no">Salutation</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">Person</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;David&#39;</span><span class="p">,</span><span class="s1">&#39;Copeland&#39;</span><span class="p">,</span><span class="ss">:male</span><span class="p">))</span>
    <span class="no">Statistics</span><span class="o">.</span><span class="n">expects</span><span class="p">(</span><span class="ss">:count</span><span class="p">)</span><span class="o">.</span><span class="n">with</span><span class="p">(</span><span class="s1">&#39;saluation.greeting.count&#39;</span><span class="p">)</span>
    <span class="n">saluation</span><span class="o">.</span><span class="n">greeting</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>What will happen is, if we don&#39;t call <code>Statistics.count(&quot;saluation.greeting.count&quot;)</code> in the <code>Salutation</code> class, this test will
fail.  That&#39;s what a mocking framework like mocha does for us.</p>

<p>Of course, there&#39;s something odd about our test.  There&#39;s no call to any sort of <code>assert</code> method.  The Given/When/Then is very
unclear.  For a real-world test that requires a lot more setup, it can be even more difficult to see what&#39;s actually being
tested.  Essentially, the &quot;Given/When/Then&quot; is &quot;out of order&quot;:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">SalutationTest</span> <span class="o">&lt;&lt;</span> <span class="no">TestCase</span>
  <span class="k">def</span> <span class="nf">test_that_we_log_statistics</span>
    <span class="c1"># Given</span>
    <span class="n">saluation</span> <span class="o">=</span> <span class="no">Salutation</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">Person</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;David&#39;</span><span class="p">,</span><span class="s1">&#39;Copeland&#39;</span><span class="p">,</span><span class="ss">:male</span><span class="p">))</span>
    <span class="c1"># Then</span>
    <span class="no">Statistics</span><span class="o">.</span><span class="n">expects</span><span class="p">(</span><span class="ss">:count</span><span class="p">)</span><span class="o">.</span><span class="n">with</span><span class="p">(</span><span class="s1">&#39;saluation.greeting.count&#39;</span><span class="p">)</span>
    <span class="c1"># When</span>
    <span class="n">saluation</span><span class="o">.</span><span class="n">greeting</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<h2>Making our Intent Clear</h2>

<p>We&#39;d like to keep our test method in a canonical structure, or at least have some part of it follow the Given/When/Then
structure.  Unfortunately, our &quot;Then&quot;, the mock expectations, simply <em>have</em> to occur <em>before</em> the &quot;When&quot;.  I think
we can make it clearer, so let&#39;s add a bit of code to help.</p>

<p>First, we&#39;ll create a method named <code>when_the_test_runs_then</code> to clearly indicate that our expectations
are part of our &quot;Then&quot;, and that they are going to be checked when the test runs, which happens later.  We&#39;ll also add a no-op
method, <code>assert_mocks_were_called</code> that will allow our test to always have an assert and provide us with a way to be explicit
about what&#39;s being asserted.  Although this &quot;assert&quot; method doesn&#39;t do anything, it allows use to distinguish between &quot;this test
passes when the mocks are called as expected&quot; from &quot;I forgot to actually test for something&quot;.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">SalutationTest</span> <span class="o">&lt;&lt;</span> <span class="no">TestCase</span>
  <span class="k">def</span> <span class="nf">test_that_we_log_statistics</span>
    <span class="n">when_the_test_runs_then</span> <span class="p">{</span>
      <span class="no">Statistics</span><span class="o">.</span><span class="n">expects</span><span class="p">(</span><span class="ss">:count</span><span class="p">)</span><span class="o">.</span><span class="n">with</span><span class="p">(</span><span class="s1">&#39;saluation.greeting.count&#39;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1"># Given</span>
    <span class="n">saluation</span> <span class="o">=</span> <span class="no">Salutation</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">Person</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;David&#39;</span><span class="p">,</span><span class="s1">&#39;Copeland&#39;</span><span class="p">,</span><span class="ss">:male</span><span class="p">))</span>
    <span class="c1"># When</span>
    <span class="n">saluation</span><span class="o">.</span><span class="n">greeting</span>
    <span class="c1"># Then</span>
    <span class="n">assert_mocks_were_called</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">when_the_test_runs_then</span><span class="p">;</span> <span class="k">yield</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">assert_mocks_were_called</span><span class="p">;</span> <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>We&#39;ve still deviated from our canonical structure, but the test <em>reads</em> better: &quot;When the test runs then expect this method to be
called; now let&#39;s run the test&quot;</p>

<p>Of course, we&#39;ve just taken our first step out of &quot;plain old Ruby&quot; and created framework code.  This is the price you pay for
using mocks; testing with mocks complicate our tests.   By using some lightweight &quot;control structure&quot; helper methods, we can at
least make the intent clear.</p>

<h2>Block-Based Asserts Disrupt, too</h2>

<p>There&#39;s another pattern we see in tests that disrupts the structure in much the same way that the use of mocks does.  That
disruption is block-based asserts, the most common of which is <code>assert_raises</code>.  For example, suppose we&#39;re testing that our
<code>Saluation</code> class requires a non-<code>nil</code> <code>Person</code> in its constructor.  We could test that like so:</p>

<p><code>ruby Testing that code raises an Exception
def test_that_constructor_requires_a_person
  assert_raises ArgumentError do
    Salutation.new(nil)
  end
end
</code></p>

<p>This test is weird for two reasons: the first is that the &quot;Given&quot; is implicit.  The second is that the &quot;Then&quot; comes before the
&quot;When&quot;:</p>

<p><code>ruby The Given/When/Then of our block-based assertion test
def test_that_constructor_requires_a_person
  # Given - we are going to use a nil Person
  # Then
  assert_raises ArgumentError do
    # When
    Salutation.new(nil)
  end
end
</code></p>

<p>We can clean this up by creating a variable for our <code>nil</code> <code>Person</code> and putting our &quot;Then&quot; code inside a block, which we then pass
to <code>assert_raises</code>:</p>

<p><code>ruby More clear test with block-based assertions
def test_that_constructor_requires_a_person
  # Given
  nil_person = nil
  # When
  code = lambda { Salutation.new(nil_person) }
  # Then
  assert_raises(ArgumentError,&amp;code)
end
</code></p>

<p>We&#39;ve had to jump through a slightly awkward hoop of putting the code-under-test in a lambda, but now things are in a consistent
structure.  This example might seem a bit too simplisitc.  What about another popular block-based assertion, <code>assert_difference</code>?
It&#39;s commonly used in Rails apps to check that a certain number of records were written to the database.  While I think that this
assertion is generally not needed, it is commonly used.<br>
Here&#39;s an example where we suppose that an <code>after_save</code> hook is memoizing a
derived field for us.</p>

<p>```ruby Complex test using assert<em>difference
test &quot;we can save and our after-save hook runs, generating the full</em>name attribute&quot; do
  # Given
  first<em>name = &#39;David&#39;
  last</em>name = &#39;Copeland&#39;</p>

<p># Then
  assert<em>difference(&#39;Person.count&#39;) do
    # When
    person = Person.create(:first</em>name =&gt; first<em>name, last</em>name =&gt; last<em>name)
    # Then
    assert &#39;David Copeland&#39;,person.full</em>name
  end
end
```</p>

<p><em>Now</em> the structure is very strange.  If we try to apply our <code>lambda</code> solution above, it&#39;s still a bit odd:</p>

<p>```ruby Applying a lambda to our Rails test
test &quot;we can save and our after-save hook runs, generating the full<em>name attribute&quot; do
  # Given
  first</em>name = &#39;David&#39;
  last_name = &#39;Copeland&#39;</p>

<p># When
  code = lambda {
    person = Person.create(:first<em>name =&gt; first</em>name, last<em>name =&gt; last</em>name)
    # Then
    assert &#39;David Copeland&#39;,person.full_name
  }</p>

<p># Then
  assert_difference(&#39;Person.count&#39;,&amp;code)
end
```</p>

<p>Yikes.  This is arguably worse.  Since only one line of code inside our &quot;When&quot; block is really affecting the condition that
<code>assert_difference</code> tests for, we can take advantage of Ruby&#39;s ability to create instance variables on-demand and pass
the person outside of the <code>assert_difference</code> block:</p>

<p>```ruby Canonically-structured Rails test using assert<em>difference
test &quot;we can save and our after-save hook runs, generating the full</em>name attribute&quot; do
  # Given
  first<em>name = &#39;David&#39;
  last</em>name = &#39;Copeland&#39;</p>

<p># When
  create<em>person = lambda { 
    @person = Person.create(:first</em>name =&gt; first<em>name, last</em>name =&gt; last_name)
  }</p>

<p># Then
  assert<em>difference(&#39;Person.count&#39;,&amp;create</em>person)
  assert &#39;David Copeland&#39;,@person.full_name
end
```</p>

<p>That&#39;s much better; we can now clearly see the setup, the code being tested, and all the assertions together.</p>

<p>It may seem slightly unusual, but by working to keep all your tests structured around Given/When/Then, you will find them
readable weeks and months later, and others will be clearly able to see their intent.</p>

<h2>Next</h2>

<p>We still have a fair way to go to get our tests really clean and clear.  For example, do we need to have those <code>#Given</code>, <code>#When</code>,
and <code>#Then</code> comments
everywhere?  I <a href="http://www.naildrivin5.com/blog/2012/01/11/the-war-on-comments.html">think comments are powerful</a>, but having the same group of comments everywhere 
feels like repetition we can eliminate.
Another issue is the use of &quot;magic values&quot;, or literals, in our test code.  In the test above, we create a male person with the
name &quot;David Copeland&quot;.  Is any of this relevant to the test?  If not, why is it there?</p>

<p>We&#39;ll deal with these issues in the next post.</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/01/11/the-war-on-comments.html">The War on Comments</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-01-11T08:32:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>Code comments often get a bad rap, especially in the Ruby community, with phrases like &quot;code should be self-documenting&quot; floating around, legitimizing the production of code with no documentation at all.  In fact, code comments are one of the many useful tools developers have to make their intent clear, and writing them off as a &quot;code smell&quot; is naive and dangerous.</p>

<!-- more -->

<h2>The Two Types of Comments</h2>

<p>Before we dig in, it&#39;s important to understand that there are two types of comments.  There are comments that serve as <em>API Documentation</em> and comments that are, for lack of a better term, <em>explanatory</em>.</p>

<p>I&#39;m not going to argue that you should write API documentation for your public APIs.  You should, and anyone insisting that you shouldn&#39;t is just being lazy.  It&#39;s worth pointing out that API documentation comments are there to help you <em>write</em> code, primarily.  They help answer the question &quot;what code do I need to accomplish this task?&quot;.</p>

<p>The other type of comment, explanatory comments, are there to help you <em>read</em> code, and this is why they are so important to use and <strong>to get right</strong>.  Code is read many more times than written, and I doubt you&#39;ll find a professional developer who would argue <em>against</em> writing code for readability.</p>

<h2>Explanatory Comments</h2>

<p>Explanatory comments are those that seek to explain something about the code that the author (or maintiner) didn&#39;t feel was obvious from the code itself.  It&#39;s at this point that many will say that the mere existence of such comments is a <a href="http://en.wikipedia.org/wiki/Code_smell">code smell</a>, or indicator that the code should be rewritten in a more clear way.</p>

<p>This rule of thumb makes a lot of assumptions about what sort of comments one might write as well as the expressiveness of source code.  Comments that merely explain <em>what</em> the code does are, in fact, a code smell.  Comments that explain <em>why</em> the code was written a certain way, or even why it exists at all, are not.  Understanding <em>why</em> code is the way it can be is incredibly hard to encode in a programming language.  I still think &quot;what&quot; comments have their place, but let&#39;s tackle &quot;why&quot; comments, as these are a powerful tool for code authors and maintainers.</p>

<h3>&quot;Why&quot; Comments</h3>

<p>Let&#39;s take the example from my <a href="http://www.naildrivin5.com/blog/2012/01/08/make-tests-clean-and-clear-without-duplication.html">last blog entry</a>: a salutation class.  Suppose our system has the following implementation:</p>

<p>```ruby Initial Implementation of Salutation
class Salutation
  def initialize(person)
    @person = person
  end</p>

<p>def greeting
    if @person.honorific == :doctor
      &quot;Hello, Dr. #{person.last<em>name}!&quot;
    elsif @person.first</em>name.present?
      &quot;Hello, #{person.first<em>name}!&quot;
    elsif @person.male?
      &quot;Hello, Mr. #{person.last</em>name}!&quot;
    else
      &quot;Hello, Ms. #{person.last_name}!&quot;
    end
  end
end
```</p>

<p>This code is pretty clear, and it&#39;s easy to understand what it does.  A novice programmer might comment it like so:</p>

<p>```ruby Useless &quot;what&quot; comments
class Salutation
  def initialize(person)
    @person = person
  end</p>

<p>def greeting
    # Check if they are a doctor, otherwise
    # use their first name, falling back
    # to their gender
    if @person.honorific == :doctor
      &quot;Hello, Dr. #{person.last<em>name}!&quot;
    elsif @person.first</em>name.present?
      &quot;Hello, #{person.first<em>name}!&quot;
    elsif @person.male?
      &quot;Hello, Mr. #{person.last</em>name}!&quot;
    else
      &quot;Hello, Ms. #{person.last_name}!&quot;
    end
  end
end
```</p>

<p>We can all agree these comments add noise.  So what&#39;s missing from this picture that the code can&#39;t express?  Something that seems odd is the explicit check for the <code>honorific</code> of <code>:doctor</code>.  Why do we only check that one?  Clearly there can be other values for <code>honorific</code>; why don&#39;t we check those?</p>

<p>Code like this is all over the place in a real production application.  This is part of what makes the job of a programmer challenging. We get requirements that are sometimes odd and result in akward code that isn&#39;t as clean as the idealized code you&#39;d see in a book.  And so we have the dreaded <em>special case</em>, which results in code that sticks out like a sore thumb.</p>

<p>Code like this, at first, looks like a bug: &quot;Oh no!  What if someone registers with the honorific of &#39;Sir&#39;?  We&#39;re going to call them by their first name?&quot;.  Suppose in this case, it&#39;s not a bug.  Suppose in this case that this is intentional.  How would someone know that?</p>

<p>Explanatory Comments.</p>

<p>```ruby Helpful &quot;Why&quot; comments
class Salutation
  def initialize(person)
    @person = person
  end</p>

<p>def greeting
    # We special case :doctor because the Initech
    # style guide for messaging requires it, and we need
    # to be compliant with it.  Since we have very few users with
    # honorifics other than doctor, we don&#39;t want to get into a 
    # complex honorific mapping mapping situation right now, so
    # we just handle this one explcitly.
    if @person.honorific == :doctor
      &quot;Hello, Dr. #{person.last<em>name}!&quot;
    elsif @person.first</em>name.present?
      &quot;Hello, #{person.first<em>name}!&quot;
    elsif @person.male?
      &quot;Hello, Mr. #{person.last</em>name}!&quot;
    else
      &quot;Hello, Ms. #{person.last_name}!&quot;
    end
  end
end
```</p>

<p><strong>Now</strong> it makes sense.  We got some annoying requirement and had to meet it.  The reality of the data in our system made the cost of a more generalized soluation have little benefit, so we did the simplest thing that could possibly work <em>and</em> were nice enough to explain ourselves.</p>

<p>This is the sort of comment that is incredibly useful for understanding code.  I would argue that <em>any</em> time you do something weird or akward in your code, you should explain why you did it that way.  Future you will thank you in the following ways:</p>

<ul>
<li>You&#39;ll understand, six months from now, why you wrote what appears to be awkward code.</li>
<li>The maintainer of this code won&#39;t ask you about it.</li>
</ul>

<h3>Maintaining Comments</h3>

<p>The second criticism typically leveled against comments is that they become out of sync with the code.  Continuing our <code>Salutation</code> example, suppose we later get a requirement to special-case college professors.  The quick and dirty solution would be:</p>

<p>```ruby Crufty, inaccurate comments in light of change
class Salutation
  def initialize(person)
    @person = person
  end</p>

<p>def greeting
    # We special case :doctor because the Initech
    # style guide for messaging requires it, and we need
    # to be compliant with it, and have very few users with
    # other honorifics, so we don&#39;t want to get into a 
    # complex honorific mapping mapping situation right now
    if @person.honorific == :doctor
      &quot;Hello, Dr. #{person.last<em>name}!&quot;
    elsif @person.honorific == :professor
      &quot;Hello, Prof. #{person.last</em>name}!&quot;
    elsif @person.first<em>name.present?
      &quot;Hello, #{person.first</em>name}!&quot;
    elsif @person.male?
      &quot;Hello, Mr. #{person.last<em>name}!&quot;
    else
      &quot;Hello, Ms. #{person.last</em>name}!&quot;
    end
  end
end
```</p>

<p>Now the comment is out of sync with reality.  We have a nice explanation of special-casing <code>:doctor</code>, but not a word about <code>:professor</code>.  I would argue that the developer that wrote this code and called it &quot;done&quot; has been negligent.  He&#39;s <strong>not done his job</strong> and there&#39;s no excuse for this.  At the <em>very</em> least, he should replace the phrase &quot;We special case :doctor&quot; in the comment with &quot;We special case :doctor and :professor&quot;.  There&#39;s many better ways to meet the new requirement, but for the purpose of keeping our focus on comments, <em>you must keep the comments and the code in sync</em>.  That&#39;s the job.  </p>

<p>Hopefully, you can see that comments that explain <em>why</em> code is the way it is are important.  These sorts of comments are a powerful tool for expressing intent and making code readable, understandable, and clear, beause the reality is, not every problem that we have to solve can be done so in perfect-looking &quot;clean&quot; code.</p>

<p>So what about those &quot;what&quot; comments?  What about comments that explain <em>how</em> code works and <em>what</em> it&#39;s doing?  Those are certainly wrong in every case, right?  Not so.  Here&#39;s a (qualified) defense of those sorts of comments.</p>

<h2>Sometimes you need to explain what the code does</h2>

<p>I don&#39;t write perfect code.  My code isn&#39;t always written in the most elegant, understandable way.  Yours isn&#39;t either.  The reasons for this are many: we didn&#39;t have time to make it as clear as possible, we couldn&#39;t think of the right name for something at the time we write it, we didn&#39;t really undertand the problem as much as we thought we did, etc.</p>

<p>And, just because you omitted all comments doesn&#39;t make your code magically comprehensible.  You might feel that code should be
self-documenting, but leaving out comments doesn&#39;t make it so.</p>

<p>If you spent any time in real production code, you know that the most brilliant developers can write some real stinkers, creating convoluted code that can be really hard to unravel.  I&#39;ve done it many times, and I&#39;m certain my ex-co-workers at Opower and Gliffy curse my name from time-to-time.  It&#39;s code like this that can benefit from some judiciously-placed &quot;what&quot; comments.</p>

<p>Suppose we come across this code:</p>

<p>```ruby mysterious code
def isqrt(square)
  square = square.to_i 
  return 0 if square == 0 
  raise RangeError if square &lt; 0</p>

<p>n = iter(1, square)
  n1 = iter(n, square)
  n1, n = iter(n1, square), n1 until n1 &gt;= n - 1
  n1 = n1 - 1 until n1*n1 &lt;= square
  return n1
end
def iter(n, square) 
  (n + (square / n)) / 2 
end
```</p>

<p>You might guess that this takes the square root, but boy is it impenetrable.  Some things are just complex and either can&#39;t be made more clear or external constraints exist (like time) that we just can&#39;t do so.  What we probably <em>could</em> do is add a few comments to help the poor sap that must fix a bug in this code later:</p>

<p>```ruby Less-than-ideal, but a bit more helpful
def isqrt(square)
  # just in case we don&#39;t get an int
  square = square.to_i 
  return 0 if square == 0 
  raise RangeError if square &lt; 0</p>

<p># make our initial guesses, which are initially 
  # too high (intentionally; see next)
  n = iter(1, square)
  n1 = iter(n, square)</p>

<p># Refine our guesses until we get close enough
  n1, n = iter(n1, square), n1 until n1 &gt;= n - 1
  # We&#39;re close enough when we&#39;re JUST under square
  n1 = n1 - 1 until n1*n1 &lt;= square
  return n1
end
def iter(n, square) 
  (n + (square / n)) / 2 
end
```</p>

<p>The code is more noisy, yes, but now the reader has some clue as to what&#39;s going on.  It might even given him the confidence to refactor this in a way that no longer requires comments.</p>

<h2>What about tests?</h2>

<p>Tests can give insight into how code is supposed to work.  Tests can rarely make clear the <em>why</em> of code, and almost never
explain the complex guts of a routine.  And, let&#39;s be honest, even well-tested applications have horribly unreadable tests, rife
with <a href="http://www.naildrivin5.com/blog/2012/01/08/make-tests-clean-and-clear-without-duplication.html">duplication</a>, magic numbers, questionable coding practices and other horrors we&#39;d never include in our production
code.  We&#39;ll get to that.</p>

<p>The point is, comments are a way to include information that can&#39;t be (or wasn&#39;t) expressed in code <em>right next to the relevant
code</em>.  There&#39;s power in that, and a develper that completely writes this power off is being foolish.</p>

<h2>Bottom Line</h2>

<ul>
<li>Document your public API</li>
<li>Use comments to explain <em>why</em> odd or surprising code was written</li>
<li>Use comments to explain <em>what</em> impenetrable code is doing if you just can&#39;t make it any more clear</li>
</ul>

<p>Future you will thank you.</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/01/08/make-tests-clean-and-clear-without-duplication.html">Make Tests Clean and Clear without Duplication</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-01-08T14:34:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>Some collegues and I were dicussing dupication in tests, specifically how much repitition of code across tests is acceptible.
On the one hand, you want each test to stand on its own and indicate what it&#39;s testing.  On the other hand, just because we&#39;re in
a test doesn&#39;t mean that all the rules about duplication of code don&#39;t apply; tests need to be maintained to, and if you make a
large change, you don&#39;t want to have to change it in several places.</p>

<p>How much duplication is too much or, what does duplication in tests mean, and how does it affect the understandability and
maintainability of our tests?</p>

<!-- more -->

<h2>What is a test?</h2>

<p>To know how our test code should be structured, we must understand what the purpose of a test is.  At its base, a test is some code that, when executed, checks that some other code behaves in a certain way.  This is a bare minimum, we also wnat our tests to describe the <em>behavior</em> of a piece of code.  We should be able to understand, from looking at a bunch of tests, what the code is supposed to <em>do</em> and what the <em>intent</em> of the developer who created it was.</p>

<p>Let&#39;s start with the basic structure of one test</p>

<h3>Structure of a single test</h3>

<p>A test is made of up three parts:</p>

<ol>
<li><em>Setup</em> or <strong>Given</strong> - This part establishes the conditions under which the test will be performed.  This is crucial, and what makes programming hard - can we know <em>every</em> condition under which our code will run?  We call this &quot;Given&quot; because we simply &quot;give&quot; conditions to the code under test.</li>
<li><em>Execute</em> or <strong>When</strong> - Here, we run the code we&#39;re testing, usually by calling a public method from the class under test.  It&#39;s called &quot;When&quot; because of phrases like &quot;When I calculcate the sales tax&quot;.</li>
<li><em>Assert</em> or <strong>Then</strong> - The final part involves checking that what we executed in step 2 did what we thought it should do.  It&#39;s
called &quot;Then&quot; because of the way we might state assertions in English - &quot;Then the total should be $56.12&quot;.</li>
</ol>

<p>A very simple test might look like this:</p>

<p><code>ruby Basic tests showing each part
def test_area
  # Given (setup)
  circle = Circle.new(10)
  # When (execute)
  area = circle.area
  # Then (assert)
  assert_equal 314,area
end
</code></p>

<p>Tests in real apps are rarely this simple and straightforward.  Often, complex setup is required to establish all the &quot;givens&quot;.
Further, the setup for several tests might be very similar, containing identical code with very small differences.  It&#39;s these
differences that form the true picture of the behavior of code under test.</p>

<h3>Structure of a set of tests</h3>

<p>Let&#39;s take a simple domain that it&#39;s a bit more complex than our <code>Circle</code> class to see how tests interact.  Let&#39;s test a class
that, given a <code>Person</code>, returns a &quot;salutation&quot;.  What makes this tricky is that people in our system don&#39;t always have a first
name or last name.  We want our <code>Salutation</code> class to handle this.</p>

<p>```ruby Basic tests for our Salutation class
class SalutationTest &lt;&lt; Test
  def test<em>full</em>name
    # Given
    person = Person.new(&quot;David&quot;,&quot;Copeland&quot;,:male)
    salutation = Salutation.new(person)
    # When
    greeting = salutation.greeting
    # Then
    assert_equal &quot;Hello, David!&quot;,greeting
  end</p>

<p>def test<em>first</em>name<em>only
    # Given
    person = Person.new(&quot;David&quot;,nil,:male)
    salutation = Salutation.new(person)
    # When
    greeting = salutation.greeting
    # Then
    assert</em>equal &quot;Hello, David!&quot;,greeting
  end</p>

<p>def test<em>last</em>name<em>only</em>male
    # Given
    person = Person.new(nil,&quot;Copeland&quot;,:male)
    salutation = Salutation.new(person)
    # When
    greeting = salutation.greeting
    # Then
    assert_equal &quot;Hello, Mr. Copeland!&quot;,greeting
  end</p>

<p>def test<em>last</em>name<em>only</em>female
    # Given
    person = Person.new(nil,&quot;Copeland&quot;,:female)
    salutation = Salutation.new(person)
    # When
    greeting = salutation.greeting
    # Then
    assert_equal &quot;Hello, Ms. Copeland!&quot;,greeting
  end
end
```</p>

<p>Read these tests over.  They should, hopefully, give you a picture of what the <code>Salutation</code> class is supposed to do, even though
we aren&#39;t seeing the actual implementation<a name="back-1"></a><sup><a href="#1">1</a></sup>.  Of course, this isn&#39;t perfect.  If you look over the test class
quickly, all the tests look similar, and it&#39;s hard to tell what the differences are.  Specifically:</p>

<ul>
<li>The assertions in the first two tests are identical. Is this by coincidence, or by design?</li>
<li>This test is tightly coupled to the construction of a <code>Person</code>, even though this class doesn&#39;t test that construction; we
simply want <code>Person</code> instances of a certain nature.</li>
</ul>

<p>All of these issues make it unclear what&#39;s really being tested.  What part of each of these tests is <em>different</em> from the others
in a significant way?</p>

<h2>Making intent more clear</h2>

<p>Our first issue is that the first two tests&#39; assertions are identical.  This is, in fact, by design of the <code>Salutation</code> class -
if the person has a first name, we don&#39;t care if they have a last name.  Let&#39;s make that design decision clear:</p>

<p><code>ruby Making the design more clear
class SalutationTest &lt;&lt; Test
  def test_salutation_uses_first_name
    [ Person.new(&quot;David&quot;,&quot;Copeland&quot;,:male),
      Person.new(&quot;David&quot;,nil       ,:male),
    ].each do |person|
      # Given
      salutation = Salutation.new(person)
      # When
      greeting = salutation.greeting
      # Then
      assert_equal &quot;Hello, David!&quot;,greeting,&quot;For person #{person}&quot;
    end
  end
end
</code></p>

<p>Now, it&#39;s very clear that the last name doesn&#39;t matter.  Note that since we&#39;re now executing our given/when/then in a loop, we need to include the person used in the salutation in our assertion message so if it ever fails, we know which <code>last_name</code> caused it.</p>

<p>This clears up our biggest issue, but what about the duplication of creating <code>Person</code> instances?  Outside of the fact that any
change in the constructor <code>Person</code> will break this test, it&#39;s also not clear what&#39;s different about all of these <code>Person</code>
instances.  Even if we&#39;re familiar with the constructor, it&#39;s still not 100% clear what <em>kind</em> of person we&#39;re setting up as a
&quot;Given&quot;.  </p>

<p>We could certainly drop a few comments in, but we have a more powerful tool: method extraction.</p>

<p>```ruby Tests with Person construction extracted to methos
class SalutationTest &lt;&lt; Test</p>

<p>def test<em>salutation</em>uses<em>first</em>name
    # Given
    first_name = &quot;David&quot;</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[ person_with_first_name_only(first_name), 
  person_with_full_name(first_name) ].each do |person|
  # Given
  salutation = Salutation.new(person)
  # When
  greeting = salutation.greeting
  # Then
  assert_equal &quot;Hello, #{first_name}!&quot;,greeting,&quot;For person #{person}&quot;
end
</code></pre></div>
<p>end</p>

<p>def test<em>last</em>name<em>only</em>male
    # Given
    salutation = Salutation.new(male<em>with</em>only<em>last</em>name(&quot;Copeland&quot;))
    # When
    greeting = salutation.greeting
    # Then
    assert_equal &quot;Hello, Mr. Copeland!&quot;,greeting
  end</p>

<p>def test<em>last</em>name<em>only</em>female
    # Given
    salutation = Salutation.new(female<em>with</em>only<em>last</em>name(&quot;Copeland&quot;))
    # When
    greeting = salutation.greeting
    # Then
    assert_equal &quot;Hello, Ms. Copeland!&quot;,greeting
  end
end
```</p>

<p>Now, it&#39;s painfully clear <em>which</em> type of person we&#39;re setting up.  We&#39;ve also been able to eliminate the <code>person</code> variable,
which was only really needed to construct the <code>Saluation</code> instance.  It&#39;s existence muddied the test code, so the elimination
of that makes the tests more clear.  The extracted methods are trivial:</p>

<p>```ruby Factory methods for Person intances
def person<em>with</em>first<em>name</em>only(first<em>name)
  Person.new(first</em>name,nil,:male)
end</p>

<p>def person<em>with</em>full<em>name(first</em>name)
  Person.new(first_name,&#39;Smith&#39;,:male)
end</p>

<p>def male<em>with</em>only<em>last</em>name(last<em>name)
  Person.new(nil,last</em>name,:male)
end</p>

<p>def female<em>with</em>only<em>last</em>name(last<em>name)
  Person.new(nil,last</em>name,:female)
end
```</p>

<p>Granted, our test is a lot more lines of code than it was, but it&#39;s also a lot more clear.  Since code is <em>read</em> much more often
than written, good, clean code should favor readability.  Our test code now does, clearly communicating, for each test, what the
conditions are under which we&#39;re going to test, what code we&#39;re testing and what behavior we expect our code to exhibit, all with
a minium of comments -- the code speaks for itself.</p>

<p>Of course, we can still introduce further confusing duplication.  As our codebase grows, we&#39;ll see that duplication will also
grow.</p>

<h2>Behavior in the face of change</h2>

<p>Let&#39;s consider a new subclass of <code>Salutation</code> called <code>FormalSalutation</code>.  This new subclass will implement the somewhat
old-fashioned notion of referring to married women as &quot;Mrs.&quot; and unmarried women as &quot;Miss&quot;.  It will also
spell our &quot;Mister&quot;.  We&#39;ll copy the tests for
<code>Salutation</code> and enhance them as a naive first step.</p>

<p>```ruby Tests for the new FormalSalutation class
class FormalSalutationTest &lt;&lt; Test</p>

<p>def test<em>salutation</em>uses<em>first</em>name
    # Given
    first_name = &quot;David&quot;</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[ person_with_first_name_only(first_name), 
  person_with_full_name(first_name) ].each do |person|

  # Given
  salutation = FormalSalutation.new(person)
  # When
  greeting = salutation.greeting
  # Then
  assert_equal &quot;Hello, #{first_name}!&quot;,greeting,&quot;For person #{person}&quot;
end
</code></pre></div>
<p>end</p>

<p>def test<em>last</em>name<em>only</em>male
    # Given
    salutation = FormalSalutation.new(male<em>with</em>only<em>last</em>name(&quot;Copeland&quot;))
    # When
    greeting = salutation.greeting
    # Then
    assert_equal &quot;Hello, Mister Copeland!&quot;,greeting
  end</p>

<p>def test<em>last</em>name<em>only</em>married<em>female
    # Given
    person = female</em>with<em>only</em>last<em>name(&quot;Copeland&quot;)
    person.marry!
    salutation = FormalSalutation.new(person)
    # When
    greeting = salutation.greeting
    # Then
    assert</em>equal &quot;Hello, Mrs. Copeland!&quot;,greeting
  end</p>

<p>def test<em>last</em>name<em>only</em>unmarried<em>female
    # Given
    salutation = FormalSalutation.new(female</em>with<em>only</em>last<em>name(&quot;Copeland&quot;))
    # When
    greeting = salutation.greeting
    # Then
    assert</em>equal &quot;Hello, Miss Copeland!&quot;,greeting
  end</p>

<p>private 
  def person<em>with</em>first<em>name</em>only(first<em>name)
    Person.new(first</em>name,nil,:male)
  end</p>

<p>def person<em>with</em>full<em>name(first</em>name)
    Person.new(first_name,&#39;Smith&#39;,:male)
  end</p>

<p>def male<em>with</em>only<em>last</em>name(last<em>name)
    Person.new(nil,last</em>name,:male)
  end</p>

<p>def female<em>with</em>only<em>last</em>name(last<em>name)
    Person.new(nil,last</em>name,:female)
  end
end
```</p>

<p>The tests are pretty clear as to what they are doing, but now we have two types of nasty duplication going on:</p>

<ul>
<li>Some of these tests are identical to those in <code>SalutationTest</code></li>
<li>Some of our private <code>person_*</code> methods are identical to those in <code>SalutationTest</code></li>
</ul>

<h3>Duplicated Tests</h3>

<p>What do our duplicated tests tell us?  They tell us that, for a person with a first name, irrespective of the existence of a last
name, <code>Salutation</code> and <code>FormalSalutation</code> behave the same <em>only by happenstance</em>.  In other words, it is OK for the behavior of
these classes to differ in this situation, but, currently, they <em>happen</em> to behave the same.  Meaning that if we later change how
<code>Salutation</code> behaves, we don&#39;t need to also change how <code>FormalSalutation</code> behaves.</p>

<p>The quesiton is: is this interpretation correct?  Let&#39;s suppose that it isn&#39;t.  Let&#39;s suppose that, anywhere in our system,
anyone that uses a <code>Salutation</code> or <code>Salutation</code>-like class should expect that the behavior regarding a <code>Person</code> with a first
name should be the same.  Can we communicate that design decision in our tests?</p>

<p>We could do this by creating a module to hold our specific asserts, called <code>SalutationTests::Asserts</code>, like so:</p>

<p>```ruby Common assertions for Salutation instances
module SalutationTests
  module Asserts
    def assert<em>greeting</em>for<em>person</em>with<em>first</em>name(greeting,first<em>name,msg=nil)
      assert</em>equal &quot;Hello, #{first_name}!&quot;,greeting,msg
    end
  end
end</p>

<p>class SalutationTest
  include SalutationTests::Asserts
  def test<em>salutation</em>uses<em>first</em>name
    # Given
    first_name = &quot;David&quot;</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[ person_with_first_name_only(first_name), 
  person_with_full_name(first_name) ].each do |person|

  # Given
  salutation = Salutation.new(person)
  # When
  greeting = salutation.greeting
  # Then
  assert_greeting_for_person_with_first_name(greeting,first_name,&quot;For person #{person}&quot;)
end
</code></pre></div>
<p>end
end</p>

<p>class FormalSalutationTest
  include SalutationTests::Asserts</p>

<p>def test<em>salutation</em>uses<em>first</em>name
    # Given
    first_name = &quot;David&quot;</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[ person_with_first_name_only(first_name), 
  person_with_full_name(first_name) ].each do |person|

  # Given
  salutation = FormalSalutation.new(person)
  # When
  greeting = salutation.greeting
  # Then
  assert_greeting_for_person_with_first_name(greeting,first_name,&quot;For person #{person}&quot;)
end
</code></pre></div>
<p>end
end</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">We&#39;ve added lines of code, but now it&#39;s clear that the behavior of both `Salutation` and `FormalSalutation` 
are _supposed to be the same_ for a `Person` with a first name.  Meaning, if the behavior of one changes, than the behavior of
the other *must* change, and we can make that change, in our tests, in one place.  It also means that future
`Salutation`-like classes can re-use this logic.  This is basic structured programming.

Onto our second form of cross-test duplication, the duplication in the setup of `Person` instances.

### Duplication in setup

In both `SalutationTest` and `FormalSalutationTest`, we create a person with a full name, a person with no last name, and a
male person without a first name.  It&#39;s done the same way in both test classes.  The code, as it stands now, is telling us that
this duplication is merely happenstance.  This is not correct.  We intended to create the _same set of circumnstances_ in both
tests.  In one, the behavior is the same (by design, as indicated by the sharing of the assert method).  In the other
the classes, _under the same conditions_ should behavior differently. 

So, we&#39;d like to communicatet this sameness that in our implementation.  We could use a tool
like [FactoryGirl][factorygirl], but this puts all of our test data into global scope.  We only want our test data scoped to the
tests in question.  This is so that data can change as those sets of classes change, and we can be sure we aren&#39;t breaking other
classes.

We can do this without any special tools by using a module with a well-chosen name.  We&#39;ll use our 
`SalutationTests` namespace and create a new module inside called `People` that will contain our extracted methods.

```ruby Module for production `Person` instances for salutation tests
module SalutationTests
  module People
    def person_with_first_name_only(first_name)
      Person.new(first_name,nil,:male)
    end

    def person_with_full_name(first_name)
      Person.new(first_name,&#39;Smith&#39;,:male)
    end

    def male_with_only_last_name(last_name)
      Person.new(nil,last_name,:male)
    end

    def female_with_only_last_name(last_name)
      Person.new(nil,last_name,:female)
    end
  end
end

class SalutationTest &lt;&lt; Test
  include SalutationTests::People
end

class FormalSalutationTest &lt;&lt; Test
  include SalutationTests::People
end
</code></pre></div>
<p>It&#39;s now clear that the setup for the first two tests of both <code>SalutationTest</code> and <code>FormalSalutationTest</code> are the same <em>by
design</em>.   Note that if we <em>did</em> choose to move to FactoryGirl later on, we only need to update this module to use our
factories, instead of having to go into each test method and do it.  This is, yet again, basic structured programming.</p>

<p>What about the case when we want to re-use this setup, but change it slightly?  Should we re-use it, or duplicate it?</p>

<h2>When we need a slight tweak to our setup</h2>

<p>Suppose we want to make a third class, called <code>HonorificSalutation</code>.  Here, our setup is very similar, but not exactly the same,
as our common <code>Person</code> setup in <code>SalutationTests::People</code>.  Since we don&#39;t <em>have</em> to use this module, we could create <code>Person</code>
instances exactly how we&#39;d like, and make it clear that the tests in <code>HonorificSalutationTest</code> aren&#39;t the same as those
in the other two.</p>

<p>However, this isn&#39;t exactly true.  The setup is <em>almost</em> the same and, since these three classes are all related, it makes sense
to share the similarities.  We want someone to look at <code>HonorificSalutation</code> and know what&#39;s <em>different</em> about this class
from <code>Salutation</code> or <code>FormalSalutation</code>.  So, we re-use the methods from <code>SalutationTests::People</code> and modify the results during
the setup:</p>

<p>```ruby Tests for HonorificSalutation
class HonorificSalutationTest &lt;&lt; Test
  include SalutationTests::People</p>

<p>def test<em>doctor</em>with<em>no</em>first<em>name
    [ male</em>with<em>only</em>last<em>name(&#39;Copeland&#39;),
      female</em>with<em>only</em>last<em>name(&#39;Copeland&#39;)].each do |person|
      # Given
      person.honorific = :doctor
      salutation = HonorificSalutation.new(person)
      # When
      greeting = salutation.greeting
      # Then
      assert</em>equal &quot;Hello, Dr. Copeland!&quot;,greeting
    end
  end
end
```</p>

<p>What this code is saying is that when we test a person who&#39;s a doctor and has no first name, we want both a male and female
<em>exactly</em> like we had in our other tests, but the <em>one</em> difference between those tests and this is that <code>honorific</code>
is being set to <code>:doctor</code>.  This makes it very clear what&#39;s truly different.</p>

<h2>Conclusions</h2>

<p>There&#39;s a lot more to this subject, but essentially what we&#39;re getting at is the meaning behind duplication.  Essentially, things
that are the same <em>by desgin</em> should be shared.  Everything else is only the same by happenstance.  By coding your tests in this
way, you make the intent and design very clear.  And you don&#39;t need any special tools to do it.</p>

<p>[factorygirl]: https://github.com/thoughtbot/factory_girl</p>

<hr>

<footer class='footnotes'>
<ol>
<li>
<a name='1'></a>
<sup>1</sup>And, of course, please set aside the American-centric natrue of this class and domain.  I understand that many cultures have the names "reversed" from American-style or don't even have such a rigid name structre.<a href='#back-1'>↩</a>
</li>
</ol></footer>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2012/01/02/2011-in-review.html">2011 In Review</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2012-01-02T15:51:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>At the start of 2011, I <a href="http://www.naildrivin5.com/blog/2011/01/01/2010-whats-next.html">blogged</a> about a &quot;professional goals&quot; file I found on my computer, and
compared it to what happened.  I kindof enjoyed the exercise, so here&#39;s a repeat.  </p>

<!-- more -->

<h2>2011</h2>

<p>Here&#39;s what was on my list of goals for 2011:</p>

<h3>Deploy my iPhone app to App Store</h3>

<p>Sadly, <a href="http://www.naildrivin5.com/blog/2010/07/18/iphone-app-part-5.html">my app</a> is still floundering.  With the release of iOS5, it&#39;s even got some bugs.  I would like to either
re-implement or at least beef it up and get it into the store.  With the book done (see below), this might happen.</p>

<h3>Speak at at least 2 conferences</h3>

<p>Done and done.  I was lucky enough to speak at more than two conferences this year, including <a href="http://www.rubynation.org">RubyNation</a>,
<a href="http://www.rubyconf.org">RubyConf</a>, <a href="http://www.gogaruco.com">GoGaRuCo</a>, <a href="http://www.oscon.com">OSCON</a> and <a href="http://www.rubymidwest.com">Ruby Midwest</a>.  It was a ton of fun, but 
exhausting.  Probably going to dial that back this year.</p>

<h3>Publish my command-line application book</h3>

<p>My <a href="http://www.awesomecommandlineapps.com">book</a> on command-line applications in Ruby is <em>done</em>.  It took most of my free time this year to get it to completion,
but it&#39;s done and should be out of beta real soon.  I love writing and so I&#39;m inclined to count this against myi &quot;blog twice a
month&quot; thing, but it took a lot more time than I thought it would.</p>

<h3>Develop and deploy an iPad app</h3>

<p>Not even close :(</p>

<h3>Blog twice a month</h3>

<p>I barely managed an average of one post/month.  This year will hopefully be better.  My main problem is that it&#39;s hard to find
interesting things to blog about.  I would much rather my blog be like <a href="http://www.marco.org">Marco Arment&#39;s</a> than a grab bag of technical junk,
but I also don&#39;t want to have a blog like <a href="http://www.daringfireball.net">Daring Fireball</a> that is just opinions and reactions (not that I don&#39;t
think that&#39;s a great blog or a great way to write, but it&#39;s just not what <em>I</em> want to blog about).</p>

<h3>Learn JavaScript more betterer</h3>

<p>I spent almost no time improving my JavaScript skills.  I&#39;m not particularly sad about it, but I would still like to be better at
it.</p>

<h3>Get my rudimentary scaladoc doclet accepted.</h3>

<p>I think that my patch inspired a change in the scaladoc tool that gives it doclet-like abilities, but I couldn&#39;t find the time to
do anything with it.   The Scala documentation is much improved over the initial version of Scaladoc2, but it&#39;s still pretty bad.
Sadly, I&#39;m not writing a lot of Scala at work, so I don&#39;t have the time or motivation to do much about it.</p>

<h2>2012</h2>

<p>All in all, I didn&#39;t hit everything I&#39;d hoped, but I&#39;m still happy with how things panned out.  I think the theme of 2011 for me
was &quot;Don&#39;t Get Pigeon-holed&quot;.  </p>

<p>While my job at <a href="http://www.opower.com">Opower</a> was great, I was doing a lot of Java and ready to move on, both technically and product-wise.  Instead of spending my
free-time refining my Ruby skills, I now apply them daily (along with a <a href="https://twitter.com/#!/merbist/livingsocial">great team</a>), freeing up my after-work
time to other pursuits.</p>

<p>So, what <em>are</em> those pursuits?  I&#39;m not looking to dive into some esoteric new bleeding-edge language at the moment.  I&#39;d still
like to get better at JavaScript and Objective-C, and that might be enough &quot;new stuff&quot; for me for this year.
Additionally, I&#39;d like to:</p>

<ul>
<li>Keep writing, either the blog or a short self-published thing</li>
<li>Complete <a href="http://www.github.com/davetron5000/methadone">methadone</a> and release <a href="http://www.github.com/davetron5000/gli">GLI2</a>, so both of those projects can be in maintenance-mode for a while</li>
<li>Find a way to keep up with my Scala.</li>
</ul>

<p>Beyond that, hopefully I can spend more time on music and cooking this year.  Amy and I had a blast in <a href="http://maps.google.com/maps?q=culebra&amp;ll=18.310203,-65.29604&amp;spn=0.104138,0.158958&amp;hq=culebra&amp;radius=15000&amp;t=h&amp;z=13&amp;vpsrc=6">Culebra</a>
just making up dishes using the limited ingredients available on the island and I&#39;m just tired of eating sandwiches.</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2011/12/22/working-with-unix-processes-review.html">Review of 'Working with Unix Processes'</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2011-12-22T08:37:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>I just finished reading the short and to-the-point <a href="http://workingwithunixprocesses.com/">Working with Unix Processes</a>, by Jess Storimer.  Although
I cut my teeth on C and UNIX programming, it&#39;s been a while, and I figured I&#39;d check the book out to see what insights it might
have, especially given that it&#39;s written from a Ruby perspective.</p>

<p>In short, I&#39;d recommend this book to someone interested in command-line Ruby (and who might have <a href="http://www.awesomecommandlineapps.com/">my book</a>), but who has
very little UNIX programming experience.  This book is a crash-course in the basics of UNIX Process management.</p>

<p>That being said, if you are (or have been) familiar with things like <code>fork</code> and <code>exec</code>, you&#39;ll find this book a bit too light, especially given the price (<strong>update 1/2/2012</strong> see inside).</p>

<!-- more -->

<h2>The Good</h2>

<p>The information in the book is accurate and presented at excellent pace; the reader isn&#39;t expected to ingest too much knowledge
at once, and the author brings the reader one step-at-a-time through understanding UNIX process management.  In a nice touch, the author pauses on occasion to connect the information presented to &quot;real world&quot; scenarios.</p>

<p>The book also delves slightly into the realities of using these tools in the context of particualr Ruby implementations.  </p>

<p>The appendeces of the book are a walkthrough of certain parts of <a href="https://github.com/defunkt/resque">Resque</a> and <a href="http://unicorn.bogomips.org/">unicorn&#39;s</a> source code,
relating back to the concepts learned in the book.  This is something few books do, but that I find very illuminating.  Here, it
demonstrates real-world use of the concepts outlined in the book.</p>

<h2>The Bad</h2>

<p>At $27 ($7 <em>more</em> than <a href="http://www.awesomecommandlineapps.com/">my book</a>, and <em>$22 more</em> that Avdi Grimm&#39;s so-far-wonderful <a href="http://avdi.org/devblog/2011/11/15/early-access-beta-of-objects-on-rails-now-available-2/">Objects on Rails</a>), I was hoping for a little more depth.  The book clocks in at 90 pages in PDF (77 pages
  in iBooks) and feels more like an introduction.    For the price, I was hoping for a lot more depth.</p>

<p>As an example, the section &quot;Daemon Processes&quot; shows the use of the <code>setsid</code> system call.  Although the purpose of using the call
is explained, <em>that</em> explanation makes no sense.  I have no idea what a &quot;session leader&quot; or &quot;process group&quot; are, and these terms
are never touched on in the book, nor is there a link to find out more.  A cursory search of the internet turned up only the
information presented here.  Piecing this together is the insight a book like this should provide; it&#39;s what makes the
information worth paying for.</p>

<p><strong>Update 1/2/2012</strong>: <em><a href="https://twitter.com/#!/jstorimer">The author</a> has recently updated the book to include a *much</em> more detailed explanation of 
<code>setsid</code> and all of the process stuff around it.  The update makes it very clear how the quoted <a href="http://rack.rubyforge.org/">rack</a> daemon
process code works and was very illuminating.  This demonstrates one of the cool things about ebooks - easy updates.*</p>

<p>I also feel like some discussion of named pipes would be warranted, as well as things like <code>select</code> and <code>poll</code>, which are at the
heart of the current fad in evented programming.</p>

<p>The book could also benefit from some editing, as there were <em>just</em> enough grammar and spelling mistakes to distract me, as well as numerous formatting bugs with source code in the ePub version.  I also think that using running, real-world examples would make the points more clear; the examples aren&#39;t particularly compelling (although the appendeces make up for this significantly, since they <em>do</em> relate the concepts to real code).</p>

<p>The book also includes some source code that is never really discussed and, honestly, I&#39;m not sure what I&#39;m supposed to do with
it.</p>

<h2>Conclusions</h2>

<p>Don&#39;t let these criticisms spoil you, though.  If you have no clue what a process is, or what <code>exec</code> is for, this book will teach
that to you, simply and quickly.  This book fills a gap that a lot of developers have these days; it shouldn&#39;t require writing C
code to learn the UNIX fundamentals.  This book proves that to be true.</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2011/12/19/methadone-the-awesome-cli-library.html">Introducing Methadone, the Awesome Command-Line Library</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2011-12-19T00:00:00-05:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p>I&#39;ve spent the last year [writing a book][book] on building awesome command-line applications in Ruby.  Over the course of
writing it, I&#39;ve used a lot of Ruby libraries for building command-line apps, and none of them work quite right.  In my book, I
spent significant time on [OptionParser][optparse], since it&#39;s builtin, and [GLI][gli], since I wrote it (and since it&#39;s actually very
fully-featured compare to the alternatives).</p>

<p>I just finished up an appendix where I showed alternate implementations of the running examples using [main][main], [thor][thor], and [trollop][trollop].  I did this for a few reasons:</p>

<ul>
<li>These tools are popular, and people have asked if they&#39;d be included</li>
<li>They are, by and large, very different from how <code>OptionParser</code> and GLI work</li>
<li>I wanted to give them a real shakedown</li>
</ul>

<p>I also surveyed many other tools, but, alas, I couldn&#39;t include everything.  Each of these tools have a common theme, which is to
avoid the boilerplate of <code>OptionParser</code>, and make it really easy to parse command-line arguments.  They all have done this, but at 
a cost.  All of them are less powerful and extensible than <code>OptionParser</code>, and only slightly more compact (or, in the case of
main, more verbose).</p>

<p>Enter [methadone][methadone], which has all of <code>OptionParser</code>&#39;s power, but the compactness of these other frameworks.</p>

<!-- more -->

<h2>Another command-line option parser?</h2>

<p>Yes and no.  Methadone isn&#39;t a re-implementation of command-line option parsing.  It&#39;s barely a DSL, making use of almost no
meta-programming, <code>class_eval</code>, or other craziness.  It&#39;s a plain Ruby proxy to <code>OptionParser</code>, with some helper methods.  It makes
idiomatic option parsing and command-line app design as seemless as possible, but doesn&#39;t force <em>any</em> of itself on
you.  In this post, I&#39;ll derive its syntax while showing you the basics of how to structure a simple command-line app.<br>
You&#39;ll have to [buy the book][book] to dig deeper<a name="back-1"></a><sup><a href="#1">1</a></sup>.</p>

<h2>Basic Command-line App Structure</h2>

<p>Most command-line apps start off with parsing the command-line with <code>OptionParser</code> (which typically consists of setting values into
some <code>Hash</code>), defining a few helper methods, and then, at the end, implementing the main logic of the program:</p>

<p>```ruby Typical Command-Line App Structure</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &#39;optparse&#39;</p>

<p>options = {}</p>

<p>parser = OptionParser.new do |opts|
  opts.banner &#39;My awesome app&#39;</p>

<p>opts.on(&quot;-u USERNAME&quot;,&quot;--username&quot;,&quot;The username&quot;) do |user|
    options[:username] = user
  end</p>

<p>opts.on(&quot;-v&quot;,&quot;--verbose&quot;,&quot;Be verbose&quot;) do 
    options[:verbose] = true
  end</p>

<p># etc.</p>

<p>end</p>

<p>parser.parse!</p>

<p>def some<em>helper</em>method
end</p>

<p>def some<em>other</em>helper_method</p>

<p>puts &quot;Starting program&quot; if options[:verbose]</p>

<h1>etc, the main logic of your program</h1>
<div class="highlight"><pre><code class="language-text" data-lang="text">Yuck.  The boilerplate option parsing is bad enough, but the structure is all wrong.  The interesting stuff is all the way at the bottom; you have to read the thing in the wrong order.  At the very least, you should extract the core logic into a `main` method, put that at the top, and call it at the end.

```ruby Extracting Logic to a Main Method
#!/usr/bin/env ruby

require &#39;optparse&#39;

def main(args)
  # main logic of your app
  0 # or return nonzero if something went wrong
end

def some_helper_method
end

def some_other_helper_method

puts &quot;Starting program&quot; if options[:verbose]

options = {}

parser = OptionParser.new do |opts|
  opts.banner &#39;My awesome app&#39;

  opts.on(&quot;-u USERNAME&quot;,&quot;--username&quot;,&quot;The username&quot;) do |user|
    options[:username] = user
  end

  opts.on(&quot;-v&quot;,&quot;--verbose&quot;,&quot;Be verbose&quot;) do 
    options[:verbose] = true
  end

  # etc.

end

parser.parse!

exit main(ARGV)
</code></pre></div>
<p>Now, we can see, immediately upon opening the file, the main thing this app is doing.
Of course, an exception might be raised.  We may even do it on purpose, but we can&#39;t have the app vomiting a stack trace to the user, so we wrap our call to <code>main</code> in a <code>begin..rescue</code> block:</p>

<p><code>ruby Handling Exceptions
begin
  exit main(ARGV)
rescue =&gt; ex
  STDERR.puts ex.message
  exit 1
end
</code></p>

<h2>Methadone&#39;s Main Method</h2>

<p>The structure we just saw is pretty decent, and gives us, and future contributors, an easy way to follow the code.  Users also
get a pretty decent experience and never have to see a backtrace.</p>

<p>This brings us to the first feature of methadone.  Instead of including this boilerplate every time, we extract it into a module, 
<code>Methadone::Main</code>, which gives us two methods: <code>main</code> and <code>go!</code>.</p>

<p><code>main</code> takes a block that represents our main method from before.  <code>go!</code> calls that block, handling the exceptions for us.  Our app now looks
like so:</p>

<p>```ruby Methadone&#39;s Boilerplate Removal</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &#39;methadone&#39;</p>

<p>include Methadone::Main</p>

<p>main do |args,go,here|
  # main logic
  # raise exceptions at will
end</p>

<h1>declare options and helper methods as before</h1>

<p>go!
```</p>

<p><code>go!</code> will extract the contents of <code>ARGV</code> leftover after parsing and pass them to the block.  Since they&#39;re passed as individual arguments, you don&#39;t have to call <code>shift</code> a bunch of times on some array.  Just name your parameters whatever, and Metahdone takes care of it.   If your main block raises an exception, <code>go!</code> will handle catching it, messaging the user without a backtrace, and exiting nonzero<a name="back-2"></a><sup><a href="#2">2</a></sup>.</p>

<h2>Parse Options with no Loss of Power</h2>

<p>Notice how we can still safely use <code>OptionParser</code>.  Methadone doesn&#39;t hide that.  As we&#39;ll see, it provides some more features to make option
parsing even easier.  First, we can get rid of the <code>options</code> <code>Hash</code> as well as the actual creation of the <code>OptionParser</code> instance.</p>

<p>Methadone provides two methods: <code>options</code> and <code>opts</code>.  <code>options</code> provides access to a <code>Hash</code> that we can use inside our <code>main</code> block.  <code>opts</code>
provides access to the underlying <code>OptionParser</code> instance that is automatically created.  We can now remove a few lines of code, losing <em>no</em>
functionality:</p>

<p>```ruby Methadone Provides an OptionParser and Options Hash for You
opts.banner &#39;My awesome app&#39;</p>

<p>opts.on(&quot;-u USERNAME&quot;,&quot;--username&quot;,&quot;The username&quot;) do |user|
  options[:username] = user
end</p>

<p>opts.on(&quot;-v&quot;,&quot;--verbose&quot;,&quot;Be verbose&quot;) do 
  options[:verbose] = true
end
```</p>

<p>Given that <code>opts</code> is baked in, there&#39;s no need to even use that for our cases, because Methadone provides a method <code>on</code> that proxies to the
underlying <code>OptionParser</code>.  You can still use <code>opts</code> to access anything else, but for declaring command-line options, just call <code>on</code>
directly:</p>

<p>```ruby The on Method Proxies to OptionParser
opts.banner &#39;My awesome app&#39;</p>

<p>on(&quot;-u USERNAME&quot;,&quot;--username&quot;,&quot;The username&quot;) do |user|
  options[:username] = user
end</p>

<p>on(&quot;-v&quot;,&quot;--verbose&quot;,&quot;Be verbose&quot;) do 
  options[:verbose] = true
end
```</p>

<p>You can see, as we peel off layers of boilerplate, Methadone hides nothing; it&#39;s just making commonly-written code easier to write. At any time,
you can abandon it and go back to the old way.  </p>

<p>So far, we&#39;ve only saved a few lines of code and a couple of characters.  That&#39;s because we haven&#39;t seen the true power of the <code>on</code> method.
<code>on</code> is more than just a proxy to <code>OptionParser</code>.  It does one additional thing for us:  it we omit the block, Methadone will provide one 
for us.  That Methadone-provided block simply sets the value from the command-line in the
<code>options</code> <code>Hash</code> automatically.  Meaning that the above code is equivalent to this:</p>

<p>```ruby The on Method Provides Idiomatic Behavior
opts.banner &#39;My awesome app&#39;</p>

<p>on(&quot;-u USERNAME&quot;,&quot;--username&quot;,&quot;The username&quot;)
on(&quot;-v&quot;,&quot;--verbose&quot;,&quot;Be verbose&quot;)
```</p>

<p>Not bad!  This means that <em>all</em> we need to do, assuming we&#39;re doing things idiomatically, is to give <code>on</code> the names of our options and their
descriptions.  Note, however, this <em>still</em> proxies to <code>OptionParser</code>&#39;s <code>on</code> method.  Suppose we only allowed usernames with all lower-case
characters?  In Methadone, as in <code>OptionParser</code>, you pass in a <code>Regexp</code>:</p>

<p><code>ruby Validation using Regular Expressions
on(&quot;-u USERNAME&quot;,&quot;--username&quot;,&quot;The username&quot;,/^[a-z]+$/)
on(&quot;-v&quot;,&quot;--verbose&quot;,&quot;Be verbose&quot;)
</code></p>

<p>Suppose you want the value type-converted for you?  We have access to the underlying <code>OptinParser</code>, so we can set that up easily:</p>

<p>```ruby Custom Type Conversions
opts.accept(User) do |username|
  User.find<em>by</em>name(username)
end</p>

<p>on(&quot;-u USERNAME&quot;,&quot;--username&quot;,&quot;The username&quot;,User)
on(&quot;-v&quot;,&quot;--verbose&quot;,&quot;Be verbose&quot;)
```</p>

<h2>Do the Right Thing</h2>

<p>You&#39;ve noticed that we are still setting our banner manually.  You&#39;ve also noticed our banner is kinda lame;  It doesn&#39;t say what our app
does nor does it give an overview of how to use it.  It should look like so:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ awesome_app.rb --help
Does so many awesome things, you won&#39;t believe it.

Usage:  awesome_app.rb [options] thing other_thing [optional_thing]
</code></pre></div>
<p>Since Methadone knows that our app takes options (by virtue of us having declared them), and it knows the name of
our app, we just need to tell it what our app does, and it will assemble the banner for 
us<a name="back-3"></a><sup><a href="#3">3</a></sup>.</p>

<p>```ruby Automatically Generate the Banner
main do |thing,other<em>thing,optional</em>thing|
  # logic
end</p>

<p>on(&quot;-u USER&quot;,&quot;--username&quot;,&quot;The user name&quot;)
on(&quot;-v&quot;,&quot;--verbose&quot;,&quot;Be verbose&quot;)</p>

<p>description &quot;Does so many awesome things, you won&#39;t believe it.&quot;</p>

<p>go!
```</p>

<p>Finally, you&#39;ll note that our <code>main</code> block takes three arguments.  Methadone provides the method <code>arg</code> that allows us to name them (in the language the user will understand) and indicate which are required and which are optional. Methadone will put this information into the banner, and will fail if any required arguments are missing:</p>

<p>```ruby Describing the Arguments
main do |thing,other<em>thing,optional</em>thing|
  # logic
end</p>

<p>on(&quot;-u USER&quot;,&quot;--username&quot;,&quot;The user name&quot;)
on(&quot;-v&quot;,&quot;--verbose&quot;,&quot;Be verbose&quot;)</p>

<p>description &quot;Does so many awesome things, you won&#39;t believe it.&quot;</p>

<p>arg :thing
arg :other<em>thing
arg :optional</em>thing, :optional</p>

<p>go!
```</p>

<p>Now, the banner looks like we&#39;d like it, and we didn&#39;t have to do much more than describe our program.  You can
even bootstrap your app using the <code>methadone</code> command-line app.  It will create an empty app, using this structure, with
some helpful comments to let you describe your UI easily and quickly.  But it won&#39;t prevent you from doing any sort of crazy thing with
<code>OptionParser</code> that you need to.</p>

<h2>Sweet, Sweet Sugar</h2>

<p>But wait!  There&#39;s more!  Complex programs start to look like this:</p>

<p>```ruby Complex, Annoying Code
if have<em>connection
  # puts &quot;got a connection&quot;
  file = request</em>data
  puts &quot;Got data&quot;
  if file.nil?
    STDERR.puts &quot;Data was nil?&quot;
  end
end</p>

<h1>puts &quot;Moving on&quot;</h1>
<div class="highlight"><pre><code class="language-text" data-lang="text">You&#39;ve got a mix of commented-out debug statements, informational messages and tediously long statements sending error messages to the
standard error.  Methadone includes a special `Logger` instance, along with some helper methods, that does away with all this:

```ruby Cleaner Messaging
include Methdone::CLILogging # sets up Logger, provides helper methods

if have_connection
  debug &quot;got a connection&quot;   # Calls logger.debug 
  file = request_data
  info &quot;Got data&quot;            # Calls logger.info
  if file.nil?
    error &quot;Data was nil?&quot;    # Calls logger.error
  end
end
debug &quot;Moving on&quot;            # Calls logger.debug
</code></pre></div>
<p>The logger is set up as follows:</p>

<ul>
<li><code>debug</code> messages don&#39;t go anywhere.<br></li>
<li><code>info</code> goes to the standard output.</li>
<li><code>warn</code>, <code>error</code>, and <code>fatal</code> go to the standard error.<br></li>
<li>Log messages are <em>unformatted</em> when logged to a TTY</li>
<li>Log messages are formatted with timestampes, levels, etc, when logged to a file</li>
</ul>

<p>This means that for command-line use, the user sees messages formatted for them, and not horrible Maven-style enterprise logging.  As soon as
you use your app in <code>cron</code>, however, the logger senses the absence of a TTY and switches its format to this style, so that the log files <em>do</em>
have that valuable information.</p>

<p>You have complete access to the logger via <code>logger</code> and <code>logger=</code>, so you can ultimatley do whatever you want.</p>

<p><code>Methdone::CLILogging</code> is included in <code>Methdone::Main</code>, so, if you followed the structure above, you have access to the logger and these
methods.</p>

<h2>Is there more?</h2>

<p>In addition to all of this, Methadone provides some [Cucumber][cucumber] step definitions, based on [Aruba][aruba] that allow you to
test-drive your command-line app.  When you bootstrap your app using <code>methadone</code>, this will be set up for you.</p>

<p>I&#39;m planning a few more things before v1.0.0, so checkout the [roadmap][roadmap] for more info.</p>

<p>And, don&#39;t forget the [buy the book][book]</p>

<hr>

<footer class='footnotes'>
<ol>
<li>
<a name='1'></a>
<sup>1</sup>Never fear, if you don't like Methadone, it only takes up a few scant pages at the end.<a href='#back-1'>↩</a>
</li>
<li>
<a name='2'></a>
<sup>1</sup>You can, of course, set <code>DEBUG</code> in the environment and a methadone-powered app <em>will</em> dump the stack on an exception.<a href='#back-1'>↩</a>
</li>
<li>
<a name='3'></a>
<sup>1</sup>Of course, you can continue to use <code>opts.banner=</code> to set your own if you like.<a href='#back-1'>↩</a>
</li>
</ol></footer>

<p>[book]: http://www.awesomecommandlineapps.com
[optparse]: http://www.ruby-doc.org/stdlib-1.9.3/libdoc/optparse/rdoc/OptionParser.html
[gli]: https://github.com/davetron5000/gli
[main]: https://github.com/ahoward/main
[thor]: https://github.com/wycats/thor
[trollop]: http://trollop.rubyforge.org/
[methadone]: https://github.com/davetron5000/methadone
[gogaruco-talk]: http://confreaks.net/videos/638-gogaruco2011-test-drive-the-development-of-your-command-line-applications
[aruba]: https://github.com/cucumber/aruba
[cucumber]: https://github.com/cucumber/cucumber
[roadmap]: https://github.com/davetron5000/methadone/wiki/Roadmap</p>
</div>
  
  


    </article>
  
  
    <article>
      <header>
  
    <h1 class="entry-title"><a href="/blog/2011/10/25/awesome-command-line-apps-in-ruby-in-beta.html">My Book's in Beta!</a></h1>
  
  
    <p class="meta">
      








  



<time datetime="2011-10-25T00:00:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

  <div><p><a href='http://www.awesomecommandlineapps.com/'><img src='http://imagery.pragprog.com/products/249/dccar_xlargebeta.jpg?1319573406'></a></p>

<h3>Build Awesome Command-Line Applications in Ruby</h3>

<h4>Control your Computer, Simplify your Life</h4>

<p>Woot!</p>

<p><a href="http://www.awesomecommandlineapps.com/">My Book</a> is in Beta!  Whoohoo!  It&#39;s all about writing amazing command-line apps in Ruby.  This isn&#39;t about hacking
together UNIX commands, or bash scripting…this is about making apps that are easy to learn, easy to use, easy to write, and
that will delight their users.  Seriously, stop making crappy command-line scripts, read my book, and start kicking ass.</p>

<p>It&#39;s been a <strong>long</strong> time coming.  Please stop now, and go <a href="http://www.awesomecommandlineapps.com/">check it out</a>.  I started this almost a year ago during
<a href="http://forums.pragprog.com/forums/190">PragProWriMo</a>, where I wrote (almost) every single day in November of 2010.  When I saw that <a href="http://www.travisswicegood.com/">Travis
Swicegood</a> (one of the few who made it all the way through) had gotten his manuscript accepted, I cleaned up a chapter
and submitted and the <a href="http://www.pragprog.com">Prags</a> accepted!</p>

<p>I&#39;ve spent my time since then writing, re-writing, re-organizing, and working hard to get this thing done.  It&#39;s in beta,
meaning that you can buy the e-book and read the work in progress.  It&#39;s <em>almost</em> complete, just a few chapters to go, and by
reading it in beta, you can give me valuable feedback to make the book even better.</p>

<p><a href="http://www.awesomecommandlineapps.com/">Check it out</a> now!</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="10">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="8">Newer &rarr;</a>
    
  </div>
</div>

</body></html>
