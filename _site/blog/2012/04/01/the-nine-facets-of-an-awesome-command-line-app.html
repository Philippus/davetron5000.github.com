
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>The Nine Facets of an Awesome Command-Line App - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  

  
  <meta name="description" content="

  
    The Nine Facets of an Awesome Command-Line App
    
      April 01, 2012
    
  
  
    When creating the outline for my book (now officia...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2012/04/01/the-nine-facets-of-an-awesome-command-line-app.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>The Nine Facets of an Awesome Command-Line App</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      April 01, 2012
    </h2>
  </header>
  <section class="blog-content">
    <p>When creating the outline for <a href="http://bit.ly/cli-hl-blog-post">my book</a> (now officially published and in print!), I decided to organize it around the
nine facets of an awesome command-line app.  <a href="http://www.awesomecommandlineapps.com">Each chapter</a> focuses on one of these facets.  They state that an awesome
command-line app should:</p>

<ul>
  <li>have a clear and concise purpose</li>
  <li>be easy to use</li>
  <li>be helpful</li>
  <li>play well with others</li>
  <li>delight casual users</li>
  <li>make configuration easy for advanced users</li>
  <li>install and distribute painlessly</li>
  <li>be well-tested and as bug free as possible</li>
  <li>be easy to maintain</li>
</ul>

<p>In this post, I’ll illustrate each of these facets (along with a test of the tenth chapter on color and formatting), via a code
walkthrough of a simple command-line app I created for work.</p>

<!-- more -->

<p>LivingSocial (where I <a href="http://www.livingsocial.com">work</a>) processes thousands of credit card transactions per day, across a highly distributed, asynchronous system.  When things go wrong, the log files are the first place I look to find answers.  This means that <code class="highlighter-rouge">grep</code> is my go-to tool for analysis.  Even though <code class="highlighter-rouge">grep</code> can highlight search terms in output, with long and complex log lines, it can be hard to pick out just what I’m looking for.  I needed a tool to just highlight text, but not actually “grep out” non-matching lines.</p>

<h2 id="to-the-command-line">To the command-line!</h2>

<p>So, in just a few short hours, <a href="https://github.com/davetron5000/hl">hl</a> was born.  I wrote it using TDD, and, even though it’s barely 100 lines of code, it hits all the notes of an awesome command-line app (if I do say so myself :).  Let’s go through all nine of our “facets of an awesome command-line app” and see what the fuss is about.</p>

<h2 id="have-a-clear--concise-purpose">Have a Clear &amp; Concise Purpose</h2>

<p>The best way to have a clear &amp; concise purpose is to do one thing, and one thing only.  <code class="highlighter-rouge">hl</code> highlights search terms in any output to assist with visual scanning of output.  It doesn’t highlight multiple terms, and it doesn’t remove non-matching lines.  It just highlights terms.  One thing, and one thing only.</p>

<h2 id="be-easy-to-use">Be Easy to Use</h2>

<p>This is a <em>big</em> topic, but here’s an example of using <code class="highlighter-rouge">hl</code>:</p>

<p><code class="highlighter-rouge">
$ grep 987876736 my_logs.log | hl credit_card_token
</code></p>

<p><code class="highlighter-rouge">hl</code> does what it’s asked, by default, without a lot of fuss, just like any other UNIX command.  It has options, but you never
need to worry about them in most cases.  Of course, if you <em>are</em> curious about those options, that leads to our next facet.</p>

<h2 id="be-helpful">Be Helpful</h2>

<p><code class="highlighter-rouge">hl</code> is based on <a href="https://github.com/davetron5000/methadone">methadone</a>, which is a proxy to <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/optparse/rdoc/OptionParser.html">OptionParser</a>, which is <em>the</em> tool to use for parsing the command-line in Ruby.  It’s very powerful, and generates a canonical, documented UI for your app:</p>

<p>```
$ bin/hl –help
Usage: hl [options] [search_term] [filename]</p>

<p>Highlight terms in output without grepping out lines</p>

<p>v1.0.0</p>

<p>Options:
    -c, –color COLOR                Color to use for highlighting
                                     (red|green|yellow|blue|magenta|cyan|white)
                                     (default: yellow)
    -b, –[no-]bright                Use bright colors
    -n, –[no-]inverse               Inverse highlight
    -u, –[no-]underline             Underline highlight
    -p, –regexp PATTERN             Search term as explicit option
    -i, –[no-]ignore-case           Ignore case in match
        –version                    Show help/version info</p>

<p>Default values can be placed in the HL_OPTS environment variable
```</p>

<p>Note how much <code class="highlighter-rouge">OptionParser</code> gives us:</p>

<ul>
  <li>Ability to describe our app, its version, and basic invocation syntax</li>
  <li>Nicely formatted list of options and descriptions</li>
  <li>Ability to accept “negatable” options (we’ll talk about that in a second)</li>
</ul>

<p>Further, I’ve gone to the trouble to make sure that <code class="highlighter-rouge">--color</code> clearly indicates the acceptable values as well as the default.  Finally, I’ve made sure that all options are available in short-form (for easy typing on the command line) and long-form (for clarity when scripting and configuring our app).</p>

<p>Here’s the code that makes this happen (if you aren’t familiar with methadone, the method <code class="highlighter-rouge">on</code> behaves almost exactly like the <code class="highlighter-rouge">on</code> method in <code class="highlighter-rouge">OptionParser</code>):</p>

<p>```ruby
#!/usr/bin/env ruby</p>

<p>require ‘optparse’
require ‘methadone’
require ‘hl’</p>

<p>class App
  include Methadone::Main
  include Methadone::CLILogging</p>

<p>main do |keyword,*filenames|
    # main logic here
  end</p>

<p>description “Highlight terms in output without grepping out lines”</p>

<p>options[:color] = ‘yellow’
  colors = [‘red’, ‘green’, ‘yellow’, ‘blue’, ‘magenta’, ‘cyan’, ‘white’]
  on(“-c COLOR”,       “–color”,”Color to use for highlighting”,colors,”(#{colors.join(‘|’)})”)
  on(“–[no-]bright”,     “-b”,  “Use bright colors”)
  on(“–[no-]inverse”,    “-n”,  “Inverse highlight”)
  on(“–[no-]underline”,  “-u”,  “Underline highlight”)
  on(“–regexp PATTERN”,  “-p”,  “Search term as explicit option”)
  on(“–[no-]ignore-case”,”-i”,  “Ignore case in match”)</p>

<p>arg :search_term, :optional
  arg :filename, :optional</p>

<p>version Hl::VERSION</p>

<p>defaults_from_env_var ‘HL_OPTS’</p>

<p>go!
end
```</p>

<p>Methods like <code class="highlighter-rouge">arg</code>, <code class="highlighter-rouge">version</code>, and <code class="highlighter-rouge">description</code> are helpers from methadone (see the <a href="http://www.naildrivin5.com/blog/2011/12/19/methadone-the-awesome-cli-library.html">intro</a> for more), but note how <em>little</em> code it takes just to make a great and polished UI.</p>

<p>The second part of a helpful app is to include more detailed documentation.  For a command-line app, this is expected to be in the form of a man page.  If you installed <code class="highlighter-rouge">hl</code> with RubyGems, try this:</p>

<p><code class="highlighter-rouge">sh
$ gem man hl
</code></p>

<p>You should see a nicely formatted man page (which also happens <a href="https://github.com/davetron5000/hl/blob/master/README.md">to be the <code class="highlighter-rouge">README</code></a> for the github project)!  Creating a man page is extremely simple thanks to <a href="https://github.com/rtomayko/ronn">ronn</a>.  <code class="highlighter-rouge">ronn</code> converts Markdown to troff, the format used by the man system.  Just add this to your Rakefile:</p>

<p>```ruby
require ‘methadone’
require ‘fileutils’</p>

<p>include Methadone::SH
include FileUtils</p>

<p>task :man do 
  sh ‘ronn –markdown –roff man/hl.1.ronn’
  mv ‘man/hl.1.markdown’,’README.md’
end
```</p>

<p>And, your gemspec just needs:</p>

<p><code class="highlighter-rouge">ruby
  s.add_development_dependency('ronn')
  s.add_dependency('gem-man')
</code></p>

<p>You’ll also need to include the generated file <code class="highlighter-rouge">man/hl.1</code> in your <code class="highlighter-rouge">files</code> in your gemspec, but if you’re using the gemspec created by Bundler, this happens automatically as long as the file is in source control.</p>

<p>That’s <em>it</em>.   Now your app has a great UI <em>and</em> a man page, and all you had to do was drop a few lines of code and write a short Markdown file (which you’d write anyway, since you <em>are</em> making a README, right?).</p>

<p>In addition to being helpful to humans, awesome command-line apps should be helpful to other commands.</p>

<h2 id="play-well-with-others">Play well with others</h2>

<p>An app that “plays well with others” on the command line, basically means that it acts as a <em>filter</em>. Text comes in, gets processed, the processed text goes out.  The expectation is that text from any other “well playing” program can be input into our program, and that our program’s output can be piped into another program as input.</p>

<p>Since the purpose of our app is to add ANSI escape codes to the output for assistance with <em>human</em> visual scanning, we can’t claim that our <em>output</em> plays well with others; it’s not designed to.  But, we can still play well with the output from <em>other</em> apps.</p>

<p>We saw that <code class="highlighter-rouge">hl</code> was designed to take input from a tool like <code class="highlighter-rouge">grep</code>.  <code class="highlighter-rouge">hl</code> can also highlight terms from any number of files given to it on the command line.  You can do this transparently in Ruby using the awesome <a href="http://ruby-doc.org/core-1.9.3/ARGF.html">ARGF</a>, however Methadone doesn’t support ARGF (a sad fact I learned while writing this app, and something <a href="https://github.com/davetron5000/methadone/issues/34">I’ll address</a> in the near future), so here’s how did it (a few comments added to indicate what’s going on):</p>

<p><code class="highlighter-rouge">ruby
# filenames is a possibly empty list of strings
files = if filenames.empty?
          [STDIN]
        else
          filenames.map { |_| File.open(_) }
        end
# files is now an Array of open IO objects
begin
  # highlighting code
ensure
  # we close the files since we didn't open them in "block" form; closing STDIN is OK to do
  # since we know our app will soon exit
  files &amp;&amp; files.map(&amp;:close)
end
</code></p>

<p>Again, ARGF handles this transparently, but the point is, we want the standard input and a provided list of files to be treated the same by our program, and this is how I did it.</p>

<p>Since our app is similar in concept to grep, I thought it would be nice if users familiar with grep could be instantly familiar
with <code class="highlighter-rouge">hl</code>.</p>

<h2 id="delight-casual-users">Delight Casual Users</h2>

<p>This is a “level up” from “being easy to use”.  The idea behind the term “delight” is to provide a level of polish and attention to detail that your users will appreciate if they’re observant, but hopefully not even notice, because your app “just works”.</p>

<p>Since <code class="highlighter-rouge">hl</code>, like <code class="highlighter-rouge">grep</code>, is used for filtering and examining text files,  I chose my command-line options to match <code class="highlighter-rouge">grep</code>’s where i could.  Initially, I had the short-form of <code class="highlighter-rouge">--inverse</code> as <code class="highlighter-rouge">-i</code>.  When I later added the ability to do a case-insensitive match, I realized that <code class="highlighter-rouge">-i</code> is the option to <code class="highlighter-rouge">grep</code> for “case-insensitive”.  I quickly changed <code class="highlighter-rouge">--inverse</code> to have <code class="highlighter-rouge">-n</code> as its short-form, and made <code class="highlighter-rouge">-i</code> and <code class="highlighter-rouge">--ignore-case</code> the options for case-insensitivity.  These are the same values that <code class="highlighter-rouge">grep</code> uses, so a user who might subconciously type <code class="highlighter-rouge">hl -i</code> expecting a case-insensitive match will get it.</p>

<p>Further, I allowed the user to specify the search term either as a command-line argument, or as the argument to <code class="highlighter-rouge">-p</code> or <code class="highlighter-rouge">--regexp</code>, which are the option names <code class="highlighter-rouge">grep</code> uses.  It’s a basic principle of design that things that are the same should be <em>exactly</em> the same, so I used <code class="highlighter-rouge">grep</code> as my guide when <code class="highlighter-rouge">hl</code> implemented similar features.</p>

<p>Of course, power users love to customize things.</p>

<h2 id="make-configuration-easy">Make Configuration Easy</h2>

<p>In the book, I talk about using YAML as a configuration format for an <code class="highlighter-rouge">.rc</code> file.  This can be very useful for complex apps, but another technique that’s handy is to allow an environment variable to hold default options.  <code class="highlighter-rouge">grep</code> does this via <code class="highlighter-rouge">GREP_OPTS</code> and if you were paying attenion, you noticed this line in <code class="highlighter-rouge">bin/hl</code>:</p>

<p><code class="highlighter-rouge">ruby
  defaults_from_env_var 'HL_OPTS'
</code></p>

<p>This tells methadone to look at the environment variable <code class="highlighter-rouge">HL_OPTS</code> (as well as the command line) for any options.  These options are placed first in <code class="highlighter-rouge">ARGV</code>, essentially like so:</p>

<p><code class="highlighter-rouge">ruby
String(ENV[@env_var]).split(/\s+/).each do |arg|
  ::ARGV.unshift(arg)
end
</code></p>

<p>(Note the use of <code class="highlighter-rouge">String</code> to make sure that <code class="highlighter-rouge">nil</code> gets turned into the empty string, saving us an <code class="highlighter-rouge">if</code> statement).  Methadone does this before parsing <code class="highlighter-rouge">ARGV</code>.  Using <code class="highlighter-rouge">unshift</code> means that any options the <em>user</em> specifies will come <em>after</em> those in <code class="highlighter-rouge">HL_OPTS</code> and therefore take precendence:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ export HL_OPTS=--color=cyan
$ grep foo some_log.txt | hl --color=magenta
</code></pre>
</div>

<p>This is the same as</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ grep foo some_log.txt | hl --color-cyan --color=magenta
</code></pre>
</div>

<p>This is also why I’ve provided the “negatable” forms.  Suppose you generally wanted inverse:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ export HL_OPTS=--inverse
</code></pre>
</div>

<p>If you wanted to run <code class="highlighter-rouge">hl</code> <em>without</em> inverse, but there was no negatable option, the only way to turn it off would be to unset the environment variable.  With the negatable forms, it’s simple:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ grep foo some_log.txt | hl --no-inverse
</code></pre>
</div>

<p>Since the user’s command-line options take precedence, things work out, but you can still configure your defaults.</p>

<p>Finally, I’d recommend that you use the long-form options in your configuration.  In other words, if you prefer bright and inverted highlights, do this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ export HL_OPTS='--inverse --bright'
</code></pre>
</div>

<p>As opposed to</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ export HL_OPTS=-nb
</code></pre>
</div>

<p>The second form is more compact, but your configuration is going to be <em>read</em> more than written, and, 6 months from now when you are going through your <code class="highlighter-rouge">.bashrc</code>, you’re going to appreciate seeing things spelled out; you’ll know instantly what the configuration does and don’t have to wonder about what <code class="highlighter-rouge">-n</code> means.</p>

<h2 id="distribute-painlessly">Distribute Painlessly</h2>

<p>RubyGems:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ gem install hl
$ hl --help
</code></pre>
</div>

<p>That is all.</p>

<h2 id="be-well-tested">Be well-tested</h2>

<p>I wrote <code class="highlighter-rouge">hl</code> entirely using <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> and entirely using <a href="https://github.com/cucumber/aruba">aruba</a>.  Here’s a sampling:</p>

<p><code class="highlighter-rouge">cucumber
  Scenario: Highlights with case insensitivity
    Given a file named "test_file" with the word "FOO bar foo" in it
    When I successfully run `hl -i foo ../../test_file`
    Then the entire contents of "test_file" should be output
    But the word "foo" should be highlighted in yellow
    And the word "FOO" should be highlighted in yellow
</code></p>

<p>It was very easy to do this, although aruba could use a man page for easier reference.  I had to jump into its source too many times to get reminded of the syntax of the steps it provides.  Aruba also strips out ANSI escape sequences, which made testing <code class="highlighter-rouge">hl</code> a bit tricky.  There appears to be an option to <em>prevent</em> this, but I couldn’t get it to work, so I just used Aruba’s internal API:</p>

<p><code class="highlighter-rouge">ruby
Then /^the word "([^"]*)" should be highlighted in (.*$)$/ do |keyword,color|
  # #color is provided by rainbow, which we'll talk about in a bit
  expected = keyword.color(color.to_sym)
  # assert_partial_output and all_stdout are provided by aruba
  assert_partial_output(expected,all_stdout)
end
</code></p>

<p>I still recommend aruba and cucumber, as it forces you to think about how users will use your app first, not how to implement it.  In fact, my initial implementation was a big hacky mess of stuff inside the <code class="highlighter-rouge">main</code> block.  Once the tests were in place, I refactored it to be a lot cleaner.</p>

<h2 id="be-easy-to-maintain">Be Easy to Maintain</h2>

<p>As I just mentioned, I was able to use my tests to refactor my code.  As such, the main block of <code class="highlighter-rouge">hl</code> is pretty simple:</p>

<p>```ruby
main do |keyword,*filenames|
  if options[:regexp]
    Array(filenames).unshift(keyword)
    keyword = options[:regexp]
  end</p>

<p>exit_now! ‘search term or –regexp/-p required’ if keyword.nil?</p>

<p>keyword = keyword.dup
  highlighter = Hl::Highlighter.new(options)</p>

<p>puts highlighter.highlight(filenames,keyword)
end
```</p>

<p>This is the sort of logic you want in your <code class="highlighter-rouge">main</code> block:</p>

<ul>
  <li>Handling the keyword-from-argument and keyword-from-command-line-option case</li>
  <li>Simple error checking</li>
  <li>Duping the keyword (since it comes in frozen)</li>
  <li>Calling our <code class="highlighter-rouge">Highlighter</code> class to do the real work</li>
</ul>

<p>We defer all non-UI logic to the <code class="highlighter-rouge">Highlighter</code> class.  I decided to make each instance of the class able to highlight any files repeatedly based on a configuration, so the constructor takes in the formatting options, and the method <code class="highlighter-rouge">highlight</code> takes the list of filenames and the search term.</p>

<p>The actual highlighting is made possible via lots of list comprehension:</p>

<p><code class="highlighter-rouge">ruby
files.map { |_| _.readlines}.flatten.map { |_| highlight_matches(regexp,_) }.join("")
</code></p>

<p>If you aren’t comfortable with this use of chained calls, it can be very powerful.  What this does is:</p>

<ul>
  <li>Map each file to an array of its contents as lines.  <code class="highlighter-rouge">[foo,bar]</code> becomes <code class="highlighter-rouge">[ ['first line of foo\n','second line of foo\n'],['first line of bar\n'],['second line of bar\n']]</code></li>
  <li>Flatten that array of arrays to just one list of all lines of all files.  Our example array becomes: <code class="highlighter-rouge">[ 'first line of foo\n','second line of foo\n','first line of bar\n','second line of bar\n']</code></li>
  <li>map those lines to the lines with the search term highlighted.  Supposing we wanted to highlight the word “line”, our array becomes: <code class="highlighter-rouge">[ 'first \e[33mline\e[0m of foo\n','second \e[33mline\e[0m of foo\n','first \e[33mline\e[0m of bar\n','second \e[33mline\e[0m of bar\n']</code></li>
  <li>join them all together into one big string
<code class="highlighter-rouge">"first \e[33mline\e[0m of foo\nsecond \e[33mline\e[0m of foo\nfirst \e[33mline\e[0m of bar\nsecond \e[33mline\e[0m of bar\n"</code></li>
</ul>

<p>Granted, this approach will probably have trouble with extremely large input, but <code class="highlighter-rouge">hl</code> was designed to work with the output of <code class="highlighter-rouge">grep</code>, so hopefully we won’t have too much (I’ve already decided I need it <a href="https://github.com/davetron5000/hl/issues/1">to work with <code class="highlighter-rouge">tail</code></a> ).</p>

<h2 id="breaking-the-rules">Breaking the rules</h2>

<p>Color and formatting <em>are not</em> typically associated with awesome command-line apps; too much of it makes an app hard to use with other apps.  But, the whole purpose of <code class="highlighter-rouge">hl</code> is to colorize output, so for that, I used <a href="https://github.com/sickill/rainbow">rainbow</a>, which is a pretty
simple enhancement to <code class="highlighter-rouge">String</code> that allows coloring and formatting.  We can see it in action in the <code class="highlighter-rouge">highlight_string</code> method of <code class="highlighter-rouge">Highlighter</code>:</p>

<p><code class="highlighter-rouge">ruby
def highlight_string(string)
  string = string.color(@options['color'].to_sym)
  string = string.inverse if @options[:inverse]
  string = string.bright if @options[:bright]
  string = string.underline if @options[:underline]
  string
end
</code></p>

<p>Each method called on <code class="highlighter-rouge">string</code> is a method provided by Rainbow.  These methods return a new string with the appropriate ANSI escape codes added.</p>

<h2 id="in-conclusion">In Conclusion</h2>

<p>Hopefully, you’ve seen that it’s really <em>not that hard</em> to make an awesome command-line app.  I was able to write <code class="highlighter-rouge">hl</code> in just a few hours, using TDD and the end result is a highly polished, well-documented, easily installable and maintainable piece of software that will be a part of my command-line arsenal for quite a while.  You can do this, too.  There’s a lot more detail and in-depth explanations <a href="http://bit.ly/cli-hl-blog-post">in my book</a>, which you should buy right now :)</p>


  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2016, by David Bryant Copeland, All Rights Reserved
    </p>
  </footer>
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '56a22cd9c88d90284f000861');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>
</body></html>
