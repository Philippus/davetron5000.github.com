
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>What is 'better' code? - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  

  
  <meta name="description" content="

  
    What is 'better' code?
    
      June 27, 2012
    
  
  
    We all want better code.  Rails creator David Heinemeier Hansson said that ...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2012/06/27/what-is-better-code.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>What is 'better' code?</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      June 27, 2012
    </h2>
  </header>
  <section class="blog-content">
    <p>We all want better code.  Rails creator David Heinemeier Hansson said that the only way to evaluate a code change is if the new code is “better” than the old.  Of course, he didn’t define what he meant by “better”.  At Scottish Ruby Conf, Dave Thomas said that good code is code that is easy to change.  This is a bit more specific, but not really enough to give any real direction.</p>

<p>Let’s see if we can derive a real understanding of code quality.</p>

<!-- more -->

<p>What do we do with code?  In decreasing order of frequency:</p>

<ul>
  <li><em>We execute it.</em>  Hopefully, our code spends most of its time executing.</li>
  <li><em>We read it.</em>  To gain an understanding, to review it, to change it, we must read it.</li>
  <li><em>We change it.</em>  To add new features, or fix bugs, we must change it.</li>
  <li><em>We write it.</em>  On occasion, we’ll write new code.</li>
</ul>

<p>The most frequent thing we do with code?  Execute it.  Code that runs, based on our current understanding (i.e. passes its tests), is the absolute minimum of acceptability.  It’s at this point that average developers typically stop.  If it works, ship it!</p>

<p>We aren’t average developers.  We want to do better.</p>

<p>With almost equally great frequency, our code gets read by humans.  We might read code to prepare for a change.  We might read code to understand how a business rule works.  We might read code as an example of how to do something, or to gain an understanding of some abstract concept.  We read code a lot.</p>

<p>Is there anything objective we can say about code readability?</p>

<h2 id="readability">Readability</h2>

<p>Readability answers the question “How quickly can someone understand this code?”  We must first define “someone”.  A good rule of thumb is “any developer that could be hired to work here”.  You may need to get more specific, but generally constraining the context to your current team will work well.</p>

<p>Once we’ve got context for understanding code, the most obvious thing we could measure would be its size.</p>

<h3 id="size">Size</h3>

<p>Size can mean two things: length (the number of lines of code) and <em>density</em> (the amount of information per line of code).  The more code you must evaluate, by either measure, the longer it will take to come to an understanding.  The distinction between length and density is interesting.  Short, but dense code, can be just as difficult to grasp as long sparse code.</p>

<p><code class="highlighter-rouge">ruby
def create_new_person(first_name, last_name, birthdate)
  raise "first name and last name required" if first_name.nil? || last_name.nil?
  Person.create(:first_name =&gt; first_name, :last_name =&gt; last_name).tap do { |person|
    person.age = Time.now.year - birthdate.year if birthdate.present?
  }
end
</code></p>

<p>Here’s the same routine, rewritten to be as sparse as possible:</p>

<p><code class="highlighter-rouge">ruby
def create_new_person(first_name, last_name, birthdate)
  if first_name.nil? || last_name.nil?
    raise "first name and last name required" 
  end
  person = Person.create(:first_name =&gt; first_name, :last_name =&gt; last_name)
  if birthdate.present?
    person.age = Time.now.year - birthdate.year
  end
  person
end
</code></p>

<p>Which one do you find easier to understand?  I would argue that the answer is not so clear-cut.  What <em>is</em> interesting is that modern languages, like Ruby or Scala, tend to encourage denser, shorter programs.  Some densly-packed statements are idiomatic, and are easily understood, while others become impeneatrable code golf.  Know the difference and you can get a good sense of the size of a piece of code.</p>

<h3 id="variables">Variables</h3>

<p>Any field, parameter, global, or local variable is a “variable” for the purposes of code readability.  Variables are placeholders for the calculations our code performs, and the more of them there are, the more abstract pieces of data you must hold in your head in
order to understand a piece of code.</p>

<p>Beyond the raw count of variables, the scope of each variable can also affect our understanding of code.  A routine that uses nothing but local variables will be easier to undestand than one using all globals.  Since globals can change outside of the routine you are reading, you need to have a higher level grasp of the system, so you can understand what possible values those variables might have.  The smaller the scope of a variable, the easier it is to understand what values it might have, and the easier it is to understand the code it’s used in.</p>

<p>Of course, variable names are important, too.  Descriptive (and accurate) names help our understanding, while symbol or inaccurate names can harm it.</p>

<p>Here’s a pattern I’ve seen in complex controllers, where ivars are used to pass variables between methods (you’ll need to imagine many other controller methods here):</p>

<p>```ruby
class PeopleController &lt; ApplicationController
  def destroy
    id = params[:id]
    @person = Person.find(id)
    if can_destroy?
      @person.destroy
      redirect_to persons_path
    else
      flash[:error] = @error
      redirect_to persons_path
    end
  end</p>

<p>private</p>

<p>def can_destroy?
    if @person.admin? 
      @error = ‘You cannot delete an admin’
      false
    elsif @person.orders.unfulfilled.any?
      @error = ‘Person has unfullied orders’
      false
    else
      true
    end
  end
end
```</p>

<p>Notice how both outcomes of <code class="highlighter-rouge">destroy</code> are redirects, yet we are setting <code class="highlighter-rouge">@person</code>.  In a Rails controller, you create ivars to communicate data to the view, but for a redirect, these variables don’t apply.  <code class="highlighter-rouge">@person</code> is effectively a parameter passed to <code class="highlighter-rouge">can_destroy?</code> but without declaring it as a parameter.  Further, <code class="highlighter-rouge">@error</code> is being initialized in <code class="highlighter-rouge">can_destroy?</code> and acts as a return value.  Finally, does <code class="highlighter-rouge">id</code> need to be a variable at all?  It’s only used in one place.  Here’s a version that keeps variables to a minimum scope:</p>

<p>```ruby
class PeopleController &lt; ApplicationController
  def destroy
    person = Person.find(params[:id])
    error = can_destroy?(person)
    if error.nil?
      person.destroy
      redirect_to persons_path
    else
      flash[:error] = error
      redirect_to persons_path
    end
  end</p>

<p>private</p>

<p>def can_destroy?(person)
    if person.admin? 
      ‘You cannot delete an admin’
    elsif person.orders.unfulfilled.any?
      ‘Person has unfullied orders’
    else
      nil
    end
  end
end
```</p>

<p>Not only is the code a bit shorter, but each routine is simpler to understand, because the scope of the variables used are constrainted to only where they are needed.</p>

<h3 id="number-of-classesmethods">Number of classes/methods</h3>

<p>This is where things get interesting.  If you need to follow the path of execution through many methods or classes to get an understanding of some code, it’s going to be harder to do so.  Of course, with fewer classes, you’ll tend toward larger methods which, of course, can also be hard to understand.</p>

<p>Consider the refactor from my <a href="http://www.naildrivin5.com/blog/2012/06/10/single-responsibility-principle-and-rails.html">controversial blog post</a>.  In that post, I extracted a class from a Rails controller to handle the business process of creating a new user.  Although the two classes were both very short and easy to understand, the entire codebase went from one class that contained all the code, to two classes.  Which is easier to understand?  It depends.  But, by trying to quantify the differences in the code, we can approach an understanding.</p>

<h3 id="paths-through-the-code">Paths through the code</h3>

<p>Often referred to as “complexity” in computer science, the number of possble paths of execution through a piece of code can greatly affect its ability to be understood by a person.  Consider this slightly modified version of <code class="highlighter-rouge">can_destroy?</code> from our example above:</p>

<p><code class="highlighter-rouge">ruby
def can_destroy?(person)
  errors = []
  if person.admin? 
    errors &lt;&lt; 'You cannot delete an admin'
  end
  if person.orders.unfulfilled.any?
    errors &lt;&lt; 'Person has unfullied orders'
  end
  return errors.join(',')
end
</code></p>

<p>There are two <code class="highlighter-rouge">if</code> statements here, which gives us <em>four</em> possible ways through this code.  This means that, to gain a real understanding of this code, we need to mentally play through all four scenarios in our heads.  Since the expression of each <code class="highlighter-rouge">if</code> statement is simple, this isn’t so bad.  What if we needed to add a feature where employees are also not allowed to be destroyed in our controller?</p>

<p><code class="highlighter-rouge">ruby
def can_destroy?(person)
  errors = []
  if person.admin? || person.is_employee?
    errors &lt;&lt; 'You cannot delete an admin or employee'
  end
  if person.orders.unfulfilled.any?
    errors &lt;&lt; 'Person has unfullied orders'
  end
  return errors.join(',')
end
</code></p>

<p>We’ve added an additional case for our first <code class="highlighter-rouge">if</code> statement, and so we have more paths:</p>

<ul>
  <li><code class="highlighter-rouge">person.admin?</code> true, <code class="highlighter-rouge">#is_employee?</code> false, <code class="highlighter-rouge">orders.unfulfilled.any?</code> false</li>
  <li><code class="highlighter-rouge">person.admin?</code> true, <code class="highlighter-rouge">#is_employee?</code> true, <code class="highlighter-rouge">orders.unfulfilled.any?</code> false</li>
  <li><code class="highlighter-rouge">person.admin?</code> true, <code class="highlighter-rouge">#is_employee?</code> false, <code class="highlighter-rouge">orders.unfulfilled.any?</code> true</li>
  <li><code class="highlighter-rouge">person.admin?</code> true, <code class="highlighter-rouge">#is_employee?</code> true, <code class="highlighter-rouge">orders.unfulfilled.any?</code> true</li>
  <li><code class="highlighter-rouge">person.admin?</code> false, <code class="highlighter-rouge">#is_employee?</code> false, <code class="highlighter-rouge">orders.unfulfilled.any?</code> false</li>
  <li><code class="highlighter-rouge">person.admin?</code> false, <code class="highlighter-rouge">#is_employee?</code> true, <code class="highlighter-rouge">orders.unfulfilled.any?</code> false</li>
  <li><code class="highlighter-rouge">person.admin?</code> false, <code class="highlighter-rouge">#is_employee?</code> false, <code class="highlighter-rouge">orders.unfulfilled.any?</code> true</li>
  <li><code class="highlighter-rouge">person.admin?</code> false, <code class="highlighter-rouge">#is_employee?</code> true, <code class="highlighter-rouge">orders.unfulfilled.any?</code> true</li>
</ul>

<p>If we were to extract the first <code class="highlighter-rouge">if</code> statement’s expression to a method, we’d reduce the complexity of this code:</p>

<p>```ruby
class Person
  def deletable?
    person.admin? || person.is_employee?
  end
end</p>

<p>def can_destroy?(person)
  errors = []
  if person.deletable?
    errors « ‘You cannot delete an admin or employee’
  end
  if person.orders.unfulfilled.any?
    errors « ‘Person has unfullied orders’
  end
  return errors.join(‘,’)
end
```</p>

<p>We’ve simplified <code class="highlighter-rouge">can_destroy?</code>, but we’ve added a new method to <code class="highlighter-rouge">Person</code>.  Readability isn’t so simple, is it?</p>

<p>Let’s complicate things further by understanding our abilitiy to change code.</p>

<h2 id="ability-to-change">Ability to Change</h2>

<p>When changing code, you often want to know where to make the change, but you also want to keep the scope of the change as small as possible.  Readability in general, and the measures we’ve outlined above in particular, affect this greatly.  If we have one giant routine, we know where to make the change, but if we have many single-purpose classes instead, the scope of our change is smaller.  Are there other aspects of our code that affect this?</p>

<p>In general, <em>coupling</em> is an indicator of the scope of a particular change.  If two classes are tightly coupled, it means that a change one is likely to necessitate a change in another.  Further, a class that is coupled to many classes is going to result in a system that is harder to change.  This is the basis for the “Law of Demeter”.  Code that “violates” this law is coupling itself to more classes than code that doesn’t “violate” the “law” and is thus harder to change.</p>

<p>The dependencies between classes are a good indicator of coupling.</p>

<h3 id="fan-out">Fan out</h3>

<p>A class or method that uses a lot of classes or methods to do its work has higher coupling than one that uses fewer.  This is often referred to as <em>fan out</em>, and it means that the class in question is more likely to have to change when the classes or methods it uses change.</p>

<h3 id="fan-in">Fan in</h3>

<p>Conversely, a class or method that a lot of other classes or methods use also has high coupling.  Obvious examples in a Rails app would be a central model object (like a person or an order), or helper methods in <code class="highlighter-rouge">ApplicationHelper</code>.  These objects and methods get used everywhere, and thus are very hard to change, because a change can have a ripple effect through the system.</p>

<p>Notice again how these conflict with other attributes of readability.  A routine that is quite large, but has no external dependencies has almost no coupling, but could be hard to understand, since it is long, potentially having many variables and many paths through the code. Code spread across many single-purpose classes in a loosely coupled way will be easier to change, but potentially harder to understand.</p>

<h2 id="better">Better</h2>

<p>So, what is “better” code?  I don’t think we’ll ever have a fool-proof way of figuring this out, but we <em>do</em> have objective measures we can use to better explain why we think one piece of code might be better than another.    Next time you’re reviewing code or doing a refactor, instead of relying on a gut feel of “better”, jot down where the code stands along measurements like these. How does the new code compare to the old?  The answer might surprise you.</p>


  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2016, by David Bryant Copeland, All Rights Reserved
    </p>
  </footer>
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '56a22cd9c88d90284f000861');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>
</body></html>
