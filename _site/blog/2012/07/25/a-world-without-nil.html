
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>A world without nil - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">

  
  <meta name="description" content="

  
    A world without nil
    
      July 25, 2012
    
  
  
    Previously, we saw how just using functions in Ruby, we could create a lot of ...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2012/07/25/a-world-without-nil.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>A world without nil</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      July 25, 2012
    </h2>
  </header>
  <section class="blog-content">
    <p><a href="http://www.naildrivin5.com/blog/2012/07/17/adventures-in-functional-programming-with-ruby.html">Previously</a>, we saw how just using functions in Ruby, we could create a lot of powerful code.  Let&#39;s continue the theme of &quot;programming with constraints&quot; and try to solve an actual problem. <code>nil</code>.</p>

<!-- more -->

<h2>Is <code>nil</code> a problem?</h2>

<p><code>nil</code> creates problems in code clarity and revealing programmer intent.  <code>nil</code> means
&quot;no value&quot; sometimes, but other times it means <code>false</code>.  Other times it means &quot;the developer didn&#39;t think of the proper default
for a value&quot;.  Rails migrations, by default, allow database columns to be nullable.  This is often not correct, and by making it
the default, you cannot tell the difference between &quot;the business requires that this field be nullable&quot; and &quot;the developer forgot
to consider the nullability of this column&quot;.</p>

<p>The problems manifest when you see a test failure or production error where something is <code>nil</code> that you weren&#39;t expecting.  Now
you have to figure out if that value could be <code>nil</code> (and the original developer missed the edge case) or if it should <em>never</em> be
<code>nil</code>, and you have a more serious problem in either your data, business logic, or worse.</p>

<p>The reason this becomes complex isn&#39;t necessarily the concept of &quot;no such value&quot; (though this <em>is</em> a bit of a problem), but the way in which <code>nil</code> is treated by the language.  In Ruby, <code>nil</code> is the only instance of <code>NilClass</code> and has the following magical properties that cannot be bestowed on any other object:</p>

<ul>
<li>it is &quot;falsey&quot; (a trait shared with only one other value, <code>false</code>, the sole value of <code>FalseClass</code>)</li>
<li>it is the default value of every variable</li>
</ul>

<p>Because of these two things, we use it all over the place to represent &quot;no value&quot;, and our code is littered with:</p>

<ul>
<li><code>do_something if value.nil?</code></li>
<li><code>foo ||= {}</code></li>
<li><code>Array(some_list).each</code></li>
</ul>

<p>And so forth.  Avdi Grimm gave <a href="http://confreaks.com/videos/763-rubymidwest2011-confident-code">a talk at Ruby Midwest</a> called &quot;Confident Ruby&quot; that deals, in part, with nil and how to avoid it.  Things like <code>Array()</code>, <code>String()</code>, and null objects are good techniques.</p>

<p>But let&#39;s take a different approach.  What if there were no such thing as <code>nil</code>, and the language didn&#39;t support it?</p>

<h2>Can you imagine? A world without <code>nil</code>?</h2>

<p><img src="http://25.media.tumblr.com/tumblr_ltbtgjU70B1qztjn5o1_500.jpg" alt="275"></p>

<p>Suppose there were no such thing as <code>nil</code> in Ruby.  Every variable would require that a value be assigned to it at declare time, and the runtime would raise an exception if you tried to use a variable/parameter/etc. without a value.</p>

<p>How would that change the way we code?</p>

<p>Of course, we could re-invent it:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NilClass</span>
  <span class="vc">@@nil</span> <span class="o">=</span> <span class="no">NilClass</span><span class="o">.</span><span class="n">new</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span>
    <span class="vc">@@nil</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">nil?</span>
    <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">BasicObject</span>
  <span class="k">def</span> <span class="nf">nil?</span>
    <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="vg">$nil</span> <span class="o">=</span> <span class="no">NilClass</span><span class="o">.</span><span class="n">new</span>
</code></pre></div>
<p>This gives us a value that means &quot;no value&quot;, but without the magic provided by the language, what good is it?</p>

<p>Let&#39;s return to our domain from the previous post, where we want to make a system that manages users in a database.  Since we now have our fully armed and operational object-oriented programming language, we might be inclined to make a <code>Person</code> class:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">attr_reader</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:birthdate</span><span class="p">,</span> <span class="ss">:gender</span><span class="p">,</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">:id</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span><span class="n">birthdate</span><span class="p">,</span><span class="n">gender</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="nb">id</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="vi">@birthdate</span> <span class="o">=</span> <span class="n">birthdate</span>
    <span class="vi">@gender</span> <span class="o">=</span> <span class="n">gender</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="n">title</span>
    <span class="vi">@id</span> <span class="o">=</span> <span class="nb">id</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Remember, we don&#39;t have <code>nil</code>, so we don&#39;t have a default value for any variable - we must assign one explicitly or we&#39;ll get runtime errors.  Given the code above, this shouldn&#39;t be a problem, since we assign values to our ivars when they are declared.</p>

<p>If you recall, however, we have two optional values in our <code>Person</code>: <code>title</code>, and <code>id</code>. <code>title</code> is simply optional - a person might not have a title - while <code>id</code> will only be populated if the person has been stored in the database.  How can we model this?</p>

<h2>Generic optional values?</h2>

<p>Scala (a statically-typed functional/OO language that runs on the JVM), &quot;solves&quot; this by creating an <code>Option</code> type that makes explicit the concept of an optional value<a name="back-1"></a><sup><a href="#1">1</a></sup>.  In Ruby, it would look like this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># The base class that also serves as a factory for instances</span>
<span class="k">class</span> <span class="nc">Optional</span>
  <span class="c1"># Optional value that has a value</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="no">Some</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Optional value with NO value</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">none</span>
    <span class="no">None</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Some</span> <span class="o">&lt;</span> <span class="no">Optional</span>
  <span class="kp">attr_reader</span> <span class="ss">:value</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">exists?</span>
    <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">None</span> <span class="o">&lt;</span> <span class="no">Optional</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">exists?</span>
    <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>We can use it like so:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">dave</span> <span class="o">=</span> <span class="no">Person</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;Dave&quot;</span><span class="p">,</span><span class="s2">&quot;1972-01-01&quot;</span><span class="p">,</span><span class="ss">:male</span><span class="p">,</span><span class="no">Optional</span><span class="o">.</span><span class="n">none</span><span class="p">,</span><span class="no">Optional</span><span class="o">.</span><span class="n">none</span><span class="p">)</span>
<span class="n">rudy</span> <span class="o">=</span> <span class="no">Person</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;Rudy&quot;</span><span class="p">,</span><span class="s2">&quot;2001-01-01&quot;</span><span class="p">,</span><span class="ss">:male</span><span class="p">,</span><span class="no">Optional</span><span class="o">.</span><span class="n">some</span><span class="p">(</span><span class="s2">&quot;cat&quot;</span><span class="p">),</span><span class="no">Optional</span><span class="o">.</span><span class="n">some</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="k">if</span> <span class="n">title</span><span class="o">.</span><span class="n">exists?</span>
      <span class="n">title</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">name</span>
    <span class="k">else</span>
      <span class="nb">name</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>So, we&#39;ve replaced what would be a call to <code>.nil?</code> in regular Ruby with a call to <code>.exists?</code> in our nil-less Ruby.  Is this really any better?  We could wrap the logic of &quot;do one thing if there&#39;s a value, do another if there isn&#39;t&quot; into a method on <code>Optional</code>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Some</span>
  <span class="k">def</span> <span class="nf">with_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span><span class="o">&amp;</span><span class="n">_</span><span class="p">)</span>
    <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">None</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">with_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_</span><span class="p">,</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">block</span><span class="o">.</span><span class="n">call</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>We could then implement <code>salutation</code> like so:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">with_value</span><span class="p">(</span>
      <span class="o">-&gt;</span><span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="p">{</span> <span class="n">title</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">name</span> <span class="p">},</span>
      <span class="o">-&gt;</span>        <span class="p">{</span> <span class="nb">name</span> <span class="p">}</span>
    <span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Yech.  We might be able to play some syntax games and clean this up, but this is <em>not</em> an improvement.  <code>if/else</code> statements are
easy to understand and with the magic of <code>nil</code>, the logic is pretty straightforward:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="k">if</span> <span class="nb">self</span><span class="o">.</span><span class="n">title</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">title</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">self</span><span class="o">.</span><span class="n">name</span>
    <span class="k">else</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">title</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p><code>Optional</code>, as we&#39;ve defined it, is just a degenerate implementation of <code>nil</code> that has a terrible API<a name="back-2"></a><sup><a href="#2">2</a></sup>.  It <em>does</em> have the advantage of not being magic - we are required to provide a value for every variable, which is nice - but can we do better?</p>

<h2>Solving the problem in front of us</h2>

<p>Let&#39;s step back and just try solving the problem in front of us, instead of adding the general concept of optional values.  What if we used the type system more explicitly?  </p>

<p>Suppose we define <code>Person</code> to be only the <em>required</em> values, i.e. the bare essence of a person in our system, and then create
mixins for the optional values.  We could make a mixin like <code>Stored</code> act as both a &quot;tag&quot; for an object that is stored in the
database, and as the location for related code.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Person</span>
  <span class="c1"># Every person must have a name, birthdate, and gender.</span>
  <span class="kp">attr_reader</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:birthdate</span><span class="p">,</span> <span class="ss">:gender</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span><span class="n">birthdate</span><span class="p">,</span><span class="n">gender</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="vi">@birthdate</span> <span class="o">=</span> <span class="n">birthdate</span>
    <span class="vi">@gender</span> <span class="o">=</span> <span class="n">gender</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Stored</span>
  <span class="kp">attr_reader</span> <span class="ss">:id</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Titled</span>
  <span class="kp">attr_reader</span> <span class="ss">:title</span>
<span class="k">end</span>
</code></pre></div>
<p>Note that we don&#39;t make <code>id</code> or <code>title</code> mutable; they are still read-only fields.  So, how do they get set?  We tightly couple
<code>Person</code> with these new modules and set the fields there.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">title</span><span class="o">=</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="n">title</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="no">Titled</span><span class="p">)</span> <span class="c1"># THIS object is now a Titled, but other Person instances are not</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">id</span><span class="o">=</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="vi">@id</span> <span class="o">=</span> <span class="nb">id</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="no">Stored</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Note that if we wanted to maintain total immutability, we would need to jump through a few hoops:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">with_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">dup</span><span class="o">.</span><span class="n">tap</span> <span class="p">{</span> <span class="o">|</span><span class="n">person</span><span class="o">|</span>
      <span class="n">person</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="no">Titled</span><span class="p">)</span>
      <span class="n">person</span><span class="o">.</span><span class="n">instance_variable_set</span><span class="p">(</span><span class="s2">&quot;@title&quot;</span><span class="p">,</span><span class="n">title</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">end</span>
</code></pre></div>
<p>In either case, we end up with an instance that has mixed in <code>Titled</code> and absolutey has a value for <code>title</code>.</p>

<p>How would this affect our <code>salutation</code> method?</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="k">if</span> <span class="nb">self</span><span class="o">.</span><span class="n">kind_of?</span><span class="p">(</span><span class="no">Titled</span><span class="p">)</span>
      <span class="s2">&quot;</span><span class="si">#{</span><span class="n">title</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span>
      <span class="nb">name</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>We&#39;ve replaced a generic check - for <code>nil</code> - with a specific check - for being <code>Titled</code>.  This may not seem like an improvement, but I&#39;d argue that it makes our domain a bit richer and more intention-revelaing.  It turns an implementation decsion (treating <code>nil</code> as not having a title) into something explicit. And, at the end of the day, if we need logic based on the existence of a value, well, we&#39;re going to need to use <code>if</code> statements.  </p>

<p>Or are we?</p>

<p>Before we answer that, it&#39;s worth noting that although <code>Titled</code> is specific to our <code>Person</code> class, <code>Stored</code> is a more generic concept that could be broadly used to explicitly call out records not stored in the database.  Imagine an <code>update</code> method like so:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">NotStoredError</span> <span class="k">unless</span> <span class="n">record</span><span class="o">.</span><span class="n">kind_of?</span><span class="p">(</span><span class="no">Stored</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>That reads a lot better to me than a <code>nil</code> check<a name="back-3"></a><sup><a href="#3">3</a></sup>.  It also abstracts away the way in which we know that a record is stored, but without requiring a common superclass.</p>

<p>Back to our <code>if</code> statement.  We have a business rule based on the existence of a value, so it seems we just have to live with the conditional logic, right?  Not exactly.  What if both <code>Person</code> and <code>Titled</code> implemented <code>salutation</code>?</p>

<p>Person would use the &quot;default if no title&quot; version, because a raw <code>Person</code> has no title:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="nb">name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Once <code>Titled</code> is mixed in, we know that we absolutely have a title, so we override it with the correct logic given a title:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Titled</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="n">title</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="k">super</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Now, <em>this</em> is interesting.  We&#39;re using polymorphism and inheritance as a way to avoid <code>if</code> statements.  If we&#39;d used <code>nil</code> to
represent &quot;no title&quot;, we&#39;d be stuck with conditional logic.  The added constraint of programming without <code>nil</code> has forced us to
get creative and resulted in a cleaner solution.</p>

<p>We&#39;ve now used the type system to create an explicit description of our domain, and we didn&#39;t need <code>nil</code>.  Of course, a type that has a lot of optional values will require a lot of these sorts of modules, and it could get ugly.  This might be a good thing.</p>

<p>Now that we can handle optional values in our data structures, what about containers?  </p>

<h2>Optional values in container classes</h2>

<p>I see a lot of code using <code>first</code> or <code>last</code> on an array as a shortcut for checking if the array is empty and, if not, getting the first or last element respectively.  Obviously, this would have to stop, but what about so-called &quot;sparse arrays&quot; where some indeces contain <code>nil</code> values?  Dealing with this cleanly is not simple given the currently API of <code>Array</code>.  Of course, if the language never had <code>nil</code>, you could imagine that <code>Array</code> would have <em>some</em> facility for dealing with this.  On idea would be that each accessor method would accept an optional block that would be run if there were no value, so that the caller could provide a default:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">list</span> <span class="o">=</span> <span class="o">[]</span>
<span class="n">list</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>                               <span class="c1"># =&gt; raises IndexError</span>
<span class="n">list</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">{</span> <span class="o">|</span><span class="n">index</span><span class="o">|</span> <span class="s2">&quot;default</span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span> <span class="c1"># =&gt; default0</span>
<span class="n">list</span><span class="o">.</span><span class="n">first</span> <span class="p">{</span> <span class="s2">&quot;default&quot;</span> <span class="p">}</span>              <span class="c1"># =&gt; default</span>
</code></pre></div>
<p>When we&#39;re talking about containers, however, we&#39;d need to be able to model &quot;there is no value at this location&quot; more explicitly.  Since <em>this</em> actually <em>is</em> a generic problem, we can bring back our <code>Optional</code> class to handle it.  We could assume that the <code>Array</code> class bakes in the use of <code>Optional</code>, but a) the API would be somewhat inconvienient and b) it doesn&#39;t help us in the real world.  What if we created a mix-in that we could use for <code>Array</code> instances that contained optional values?</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">OptionalValuesArray</span>

  <span class="c1"># Set a value directly</span>
  <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
    <span class="k">super</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="no">Optional</span><span class="o">.</span><span class="n">some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># clear the value at this index</span>
  <span class="k">def</span> <span class="nf">clear_value</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="k">super</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="no">Optional</span><span class="o">.</span><span class="n">none</span>
  <span class="k">end</span>

  <span class="c1"># get the value or, if it&#39;s not there, call the block</span>
  <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">super</span><span class="o">[</span><span class="n">index</span><span class="o">].</span><span class="n">with_value</span><span class="p">(</span>
      <span class="o">-&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span> <span class="p">},</span>
      <span class="o">-&gt;</span><span class="p">()</span>      <span class="p">{</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># iterate over only the values that exist</span>
  <span class="k">def</span> <span class="nf">each_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">super</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span>
      <span class="n">optional</span><span class="o">.</span><span class="n">with_value</span><span class="p">(</span>
        <span class="o">-&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">},</span>
        <span class="o">-&gt;</span><span class="p">()</span>      <span class="p">{</span> <span class="p">}</span>
      <span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Map only the values that exist</span>
  <span class="k">def</span> <span class="nf">map_values</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="o">[].</span><span class="n">tap</span> <span class="p">{</span> <span class="o">|</span><span class="n">new_array</span><span class="o">|</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">each_value</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span> 
        <span class="n">new_array</span> <span class="o">&lt;&lt;</span> <span class="n">value</span>
      <span class="k">end</span>
    <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">optional_values_allowed</span> <span class="o">=</span> <span class="o">[].</span><span class="n">extend</span><span class="p">(</span><span class="no">OptionalValuesArray</span><span class="p">)</span>
<span class="n">no_optional_values</span> <span class="o">=</span> <span class="o">[]</span>
</code></pre></div>
<p>This API might not be &quot;right&quot;, but we can see that, without <code>nil</code>, we have to be explicit about which arrays can be missing
values and which cannot.  That makes our code more intention-revealing.  If Ruby really didn&#39;t have <code>nil</code>, I would expect the
Array class to better &quot;bake-in&quot; this concept so that the API was clean and easy.</p>

<p><code>Hash</code>, on the other hand, comes built-in with everything we need to avoid <code>nil</code>, namely the <code>fetch</code> method:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:foo</span> <span class="o">=&gt;</span> <span class="ss">:bar</span><span class="p">,</span> <span class="ss">:baz</span> <span class="o">=&gt;</span> <span class="ss">:quux</span> <span class="p">}</span>
<span class="nb">hash</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span>                   <span class="c1"># =&gt; :bar</span>
<span class="nb">hash</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:blah</span><span class="p">)</span>                  <span class="c1"># =&gt; raises IndexError</span>
<span class="nb">hash</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:blah</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span> <span class="s2">&quot;crud&quot;</span> <span class="p">}</span> <span class="c1"># =&gt; &quot;crud&quot;</span>
</code></pre></div>
<p>By using <code>fetch</code>, we can be very clear about what we want to do.  Without a block, we are getting the value for a key that must exist.  <em>With</em> a block we indicate that we&#39;re getting a value for a key that is optional...and we must specify the value to use if it&#39;s missing.</p>

<p>An alternative is to specify a block that provides default values, and then use <code>[]</code>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">hash</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="o">|</span> <span class="ss">:default_value</span> <span class="p">}</span>
<span class="nb">hash</span><span class="o">[</span><span class="ss">:foo</span><span class="o">]</span> <span class="o">=</span> <span class="ss">:bar</span>
<span class="nb">hash</span><span class="o">[</span><span class="ss">:foo</span><span class="o">]</span>  <span class="c1"># =&gt; :bar</span>
<span class="nb">hash</span><span class="o">[</span><span class="ss">:blah</span><span class="o">]</span> <span class="c1"># =&gt; :default_value</span>
</code></pre></div>
<p>Another way in which we use <code>nil</code> in a <code>Hash</code> is in the &quot;options hash&quot; pattern where we can parameterize a method call, typically
omitting keys where we want to use the default value provided by the API.  In this case, we use <code>nil</code> to mean &quot;don&#39;t use the
default, but omit the value entirely&quot;.  </p>

<p>For example, in Rails 3, we can use <code>respond_with</code> to send an object to the caller in the
controller.  By default, the HTTP location header is set by examining the type of the object and getting a URL for it.
<code>respond_with</code> takes an options hash and, if we wish to avoid setting this header, we must set <code>:location</code> to <code>nil</code>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">SomeController</span>
  <span class="n">respond_to</span> <span class="ss">:json</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">create_record_somehow</span>
    <span class="n">respond_with</span> <span class="n">record</span><span class="p">,</span> <span class="ss">:location</span> <span class="o">=&gt;</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Doing this without <code>nil</code> is trickier, and I think it requires a small change in how we design APIs using the options hash.
The result, again, will be more intention-revelaing code.  Instead of using <code>nil</code> for &quot;don&#39;t set the location header&quot;, we would
set an option that indicates that more clearly:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">SomeController</span>
  <span class="n">respond_to</span> <span class="ss">:json</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">create_record_somehow</span>
    <span class="n">respond_with</span> <span class="n">record</span><span class="p">,</span> <span class="ss">:set_location</span> <span class="o">=&gt;</span> <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>This would even improve the implementation of <code>respond_with</code> as well:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">respond_with</span><span class="p">(</span><span class="n">record</span><span class="p">,</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">options</span><span class="o">[</span><span class="ss">:location</span><span class="o">]</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="ss">:location</span><span class="p">)</span> <span class="p">{</span> <span class="n">default_location_for</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">if</span> <span class="n">options</span><span class="o">[</span><span class="ss">:set_location</span><span class="o">]</span>
    <span class="n">headers</span><span class="o">[</span><span class="s1">&#39;Location&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="n">options</span><span class="o">[</span><span class="ss">:location</span><span class="o">]</span>
  <span class="k">end</span>

  <span class="c1"># and whatever else</span>
<span class="k">end</span>
</code></pre></div>
<p>Again, the absence of <code>nil</code> is making our code a <em>bit</em> longer, but much more intention-revealing and explicit.</p>

<p>In reality, though, <code>nil</code> exists and is used in many places.  Can we take anything from this to the real world?</p>

<h2>Back to reality</h2>

<p>First and foremost, I would suggest that you design APIs in a way that <code>nil</code> is not required nor used.  Methods that return
collections should return an empty version instead of <code>nil</code>.  Method parameters should not allow <code>nil</code> to be passed in for any
value, and should use an options has for optional values.</p>

<p>Not every API is written this way, and to deal with them, there are a few handy methods provided by Ruby that can help:</p>

<ul>
<li><code>String()</code> - converts <code>nil</code> to the empty string, and converts any string to itself.  Wrap a possibly-<code>nil</code> string in this and you avoid a <code>nil</code> check. (ActiveSupport&#39;s <code>#present?</code> is a way to do this, too, but <code>String()</code> works everywhere in Ruby)</li>
<li><code>Array()</code> - converts <code>nil</code> to an empty array and converts an array to itself.  Perfect for dealing with pesky APIs that insist on returning <code>nil</code> instead of an empty array.</li>
<li><code>Hash[Array()]</code> - by combining <code>Hash#[]</code> and <code>Array()</code>, we can convert nil to an empty hash and a hash to itself.  <code>Array()</code> will turn a <code>Hash</code> into a two-dimensional array, and <code>Hash#[]</code> will turn a two-dimensional array back into a <code>Hash</code>.  Since <code>Array()</code> turns <code>nil</code> into an empty array, <code>Hash[Array(nil)]</code> returns an empty has.  Ruby really should include a method named <code>Hash()</code> that does this, but it doesn&#39;t.</li>
</ul>

<p>Beyond this, <a href="http://en.wikipedia.org/wiki/Null_Object_pattern">null objects</a> are a useful pattern for encapsulating logic of the type &quot;do this if some value is nil&quot;, and the <a href="http://api.rubyonrails.org/classes/Object.html#method-i-try"><code>try</code></a>
method in Rails is also very useful.</p>

<p>It&#39;s still interesting to think about a world without <code>nil</code>. Without it, we can still handle the absence of values in objects, as well as containers, and our code is more intentional-revelaing.  Why <em>do</em> we need <code>nil</code>?</p>

<hr>

<footer class='footnotes'>
<ol>
<li>
<a name='1'></a>
<sup>1</sup>The JVM still allows <code>null</code> and so does Scala, so <code>Option</code> only provides a way to express optional types more clearly; <code>null</code> is still there and is the default value of variables that aren't given an initial value.<a href='#back-1'>↩</a>
</li>
<li>
<a name='2'></a>
<sup>2</sup>It's worth pointing out that in Scala, <code>Option</code> is a lot more useful, because <code>null</code> has no such magical properties on the JVM like it does in Ruby.<a href='#back-2'>↩</a>
</li>
<li>
<a name='3'></a>
<sup>3</sup>I realize that Active Record encapsulates this concept in <code>new_record?</code>, but a) we're in an imaginary domain without Active Record and b) that Active Record encapsulates the <code>nil</code> check gives more credence that doing so is a good idea in general.<a href='#back-3'>↩</a>
</li>
</ol></footer>

  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2015, by David Bryant Copeland, All Rights Reserved
  </footer>
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body></html>
