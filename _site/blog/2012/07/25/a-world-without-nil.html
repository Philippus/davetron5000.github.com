
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>A world without nil - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  

  
  <meta name="description" content="

  
    A world without nil
    
      July 25, 2012
    
  
  
    Previously, we saw how just using functions in Ruby, we could create a lot of ...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2012/07/25/a-world-without-nil.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>A world without nil</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      July 25, 2012
    </h2>
  </header>
  <section class="blog-content">
    <p><a href="http://www.naildrivin5.com/blog/2012/07/17/adventures-in-functional-programming-with-ruby.html">Previously</a>, we saw how just using functions in Ruby, we could create a lot of powerful code.  Let’s continue the theme of “programming with constraints” and try to solve an actual problem. <code class="highlighter-rouge">nil</code>.</p>

<!-- more -->

<h2 id="is-nil-a-problem">Is <code class="highlighter-rouge">nil</code> a problem?</h2>

<p><code class="highlighter-rouge">nil</code> creates problems in code clarity and revealing programmer intent.  <code class="highlighter-rouge">nil</code> means
“no value” sometimes, but other times it means <code class="highlighter-rouge">false</code>.  Other times it means “the developer didn’t think of the proper default
for a value”.  Rails migrations, by default, allow database columns to be nullable.  This is often not correct, and by making it
the default, you cannot tell the difference between “the business requires that this field be nullable” and “the developer forgot
to consider the nullability of this column”.</p>

<p>The problems manifest when you see a test failure or production error where something is <code class="highlighter-rouge">nil</code> that you weren’t expecting.  Now
you have to figure out if that value could be <code class="highlighter-rouge">nil</code> (and the original developer missed the edge case) or if it should <em>never</em> be
<code class="highlighter-rouge">nil</code>, and you have a more serious problem in either your data, business logic, or worse.</p>

<p>The reason this becomes complex isn’t necessarily the concept of “no such value” (though this <em>is</em> a bit of a problem), but the way in which <code class="highlighter-rouge">nil</code> is treated by the language.  In Ruby, <code class="highlighter-rouge">nil</code> is the only instance of <code class="highlighter-rouge">NilClass</code> and has the following magical properties that cannot be bestowed on any other object:</p>

<ul>
  <li>it is “falsey” (a trait shared with only one other value, <code class="highlighter-rouge">false</code>, the sole value of <code class="highlighter-rouge">FalseClass</code>)</li>
  <li>it is the default value of every variable</li>
</ul>

<p>Because of these two things, we use it all over the place to represent “no value”, and our code is littered with:</p>

<ul>
  <li><code class="highlighter-rouge">do_something if value.nil?</code></li>
  <li><code class="highlighter-rouge">foo ||= {}</code></li>
  <li><code class="highlighter-rouge">Array(some_list).each</code></li>
</ul>

<p>And so forth.  Avdi Grimm gave <a href="http://confreaks.com/videos/763-rubymidwest2011-confident-code">a talk at Ruby Midwest</a> called “Confident Ruby” that deals, in part, with nil and how to avoid it.  Things like <code class="highlighter-rouge">Array()</code>, <code class="highlighter-rouge">String()</code>, and null objects are good techniques.</p>

<p>But let’s take a different approach.  What if there were no such thing as <code class="highlighter-rouge">nil</code>, and the language didn’t support it?</p>

<h2 id="can-you-imagine-a-world-without-nil">Can you imagine? A world without <code class="highlighter-rouge">nil</code>?</h2>

<p><img src="http://25.media.tumblr.com/tumblr_ltbtgjU70B1qztjn5o1_500.jpg" alt="275" /></p>

<p>Suppose there were no such thing as <code class="highlighter-rouge">nil</code> in Ruby.  Every variable would require that a value be assigned to it at declare time, and the runtime would raise an exception if you tried to use a variable/parameter/etc. without a value.</p>

<p>How would that change the way we code?</p>

<p>Of course, we could re-invent it:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">NilClass</span>
  <span class="vc">@@nil</span> <span class="o">=</span> <span class="no">NilClass</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span>
    <span class="vc">@@nil</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">nil?</span>
    <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">BasicObject</span>
  <span class="k">def</span> <span class="nf">nil?</span>
    <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="vg">$nil</span> <span class="o">=</span> <span class="no">NilClass</span><span class="p">.</span><span class="nf">new</span>
</code></pre>
</div>

<p>This gives us a value that means “no value”, but without the magic provided by the language, what good is it?</p>

<p>Let’s return to our domain from the previous post, where we want to make a system that manages users in a database.  Since we now have our fully armed and operational object-oriented programming language, we might be inclined to make a <code class="highlighter-rouge">Person</code> class:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">attr_reader</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:birthdate</span><span class="p">,</span> <span class="ss">:gender</span><span class="p">,</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">:id</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span><span class="n">birthdate</span><span class="p">,</span><span class="n">gender</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="nb">id</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="vi">@birthdate</span> <span class="o">=</span> <span class="n">birthdate</span>
    <span class="vi">@gender</span> <span class="o">=</span> <span class="n">gender</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="n">title</span>
    <span class="vi">@id</span> <span class="o">=</span> <span class="nb">id</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Remember, we don’t have <code class="highlighter-rouge">nil</code>, so we don’t have a default value for any variable - we must assign one explicitly or we’ll get runtime errors.  Given the code above, this shouldn’t be a problem, since we assign values to our ivars when they are declared.</p>

<p>If you recall, however, we have two optional values in our <code class="highlighter-rouge">Person</code>: <code class="highlighter-rouge">title</code>, and <code class="highlighter-rouge">id</code>. <code class="highlighter-rouge">title</code> is simply optional - a person might not have a title - while <code class="highlighter-rouge">id</code> will only be populated if the person has been stored in the database.  How can we model this?</p>

<h2 id="generic-optional-values">Generic optional values?</h2>

<p>Scala (a statically-typed functional/OO language that runs on the JVM), “solves” this by creating an <code class="highlighter-rouge">Option</code> type that makes explicit the concept of an optional value<a name="back-1"></a><sup><a href="#1">1</a></sup>.  In Ruby, it would look like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1"># The base class that also serves as a factory for instances</span>
<span class="k">class</span> <span class="nc">Optional</span>
  <span class="c1"># Optional value that has a value</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="no">Some</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Optional value with NO value</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">none</span>
    <span class="no">None</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Some</span> <span class="o">&lt;</span> <span class="no">Optional</span>
  <span class="kp">attr_reader</span> <span class="ss">:value</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">exists?</span>
    <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">None</span> <span class="o">&lt;</span> <span class="no">Optional</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">exists?</span>
    <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We can use it like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">dave</span> <span class="o">=</span> <span class="no">Person</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Dave"</span><span class="p">,</span><span class="s2">"1972-01-01"</span><span class="p">,</span><span class="ss">:male</span><span class="p">,</span><span class="no">Optional</span><span class="p">.</span><span class="nf">none</span><span class="p">,</span><span class="no">Optional</span><span class="p">.</span><span class="nf">none</span><span class="p">)</span>
<span class="n">rudy</span> <span class="o">=</span> <span class="no">Person</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Rudy"</span><span class="p">,</span><span class="s2">"2001-01-01"</span><span class="p">,</span><span class="ss">:male</span><span class="p">,</span><span class="no">Optional</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="s2">"cat"</span><span class="p">),</span><span class="no">Optional</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="k">if</span> <span class="n">title</span><span class="p">.</span><span class="nf">exists?</span>
      <span class="n">title</span><span class="p">.</span><span class="nf">value</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="nb">name</span>
    <span class="k">else</span>
      <span class="nb">name</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>So, we’ve replaced what would be a call to <code class="highlighter-rouge">.nil?</code> in regular Ruby with a call to <code class="highlighter-rouge">.exists?</code> in our nil-less Ruby.  Is this really any better?  We could wrap the logic of “do one thing if there’s a value, do another if there isn’t” into a method on <code class="highlighter-rouge">Optional</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Some</span>
  <span class="k">def</span> <span class="nf">with_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span><span class="o">&amp;</span><span class="n">_</span><span class="p">)</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nf">value</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">None</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">with_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_</span><span class="p">,</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">block</span><span class="p">.</span><span class="nf">call</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We could then implement <code class="highlighter-rouge">salutation</code> like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">title</span><span class="p">.</span><span class="nf">with_value</span><span class="p">(</span>
      <span class="o">-&gt;</span><span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="p">{</span> <span class="n">title</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="nb">name</span> <span class="p">},</span>
      <span class="o">-&gt;</span>        <span class="p">{</span> <span class="nb">name</span> <span class="p">}</span>
    <span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Yech.  We might be able to play some syntax games and clean this up, but this is <em>not</em> an improvement.  <code class="highlighter-rouge">if/else</code> statements are
easy to understand and with the magic of <code class="highlighter-rouge">nil</code>, the logic is pretty straightforward:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">title</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">title</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="nb">self</span><span class="p">.</span><span class="nf">name</span>
    <span class="k">else</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">title</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Optional</code>, as we’ve defined it, is just a degenerate implementation of <code class="highlighter-rouge">nil</code> that has a terrible API<a name="back-2"></a><sup><a href="#2">2</a></sup>.  It <em>does</em> have the advantage of not being magic - we are required to provide a value for every variable, which is nice - but can we do better?</p>

<h2 id="solving-the-problem-in-front-of-us">Solving the problem in front of us</h2>

<p>Let’s step back and just try solving the problem in front of us, instead of adding the general concept of optional values.  What if we used the type system more explicitly?</p>

<p>Suppose we define <code class="highlighter-rouge">Person</code> to be only the <em>required</em> values, i.e. the bare essence of a person in our system, and then create
mixins for the optional values.  We could make a mixin like <code class="highlighter-rouge">Stored</code> act as both a “tag” for an object that is stored in the
database, and as the location for related code.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="c1"># Every person must have a name, birthdate, and gender.</span>
  <span class="kp">attr_reader</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:birthdate</span><span class="p">,</span> <span class="ss">:gender</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span><span class="n">birthdate</span><span class="p">,</span><span class="n">gender</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="vi">@birthdate</span> <span class="o">=</span> <span class="n">birthdate</span>
    <span class="vi">@gender</span> <span class="o">=</span> <span class="n">gender</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Stored</span>
  <span class="kp">attr_reader</span> <span class="ss">:id</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Titled</span>
  <span class="kp">attr_reader</span> <span class="ss">:title</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Note that we don’t make <code class="highlighter-rouge">id</code> or <code class="highlighter-rouge">title</code> mutable; they are still read-only fields.  So, how do they get set?  We tightly couple
<code class="highlighter-rouge">Person</code> with these new modules and set the fields there.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">title</span><span class="o">=</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="n">title</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="no">Titled</span><span class="p">)</span> <span class="c1"># THIS object is now a Titled, but other Person instances are not</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">id</span><span class="o">=</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="vi">@id</span> <span class="o">=</span> <span class="nb">id</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="no">Stored</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Note that if we wanted to maintain total immutability, we would need to jump through a few hoops:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">with_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">dup</span><span class="p">.</span><span class="nf">tap</span> <span class="p">{</span> <span class="o">|</span><span class="n">person</span><span class="o">|</span>
      <span class="n">person</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="no">Titled</span><span class="p">)</span>
      <span class="n">person</span><span class="p">.</span><span class="nf">instance_variable_set</span><span class="p">(</span><span class="s2">"@title"</span><span class="p">,</span><span class="n">title</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">end</span>
</code></pre>
</div>

<p>In either case, we end up with an instance that has mixed in <code class="highlighter-rouge">Titled</code> and absolutey has a value for <code class="highlighter-rouge">title</code>.</p>

<p>How would this affect our <code class="highlighter-rouge">salutation</code> method?</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">kind_of?</span><span class="p">(</span><span class="no">Titled</span><span class="p">)</span>
      <span class="s2">"</span><span class="si">#{</span><span class="n">title</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">else</span>
      <span class="nb">name</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We’ve replaced a generic check - for <code class="highlighter-rouge">nil</code> - with a specific check - for being <code class="highlighter-rouge">Titled</code>.  This may not seem like an improvement, but I’d argue that it makes our domain a bit richer and more intention-revelaing.  It turns an implementation decsion (treating <code class="highlighter-rouge">nil</code> as not having a title) into something explicit. And, at the end of the day, if we need logic based on the existence of a value, well, we’re going to need to use <code class="highlighter-rouge">if</code> statements.</p>

<p>Or are we?</p>

<p>Before we answer that, it’s worth noting that although <code class="highlighter-rouge">Titled</code> is specific to our <code class="highlighter-rouge">Person</code> class, <code class="highlighter-rouge">Stored</code> is a more generic concept that could be broadly used to explicitly call out records not stored in the database.  Imagine an <code class="highlighter-rouge">update</code> method like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">NotStoredError</span> <span class="k">unless</span> <span class="n">record</span><span class="p">.</span><span class="nf">kind_of?</span><span class="p">(</span><span class="no">Stored</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>That reads a lot better to me than a <code class="highlighter-rouge">nil</code> check<a name="back-3"></a><sup><a href="#3">3</a></sup>.  It also abstracts away the way in which we know that a record is stored, but without requiring a common superclass.</p>

<p>Back to our <code class="highlighter-rouge">if</code> statement.  We have a business rule based on the existence of a value, so it seems we just have to live with the conditional logic, right?  Not exactly.  What if both <code class="highlighter-rouge">Person</code> and <code class="highlighter-rouge">Titled</code> implemented <code class="highlighter-rouge">salutation</code>?</p>

<p>Person would use the “default if no title” version, because a raw <code class="highlighter-rouge">Person</code> has no title:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="nb">name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Once <code class="highlighter-rouge">Titled</code> is mixed in, we know that we absolutely have a title, so we override it with the correct logic given a title:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Titled</span>
  <span class="k">def</span> <span class="nf">salutation</span>
    <span class="n">title</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="k">super</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Now, <em>this</em> is interesting.  We’re using polymorphism and inheritance as a way to avoid <code class="highlighter-rouge">if</code> statements.  If we’d used <code class="highlighter-rouge">nil</code> to
represent “no title”, we’d be stuck with conditional logic.  The added constraint of programming without <code class="highlighter-rouge">nil</code> has forced us to
get creative and resulted in a cleaner solution.</p>

<p>We’ve now used the type system to create an explicit description of our domain, and we didn’t need <code class="highlighter-rouge">nil</code>.  Of course, a type that has a lot of optional values will require a lot of these sorts of modules, and it could get ugly.  This might be a good thing.</p>

<p>Now that we can handle optional values in our data structures, what about containers?</p>

<h2 id="optional-values-in-container-classes">Optional values in container classes</h2>

<p>I see a lot of code using <code class="highlighter-rouge">first</code> or <code class="highlighter-rouge">last</code> on an array as a shortcut for checking if the array is empty and, if not, getting the first or last element respectively.  Obviously, this would have to stop, but what about so-called “sparse arrays” where some indeces contain <code class="highlighter-rouge">nil</code> values?  Dealing with this cleanly is not simple given the currently API of <code class="highlighter-rouge">Array</code>.  Of course, if the language never had <code class="highlighter-rouge">nil</code>, you could imagine that <code class="highlighter-rouge">Array</code> would have <em>some</em> facility for dealing with this.  On idea would be that each accessor method would accept an optional block that would be run if there were no value, so that the caller could provide a default:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                               <span class="c1"># =&gt; raises IndexError</span>
<span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span> <span class="o">|</span><span class="n">index</span><span class="o">|</span> <span class="s2">"default</span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span> <span class="c1"># =&gt; default0</span>
<span class="n">list</span><span class="p">.</span><span class="nf">first</span> <span class="p">{</span> <span class="s2">"default"</span> <span class="p">}</span>              <span class="c1"># =&gt; default</span>
</code></pre>
</div>

<p>When we’re talking about containers, however, we’d need to be able to model “there is no value at this location” more explicitly.  Since <em>this</em> actually <em>is</em> a generic problem, we can bring back our <code class="highlighter-rouge">Optional</code> class to handle it.  We could assume that the <code class="highlighter-rouge">Array</code> class bakes in the use of <code class="highlighter-rouge">Optional</code>, but a) the API would be somewhat inconvienient and b) it doesn’t help us in the real world.  What if we created a mix-in that we could use for <code class="highlighter-rouge">Array</code> instances that contained optional values?</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">module</span> <span class="nn">OptionalValuesArray</span>

  <span class="c1"># Set a value directly</span>
  <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
    <span class="k">super</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="no">Optional</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># clear the value at this index</span>
  <span class="k">def</span> <span class="nf">clear_value</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="k">super</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="no">Optional</span><span class="p">.</span><span class="nf">none</span>
  <span class="k">end</span>

  <span class="c1"># get the value or, if it's not there, call the block</span>
  <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">super</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="nf">with_value</span><span class="p">(</span>
      <span class="o">-&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span> <span class="p">},</span>
      <span class="o">-&gt;</span><span class="p">()</span>      <span class="p">{</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># iterate over only the values that exist</span>
  <span class="k">def</span> <span class="nf">each_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">super</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span>
      <span class="n">optional</span><span class="p">.</span><span class="nf">with_value</span><span class="p">(</span>
        <span class="o">-&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">},</span>
        <span class="o">-&gt;</span><span class="p">()</span>      <span class="p">{</span> <span class="p">}</span>
      <span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Map only the values that exist</span>
  <span class="k">def</span> <span class="nf">map_values</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="p">[].</span><span class="nf">tap</span> <span class="p">{</span> <span class="o">|</span><span class="n">new_array</span><span class="o">|</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">each_value</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span> 
        <span class="n">new_array</span> <span class="o">&lt;&lt;</span> <span class="n">value</span>
      <span class="k">end</span>
    <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">optional_values_allowed</span> <span class="o">=</span> <span class="p">[].</span><span class="nf">extend</span><span class="p">(</span><span class="no">OptionalValuesArray</span><span class="p">)</span>
<span class="n">no_optional_values</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre>
</div>

<p>This API might not be “right”, but we can see that, without <code class="highlighter-rouge">nil</code>, we have to be explicit about which arrays can be missing
values and which cannot.  That makes our code more intention-revealing.  If Ruby really didn’t have <code class="highlighter-rouge">nil</code>, I would expect the
Array class to better “bake-in” this concept so that the API was clean and easy.</p>

<p><code class="highlighter-rouge">Hash</code>, on the other hand, comes built-in with everything we need to avoid <code class="highlighter-rouge">nil</code>, namely the <code class="highlighter-rouge">fetch</code> method:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:foo</span> <span class="o">=&gt;</span> <span class="ss">:bar</span><span class="p">,</span> <span class="ss">:baz</span> <span class="o">=&gt;</span> <span class="ss">:quux</span> <span class="p">}</span>
<span class="nb">hash</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span>                   <span class="c1"># =&gt; :bar</span>
<span class="nb">hash</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:blah</span><span class="p">)</span>                  <span class="c1"># =&gt; raises IndexError</span>
<span class="nb">hash</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:blah</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span> <span class="s2">"crud"</span> <span class="p">}</span> <span class="c1"># =&gt; "crud"</span>
</code></pre>
</div>

<p>By using <code class="highlighter-rouge">fetch</code>, we can be very clear about what we want to do.  Without a block, we are getting the value for a key that must exist.  <em>With</em> a block we indicate that we’re getting a value for a key that is optional…and we must specify the value to use if it’s missing.</p>

<p>An alternative is to specify a block that provides default values, and then use <code class="highlighter-rouge">[]</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nb">hash</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="o">|</span> <span class="ss">:default_value</span> <span class="p">}</span>
<span class="nb">hash</span><span class="p">[</span><span class="ss">:foo</span><span class="p">]</span> <span class="o">=</span> <span class="ss">:bar</span>
<span class="nb">hash</span><span class="p">[</span><span class="ss">:foo</span><span class="p">]</span>  <span class="c1"># =&gt; :bar</span>
<span class="nb">hash</span><span class="p">[</span><span class="ss">:blah</span><span class="p">]</span> <span class="c1"># =&gt; :default_value</span>
</code></pre>
</div>

<p>Another way in which we use <code class="highlighter-rouge">nil</code> in a <code class="highlighter-rouge">Hash</code> is in the “options hash” pattern where we can parameterize a method call, typically
omitting keys where we want to use the default value provided by the API.  In this case, we use <code class="highlighter-rouge">nil</code> to mean “don’t use the
default, but omit the value entirely”.</p>

<p>For example, in Rails 3, we can use <code class="highlighter-rouge">respond_with</code> to send an object to the caller in the
controller.  By default, the HTTP location header is set by examining the type of the object and getting a URL for it.
<code class="highlighter-rouge">respond_with</code> takes an options hash and, if we wish to avoid setting this header, we must set <code class="highlighter-rouge">:location</code> to <code class="highlighter-rouge">nil</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SomeController</span>
  <span class="n">respond_to</span> <span class="ss">:json</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">create_record_somehow</span>
    <span class="n">respond_with</span> <span class="n">record</span><span class="p">,</span> <span class="ss">:location</span> <span class="o">=&gt;</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Doing this without <code class="highlighter-rouge">nil</code> is trickier, and I think it requires a small change in how we design APIs using the options hash.
The result, again, will be more intention-revelaing code.  Instead of using <code class="highlighter-rouge">nil</code> for “don’t set the location header”, we would
set an option that indicates that more clearly:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SomeController</span>
  <span class="n">respond_to</span> <span class="ss">:json</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">create_record_somehow</span>
    <span class="n">respond_with</span> <span class="n">record</span><span class="p">,</span> <span class="ss">:set_location</span> <span class="o">=&gt;</span> <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This would even improve the implementation of <code class="highlighter-rouge">respond_with</code> as well:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">respond_with</span><span class="p">(</span><span class="n">record</span><span class="p">,</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:location</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:location</span><span class="p">)</span> <span class="p">{</span> <span class="n">default_location_for</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:set_location</span><span class="p">]</span>
    <span class="n">headers</span><span class="p">[</span><span class="s1">'Location'</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:location</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="c1"># and whatever else</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Again, the absence of <code class="highlighter-rouge">nil</code> is making our code a <em>bit</em> longer, but much more intention-revealing and explicit.</p>

<p>In reality, though, <code class="highlighter-rouge">nil</code> exists and is used in many places.  Can we take anything from this to the real world?</p>

<h2 id="back-to-reality">Back to reality</h2>

<p>First and foremost, I would suggest that you design APIs in a way that <code class="highlighter-rouge">nil</code> is not required nor used.  Methods that return
collections should return an empty version instead of <code class="highlighter-rouge">nil</code>.  Method parameters should not allow <code class="highlighter-rouge">nil</code> to be passed in for any
value, and should use an options has for optional values.</p>

<p>Not every API is written this way, and to deal with them, there are a few handy methods provided by Ruby that can help:</p>

<ul>
  <li><code class="highlighter-rouge">String()</code> - converts <code class="highlighter-rouge">nil</code> to the empty string, and converts any string to itself.  Wrap a possibly-<code class="highlighter-rouge">nil</code> string in this and you avoid a <code class="highlighter-rouge">nil</code> check. (ActiveSupport’s <code class="highlighter-rouge">#present?</code> is a way to do this, too, but <code class="highlighter-rouge">String()</code> works everywhere in Ruby)</li>
  <li><code class="highlighter-rouge">Array()</code> - converts <code class="highlighter-rouge">nil</code> to an empty array and converts an array to itself.  Perfect for dealing with pesky APIs that insist on returning <code class="highlighter-rouge">nil</code> instead of an empty array.</li>
  <li><code class="highlighter-rouge">Hash[Array()]</code> - by combining <code class="highlighter-rouge">Hash#[]</code> and <code class="highlighter-rouge">Array()</code>, we can convert nil to an empty hash and a hash to itself.  <code class="highlighter-rouge">Array()</code> will turn a <code class="highlighter-rouge">Hash</code> into a two-dimensional array, and <code class="highlighter-rouge">Hash#[]</code> will turn a two-dimensional array back into a <code class="highlighter-rouge">Hash</code>.  Since <code class="highlighter-rouge">Array()</code> turns <code class="highlighter-rouge">nil</code> into an empty array, <code class="highlighter-rouge">Hash[Array(nil)]</code> returns an empty has.  Ruby really should include a method named <code class="highlighter-rouge">Hash()</code> that does this, but it doesn’t.</li>
</ul>

<p>Beyond this, <a href="http://en.wikipedia.org/wiki/Null_Object_pattern">null objects</a> are a useful pattern for encapsulating logic of the type “do this if some value is nil”, and the <a href="http://api.rubyonrails.org/classes/Object.html#method-i-try"><code class="highlighter-rouge">try</code></a>
method in Rails is also very useful.</p>

<p>It’s still interesting to think about a world without <code class="highlighter-rouge">nil</code>. Without it, we can still handle the absence of values in objects, as well as containers, and our code is more intentional-revelaing.  Why <em>do</em> we need <code class="highlighter-rouge">nil</code>?</p>

<hr />

<footer class="footnotes">
<ol>
<li>
<a name="1"></a>
<sup>1</sup>The JVM still allows <code>null</code> and so does Scala, so <code>Option</code> only provides a way to express optional types more clearly; <code>null</code> is still there and is the default value of variables that aren't given an initial value.<a href="#back-1">↩</a>
</li>
<li>
<a name="2"></a>
<sup>2</sup>It's worth pointing out that in Scala, <code>Option</code> is a lot more useful, because <code>null</code> has no such magical properties on the JVM like it does in Ruby.<a href="#back-2">↩</a>
</li>
<li>
<a name="3"></a>
<sup>3</sup>I realize that Active Record encapsulates this concept in <code>new_record?</code>, but a) we're in an imaginary domain without Active Record and b) that Active Record encapsulates the <code>nil</code> check gives more credence that doing so is a good idea in general.<a href="#back-3">↩</a>
</li>
</ol></footer>


  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2016, by David Bryant Copeland, All Rights Reserved
    </p>
  </footer>
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '56a22cd9c88d90284f000861');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>
</body></html>
