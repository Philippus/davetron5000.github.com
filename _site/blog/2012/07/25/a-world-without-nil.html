
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>A world without nil - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  

  
  <meta name="description" content="

  
    A world without nil
    
      July 25, 2012
    
  
  
    Previously, we saw how just using functions in Ruby, we could create a lot of ...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2012/07/25/a-world-without-nil.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>A world without nil</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      July 25, 2012
    </h2>
  </header>
  <section class="blog-content">
    <p><a href="http://www.naildrivin5.com/blog/2012/07/17/adventures-in-functional-programming-with-ruby.html">Previously</a>, we saw how just using functions in Ruby, we could create a lot of powerful code.  Let’s continue the theme of “programming with constraints” and try to solve an actual problem. <code class="highlighter-rouge">nil</code>.</p>

<!-- more -->

<h2 id="is-nil-a-problem">Is <code class="highlighter-rouge">nil</code> a problem?</h2>

<p><code class="highlighter-rouge">nil</code> creates problems in code clarity and revealing programmer intent.  <code class="highlighter-rouge">nil</code> means
“no value” sometimes, but other times it means <code class="highlighter-rouge">false</code>.  Other times it means “the developer didn’t think of the proper default
for a value”.  Rails migrations, by default, allow database columns to be nullable.  This is often not correct, and by making it
the default, you cannot tell the difference between “the business requires that this field be nullable” and “the developer forgot
to consider the nullability of this column”.</p>

<p>The problems manifest when you see a test failure or production error where something is <code class="highlighter-rouge">nil</code> that you weren’t expecting.  Now
you have to figure out if that value could be <code class="highlighter-rouge">nil</code> (and the original developer missed the edge case) or if it should <em>never</em> be
<code class="highlighter-rouge">nil</code>, and you have a more serious problem in either your data, business logic, or worse.</p>

<p>The reason this becomes complex isn’t necessarily the concept of “no such value” (though this <em>is</em> a bit of a problem), but the way in which <code class="highlighter-rouge">nil</code> is treated by the language.  In Ruby, <code class="highlighter-rouge">nil</code> is the only instance of <code class="highlighter-rouge">NilClass</code> and has the following magical properties that cannot be bestowed on any other object:</p>

<ul>
  <li>it is “falsey” (a trait shared with only one other value, <code class="highlighter-rouge">false</code>, the sole value of <code class="highlighter-rouge">FalseClass</code>)</li>
  <li>it is the default value of every variable</li>
</ul>

<p>Because of these two things, we use it all over the place to represent “no value”, and our code is littered with:</p>

<ul>
  <li><code class="highlighter-rouge">do_something if value.nil?</code></li>
  <li><code class="highlighter-rouge">foo ||= {}</code></li>
  <li><code class="highlighter-rouge">Array(some_list).each</code></li>
</ul>

<p>And so forth.  Avdi Grimm gave <a href="http://confreaks.com/videos/763-rubymidwest2011-confident-code">a talk at Ruby Midwest</a> called “Confident Ruby” that deals, in part, with nil and how to avoid it.  Things like <code class="highlighter-rouge">Array()</code>, <code class="highlighter-rouge">String()</code>, and null objects are good techniques.</p>

<p>But let’s take a different approach.  What if there were no such thing as <code class="highlighter-rouge">nil</code>, and the language didn’t support it?</p>

<h2 id="can-you-imagine-a-world-without-nil">Can you imagine? A world without <code class="highlighter-rouge">nil</code>?</h2>

<p><img src="http://25.media.tumblr.com/tumblr_ltbtgjU70B1qztjn5o1_500.jpg" alt="275" /></p>

<p>Suppose there were no such thing as <code class="highlighter-rouge">nil</code> in Ruby.  Every variable would require that a value be assigned to it at declare time, and the runtime would raise an exception if you tried to use a variable/parameter/etc. without a value.</p>

<p>How would that change the way we code?</p>

<p>Of course, we could re-invent it:</p>

<p>```ruby
class NilClass
  @@nil = NilClass.new
  def self.new
    @@nil
  end</p>

<p>def nil?
    true
  end
end</p>

<p>class BasicObject
  def nil?
    false
  end
end</p>

<p>$nil = NilClass.new
```</p>

<p>This gives us a value that means “no value”, but without the magic provided by the language, what good is it?</p>

<p>Let’s return to our domain from the previous post, where we want to make a system that manages users in a database.  Since we now have our fully armed and operational object-oriented programming language, we might be inclined to make a <code class="highlighter-rouge">Person</code> class:</p>

<p><code class="highlighter-rouge">ruby
class Person
  attr_reader :name, :birthdate, :gender, :title, :id
  def initialize(name,birthdate,gender,title,id)
    @name = name
    @birthdate = birthdate
    @gender = gender
    @title = title
    @id = id
  end
end
</code></p>

<p>Remember, we don’t have <code class="highlighter-rouge">nil</code>, so we don’t have a default value for any variable - we must assign one explicitly or we’ll get runtime errors.  Given the code above, this shouldn’t be a problem, since we assign values to our ivars when they are declared.</p>

<p>If you recall, however, we have two optional values in our <code class="highlighter-rouge">Person</code>: <code class="highlighter-rouge">title</code>, and <code class="highlighter-rouge">id</code>. <code class="highlighter-rouge">title</code> is simply optional - a person might not have a title - while <code class="highlighter-rouge">id</code> will only be populated if the person has been stored in the database.  How can we model this?</p>

<h2 id="generic-optional-values">Generic optional values?</h2>

<p>Scala (a statically-typed functional/OO language that runs on the JVM), “solves” this by creating an <code class="highlighter-rouge">Option</code> type that makes explicit the concept of an optional value<a name="back-1"></a><sup><a href="#1">1</a></sup>.  In Ruby, it would look like this:</p>

<p>```ruby
# The base class that also serves as a factory for instances
class Optional
  # Optional value that has a value
  def self.some(value)
    Some.new(value)
  end</p>

<p># Optional value with NO value
  def self.none
    None
  end
end</p>

<p>class Some &lt; Optional
  attr_reader :value
  def initialize(value)
    @value = value
  end</p>

<p>def exists?
    true
  end
end</p>

<p>class None &lt; Optional
  def self.exists?
    false
  end
end
```</p>

<p>We can use it like so:</p>

<p>```ruby
dave = Person.new(“Dave”,”1972-01-01”,:male,Optional.none,Optional.none)
rudy = Person.new(“Rudy”,”2001-01-01”,:male,Optional.some(“cat”),Optional.some(42))</p>

<p>class Person
  def salutation
    if title.exists?
      title.value + ‘ ‘ + name
    else
      name
    end
  end
end
```</p>

<p>So, we’ve replaced what would be a call to <code class="highlighter-rouge">.nil?</code> in regular Ruby with a call to <code class="highlighter-rouge">.exists?</code> in our nil-less Ruby.  Is this really any better?  We could wrap the logic of “do one thing if there’s a value, do another if there isn’t” into a method on <code class="highlighter-rouge">Optional</code>:</p>

<p>```ruby
class Some
  def with_value(&amp;block,&amp;_)
    block.call(self.value)
  end
end</p>

<p>class None
  def self.with_value(&amp;_,&amp;block)
    block.call
  end
end
```</p>

<p>We could then implement <code class="highlighter-rouge">salutation</code> like so:</p>

<p><code class="highlighter-rouge">ruby
class Person
  def salutation
    self.title.with_value(
      -&gt;(title) { title + ' ' + name },
      -&gt;        { name }
    )
  end
end
</code></p>

<p>Yech.  We might be able to play some syntax games and clean this up, but this is <em>not</em> an improvement.  <code class="highlighter-rouge">if/else</code> statements are
easy to understand and with the magic of <code class="highlighter-rouge">nil</code>, the logic is pretty straightforward:</p>

<p><code class="highlighter-rouge">ruby
class Person
  def salutation
    if self.title
      self.title + ' ' + self.name
    else
      self.title
    end
  end
end
</code></p>

<p><code class="highlighter-rouge">Optional</code>, as we’ve defined it, is just a degenerate implementation of <code class="highlighter-rouge">nil</code> that has a terrible API<a name="back-2"></a><sup><a href="#2">2</a></sup>.  It <em>does</em> have the advantage of not being magic - we are required to provide a value for every variable, which is nice - but can we do better?</p>

<h2 id="solving-the-problem-in-front-of-us">Solving the problem in front of us</h2>

<p>Let’s step back and just try solving the problem in front of us, instead of adding the general concept of optional values.  What if we used the type system more explicitly?</p>

<p>Suppose we define <code class="highlighter-rouge">Person</code> to be only the <em>required</em> values, i.e. the bare essence of a person in our system, and then create
mixins for the optional values.  We could make a mixin like <code class="highlighter-rouge">Stored</code> act as both a “tag” for an object that is stored in the
database, and as the location for related code.</p>

<p>```ruby
class Person
  # Every person must have a name, birthdate, and gender.
  attr_reader :name, :birthdate, :gender
  def initialize(name,birthdate,gender)
    @name = name
    @birthdate = birthdate
    @gender = gender
  end
end</p>

<p>module Stored
  attr_reader :id
end</p>

<p>module Titled
  attr_reader :title
end
```</p>

<p>Note that we don’t make <code class="highlighter-rouge">id</code> or <code class="highlighter-rouge">title</code> mutable; they are still read-only fields.  So, how do they get set?  We tightly couple
<code class="highlighter-rouge">Person</code> with these new modules and set the fields there.</p>

<p>```ruby
class Person
  def title=(title)
    @title = title
    self.extend(Titled) # THIS object is now a Titled, but other Person instances are not
  end</p>

<p>def id=(id)
    @id = id
    self.extend(Stored)
  end
end
```</p>

<p>Note that if we wanted to maintain total immutability, we would need to jump through a few hoops:</p>

<p><code class="highlighter-rouge">ruby
class Person
  def with_title(title)
    self.dup.tap { |person|
      person.extend(Titled)
      person.instance_variable_set("@title",title)
    }
  end
</code></p>

<p>In either case, we end up with an instance that has mixed in <code class="highlighter-rouge">Titled</code> and absolutey has a value for <code class="highlighter-rouge">title</code>.</p>

<p>How would this affect our <code class="highlighter-rouge">salutation</code> method?</p>

<p><code class="highlighter-rouge">ruby
class Person
  def salutation
    if self.kind_of?(Titled)
      "#{title} #{name}"
    else
      name
    end
  end
end
</code></p>

<p>We’ve replaced a generic check - for <code class="highlighter-rouge">nil</code> - with a specific check - for being <code class="highlighter-rouge">Titled</code>.  This may not seem like an improvement, but I’d argue that it makes our domain a bit richer and more intention-revelaing.  It turns an implementation decsion (treating <code class="highlighter-rouge">nil</code> as not having a title) into something explicit. And, at the end of the day, if we need logic based on the existence of a value, well, we’re going to need to use <code class="highlighter-rouge">if</code> statements.</p>

<p>Or are we?</p>

<p>Before we answer that, it’s worth noting that although <code class="highlighter-rouge">Titled</code> is specific to our <code class="highlighter-rouge">Person</code> class, <code class="highlighter-rouge">Stored</code> is a more generic concept that could be broadly used to explicitly call out records not stored in the database.  Imagine an <code class="highlighter-rouge">update</code> method like so:</p>

<p><code class="highlighter-rouge">ruby
def update(record)
  raise NotStoredError unless record.kind_of?(Stored)
end
</code></p>

<p>That reads a lot better to me than a <code class="highlighter-rouge">nil</code> check<a name="back-3"></a><sup><a href="#3">3</a></sup>.  It also abstracts away the way in which we know that a record is stored, but without requiring a common superclass.</p>

<p>Back to our <code class="highlighter-rouge">if</code> statement.  We have a business rule based on the existence of a value, so it seems we just have to live with the conditional logic, right?  Not exactly.  What if both <code class="highlighter-rouge">Person</code> and <code class="highlighter-rouge">Titled</code> implemented <code class="highlighter-rouge">salutation</code>?</p>

<p>Person would use the “default if no title” version, because a raw <code class="highlighter-rouge">Person</code> has no title:</p>

<p><code class="highlighter-rouge">ruby
class Person
  def salutation
    name
  end
end
</code></p>

<p>Once <code class="highlighter-rouge">Titled</code> is mixed in, we know that we absolutely have a title, so we override it with the correct logic given a title:</p>

<p><code class="highlighter-rouge">ruby
module Titled
  def salutation
    title + ' ' + super
  end
end
</code></p>

<p>Now, <em>this</em> is interesting.  We’re using polymorphism and inheritance as a way to avoid <code class="highlighter-rouge">if</code> statements.  If we’d used <code class="highlighter-rouge">nil</code> to
represent “no title”, we’d be stuck with conditional logic.  The added constraint of programming without <code class="highlighter-rouge">nil</code> has forced us to
get creative and resulted in a cleaner solution.</p>

<p>We’ve now used the type system to create an explicit description of our domain, and we didn’t need <code class="highlighter-rouge">nil</code>.  Of course, a type that has a lot of optional values will require a lot of these sorts of modules, and it could get ugly.  This might be a good thing.</p>

<p>Now that we can handle optional values in our data structures, what about containers?</p>

<h2 id="optional-values-in-container-classes">Optional values in container classes</h2>

<p>I see a lot of code using <code class="highlighter-rouge">first</code> or <code class="highlighter-rouge">last</code> on an array as a shortcut for checking if the array is empty and, if not, getting the first or last element respectively.  Obviously, this would have to stop, but what about so-called “sparse arrays” where some indeces contain <code class="highlighter-rouge">nil</code> values?  Dealing with this cleanly is not simple given the currently API of <code class="highlighter-rouge">Array</code>.  Of course, if the language never had <code class="highlighter-rouge">nil</code>, you could imagine that <code class="highlighter-rouge">Array</code> would have <em>some</em> facility for dealing with this.  On idea would be that each accessor method would accept an optional block that would be run if there were no value, so that the caller could provide a default:</p>

<p><code class="highlighter-rouge">ruby
list = []
list[0]                               # =&gt; raises IndexError
list[0] { |index| "default#{index}" } # =&gt; default0
list.first { "default" }              # =&gt; default
</code></p>

<p>When we’re talking about containers, however, we’d need to be able to model “there is no value at this location” more explicitly.  Since <em>this</em> actually <em>is</em> a generic problem, we can bring back our <code class="highlighter-rouge">Optional</code> class to handle it.  We could assume that the <code class="highlighter-rouge">Array</code> class bakes in the use of <code class="highlighter-rouge">Optional</code>, but a) the API would be somewhat inconvienient and b) it doesn’t help us in the real world.  What if we created a mix-in that we could use for <code class="highlighter-rouge">Array</code> instances that contained optional values?</p>

<p>```ruby
module OptionalValuesArray</p>

<p># Set a value directly
  def []=(index,value)
    super[index] = Optional.some(value)
  end</p>

<p># clear the value at this index
  def clear_value(index)
    super[index] = Optional.none
  end</p>

<p># get the value or, if it’s not there, call the block
  def [](index,&amp;block)
    super[index].with_value(
      -&gt;(value) { value },
      -&gt;()      { block.call(index) }
    )
  end</p>

<p># iterate over only the values that exist
  def each_value(&amp;block)
    super.each(optional)
      optional.with_value(
        -&gt;(value) { block.call(value) },
        -&gt;()      { }
      )
    end
  end</p>

<p># Map only the values that exist
  def map_values(&amp;block)
    [].tap { |new_array|
      self.each_value do |value| 
        new_array « value
      end
    }
  end
end</p>

<p>optional_values_allowed = [].extend(OptionalValuesArray)
no_optional_values = []
```</p>

<p>This API might not be “right”, but we can see that, without <code class="highlighter-rouge">nil</code>, we have to be explicit about which arrays can be missing
values and which cannot.  That makes our code more intention-revealing.  If Ruby really didn’t have <code class="highlighter-rouge">nil</code>, I would expect the
Array class to better “bake-in” this concept so that the API was clean and easy.</p>

<p><code class="highlighter-rouge">Hash</code>, on the other hand, comes built-in with everything we need to avoid <code class="highlighter-rouge">nil</code>, namely the <code class="highlighter-rouge">fetch</code> method:</p>

<p><code class="highlighter-rouge">ruby
hash = { :foo =&gt; :bar, :baz =&gt; :quux }
hash.fetch(:foo)                   # =&gt; :bar
hash.fetch(:blah)                  # =&gt; raises IndexError
hash.fetch(:blah) { |key| "crud" } # =&gt; "crud"
</code></p>

<p>By using <code class="highlighter-rouge">fetch</code>, we can be very clear about what we want to do.  Without a block, we are getting the value for a key that must exist.  <em>With</em> a block we indicate that we’re getting a value for a key that is optional…and we must specify the value to use if it’s missing.</p>

<p>An alternative is to specify a block that provides default values, and then use <code class="highlighter-rouge">[]</code>:</p>

<p><code class="highlighter-rouge">ruby
hash = Hash.new { |key,value| :default_value }
hash[:foo] = :bar
hash[:foo]  # =&gt; :bar
hash[:blah] # =&gt; :default_value
</code></p>

<p>Another way in which we use <code class="highlighter-rouge">nil</code> in a <code class="highlighter-rouge">Hash</code> is in the “options hash” pattern where we can parameterize a method call, typically
omitting keys where we want to use the default value provided by the API.  In this case, we use <code class="highlighter-rouge">nil</code> to mean “don’t use the
default, but omit the value entirely”.</p>

<p>For example, in Rails 3, we can use <code class="highlighter-rouge">respond_with</code> to send an object to the caller in the
controller.  By default, the HTTP location header is set by examining the type of the object and getting a URL for it.
<code class="highlighter-rouge">respond_with</code> takes an options hash and, if we wish to avoid setting this header, we must set <code class="highlighter-rouge">:location</code> to <code class="highlighter-rouge">nil</code>:</p>

<p>```ruby
class SomeController
  respond_to :json</p>

<p>def create
    record = create_record_somehow
    respond_with record, :location =&gt; nil
  end
end
```</p>

<p>Doing this without <code class="highlighter-rouge">nil</code> is trickier, and I think it requires a small change in how we design APIs using the options hash.
The result, again, will be more intention-revelaing code.  Instead of using <code class="highlighter-rouge">nil</code> for “don’t set the location header”, we would
set an option that indicates that more clearly:</p>

<p>```ruby
class SomeController
  respond_to :json</p>

<p>def create
    record = create_record_somehow
    respond_with record, :set_location =&gt; false
  end
end
```</p>

<p>This would even improve the implementation of <code class="highlighter-rouge">respond_with</code> as well:</p>

<p>```ruby
def respond_with(record,options = {})
  options[:location] = options.fetch(:location) { default_location_for(record) }
  if options[:set_location]
    headers[‘Location’] = options[:location]
  end</p>

<p># and whatever else
end
```</p>

<p>Again, the absence of <code class="highlighter-rouge">nil</code> is making our code a <em>bit</em> longer, but much more intention-revealing and explicit.</p>

<p>In reality, though, <code class="highlighter-rouge">nil</code> exists and is used in many places.  Can we take anything from this to the real world?</p>

<h2 id="back-to-reality">Back to reality</h2>

<p>First and foremost, I would suggest that you design APIs in a way that <code class="highlighter-rouge">nil</code> is not required nor used.  Methods that return
collections should return an empty version instead of <code class="highlighter-rouge">nil</code>.  Method parameters should not allow <code class="highlighter-rouge">nil</code> to be passed in for any
value, and should use an options has for optional values.</p>

<p>Not every API is written this way, and to deal with them, there are a few handy methods provided by Ruby that can help:</p>

<ul>
  <li><code class="highlighter-rouge">String()</code> - converts <code class="highlighter-rouge">nil</code> to the empty string, and converts any string to itself.  Wrap a possibly-<code class="highlighter-rouge">nil</code> string in this and you avoid a <code class="highlighter-rouge">nil</code> check. (ActiveSupport’s <code class="highlighter-rouge">#present?</code> is a way to do this, too, but <code class="highlighter-rouge">String()</code> works everywhere in Ruby)</li>
  <li><code class="highlighter-rouge">Array()</code> - converts <code class="highlighter-rouge">nil</code> to an empty array and converts an array to itself.  Perfect for dealing with pesky APIs that insist on returning <code class="highlighter-rouge">nil</code> instead of an empty array.</li>
  <li><code class="highlighter-rouge">Hash[Array()]</code> - by combining <code class="highlighter-rouge">Hash#[]</code> and <code class="highlighter-rouge">Array()</code>, we can convert nil to an empty hash and a hash to itself.  <code class="highlighter-rouge">Array()</code> will turn a <code class="highlighter-rouge">Hash</code> into a two-dimensional array, and <code class="highlighter-rouge">Hash#[]</code> will turn a two-dimensional array back into a <code class="highlighter-rouge">Hash</code>.  Since <code class="highlighter-rouge">Array()</code> turns <code class="highlighter-rouge">nil</code> into an empty array, <code class="highlighter-rouge">Hash[Array(nil)]</code> returns an empty has.  Ruby really should include a method named <code class="highlighter-rouge">Hash()</code> that does this, but it doesn’t.</li>
</ul>

<p>Beyond this, <a href="http://en.wikipedia.org/wiki/Null_Object_pattern">null objects</a> are a useful pattern for encapsulating logic of the type “do this if some value is nil”, and the <a href="http://api.rubyonrails.org/classes/Object.html#method-i-try"><code class="highlighter-rouge">try</code></a>
method in Rails is also very useful.</p>

<p>It’s still interesting to think about a world without <code class="highlighter-rouge">nil</code>. Without it, we can still handle the absence of values in objects, as well as containers, and our code is more intentional-revelaing.  Why <em>do</em> we need <code class="highlighter-rouge">nil</code>?</p>

<hr />

<footer class="footnotes">
<ol>
<li>
<a name="1"></a>
<sup>1</sup>The JVM still allows <code>null</code> and so does Scala, so <code>Option</code> only provides a way to express optional types more clearly; <code>null</code> is still there and is the default value of variables that aren't given an initial value.<a href="#back-1">↩</a>
</li>
<li>
<a name="2"></a>
<sup>2</sup>It's worth pointing out that in Scala, <code>Option</code> is a lot more useful, because <code>null</code> has no such magical properties on the JVM like it does in Ruby.<a href="#back-2">↩</a>
</li>
<li>
<a name="3"></a>
<sup>3</sup>I realize that Active Record encapsulates this concept in <code>new_record?</code>, but a) we're in an imaginary domain without Active Record and b) that Active Record encapsulates the <code>nil</code> check gives more credence that doing so is a good idea in general.<a href="#back-3">↩</a>
</li>
</ol></footer>


  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2016, by David Bryant Copeland, All Rights Reserved
    </p>
  </footer>
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '56a22cd9c88d90284f000861');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>
</body></html>
