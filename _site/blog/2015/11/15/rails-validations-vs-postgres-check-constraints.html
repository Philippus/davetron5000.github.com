
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>Rails Validations vs Postgres Check Constraints - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  

  
  <meta name="description" content="

  
    Rails Validations vs Postgres Check Constraints
    
      November 15, 2015
    
  
  
    Before using Postgres, I would have to rely he...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2015/11/15/rails-validations-vs-postgres-check-constraints.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>Rails Validations vs Postgres Check Constraints</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      November 15, 2015
    </h2>
  </header>
  <section class="blog-content">
    <p>Before using Postgres, I would have to rely heavily on Rails validations to ensure data integrity—MySQL simply doesn’t provide the tools
to do this.  This always felt wrong.  Outside of rogue processes connecting to the database, there’s also application bugs
and, well, the ActiveRecord API itself: <code class="highlighter-rouge">update_attribute</code> skips validation!  That means it’s hard to rely on Rails validations for data
integrity, but there isn’t a great alternative for creating a great user experience.</p>

<p>Postgres has the answer: <em>check constraints</em>.  As we’ll see, check constraints are tool for <em>data integrity</em> and work much better than
Rails validations.  But Rails validations are still a great tool for <em>user experience</em>.</p>

<!-- more -->

<h2 id="check-constraints-for-data-integrity">Check Constraints for Data Integrity</h2>

<p>Suppose we have a table of users, and a user has a name and email:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">users</span><span class="p">(</span>
  <span class="n">id</span>    <span class="n">int</span>  <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">name</span>  <span class="n">text</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">email</span> <span class="n">text</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>
</code></pre>
</div>

<p><a name="back-1">
</a>
Although we’ve used <code class="highlighter-rouge">NOT NULL</code> to make sure there are values, we need more than that.  Although our domain doesn’t care about first or last names, it <em>does</em> require that a user’s name to be at least one letter, followed by a space, followed by at least one other letter<sup><a href="#fn_1">1</a></sup>.</p>

<p>We can do that by requiring that the <code class="highlighter-rouge">name</code> field match a regexp:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> 
  <span class="n">users</span> 
<span class="k">ADD</span> <span class="k">CONSTRAINT</span> 
  <span class="n">users_name_must_look_like_a_name</span> 
<span class="k">CHECK</span> <span class="p">(</span>
  <span class="n">name</span> <span class="o">~*</span> <span class="s1">'^.*[a-z] [a-z].*$'</span>
<span class="p">);</span>
</code></pre>
</div>

<p><a name="back-2">
</a>
This is saying that the <code class="highlighter-rouge">name</code> field must match the regular expression specified.  That regexp allows anything, as long as there is a
letter followed by a space, followed by another letter, somewhere in the string<sup><a href="#fn_2">2</a></sup>.</p>

<p>Now, when we insert an invalid value, it won’t work:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt; insert into users(id,name,email) values (1,'','bob@blah.com');
ERROR:  new row for relation "users" violates 
        check constraint "users_name_must_look_like_a_name"
DETAIL:  Failing row contains (1, , bob@blah.com).

&gt; insert into users(id,name,email) values (1,'Bob','bob@blah.com');
ERROR:  new row for relation "users" violates 
        check constraint "users_name_must_look_like_a_name"
DETAIL:  Failing row contains (1, Bob, bob@blah.com).

&gt; insert into users(id,name,email) values (1,'Bob Jones','bob@blah.com');
INSERT 0 1
</code></pre>
</div>

<p>Nice!  This means that a) our data will always match our rules around what good data is, and b) our code can rely on this.</p>

<p>For example, suppose we have to integrate with a third party shipping system that, for whatever reason, requires a first and last name.
Our system is designed to allow users to enter whatever their name is, as long as there are at least two parts.</p>

<p>Because we know our data meets its needs, we can safely do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">name_part1</span><span class="p">,</span><span class="n">rest_of_name</span> <span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/\s/</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="no">ShippingProvider</span><span class="p">.</span><span class="nf">generate_label</span><span class="p">(</span><span class="ss">first_name: </span><span class="n">name_part1</span><span class="p">,</span>
                                <span class="ss">last_name: </span><span class="n">rest_of_name</span><span class="p">)</span>
</code></pre>
</div>

<p>Without the check constraints, we couldn’t rely on the data being good, and so our use of <code class="highlighter-rouge">split</code> would have to have some sort of error
handling if the name didn’t have a space in it.  Because that can never happen, our code is simpler!</p>

<p>OK, so what does this have to do with Rails validations?</p>

<h2 id="rails-validations-for-user-experience">Rails Validations for User Experience</h2>

<p>The equivalent of our check constraint above, using Rails Validations, would be:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">format: </span><span class="sr">/\A.*[a-z] [a-z].*\z/i</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Sure enough, this prevents us violating the validation:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt; user = User.create(name: "bob", email: "bob@blah.com")
 =&gt; #&lt;User id: nil, name: "bob", email: "bob@blah.com"&gt; 
&gt; user.valid?
 =&gt; false 
&gt; user.errors
 =&gt; #&lt;ActiveModel::Errors:0x007fcf817cc808 
      @base=#&lt;User id: nil, name: "bob", email: "bob@blah.com"&gt;, 
      @messages={:name=&gt;["is invalid"]}&gt; 
</code></pre>
</div>

<p>Of course, we can route around this with ActiveRecord’s methods that allow it, or by calling <code class="highlighter-rouge">save(false)</code>, or by just going into the
database.</p>

<p><strong>This</strong> means that any code reading from this table must account for the bad data.</p>

<p>This presents us a few choices for how to deal with it:</p>

<ol>
  <li>Don’t worry about bad data getting in there</li>
  <li>Just use the check constraints</li>
  <li>Use both validations <em>and</em> check constraints</li>
</ol>

<p>Option 1 is unacceptable.  Our data is important and if our busines domain requires user names to have a letter, a space, and then
another letter, we can’t simply hope for the best.  As developers, we have a duty to ensure our code meets its requirements.</p>

<p>Option 2 creates a poor user experience:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt; User.create(name: "Bob", email: "bob@jones.com")
ActiveRecord::StatementInvalid: PG::CheckViolation: ERROR:  
  new row for relation "users" violates 
  check constraint "user_name_must_look_like_a_name"
DETAIL:  Failing row contains (22, Bob, bob@jones.com).
: INSERT INTO "users" ("name", "email", "id") VALUES ($1, $2, $3)
</code></pre>
</div>

<p>Assuming a user is going to be entering in their name, we need to give them a better experience than an exception. We need to use both,
which will create some duplication.</p>

<h2 id="be-ok-with-some-duplication">Be OK with Some Duplication</h2>

<p>If we use both the ActiveRecord validation <em>and</em> the check constraint, we achieve what we need: a good user experience, and ther
assurance of data integrity.  The <em>problem</em> is that this creates duplication.  We have the same regexp in two places and they both have
to be changed together.</p>

<p>While I could imagine a more sophisticated data layer handling this, we don’t have one.  That means we have to live with the duplication
or sacrifice our system requirements.  For me, the job of a programmer is to make the system work properly, even if that means that the
resulting code has maintenance issues.</p>

<p>I am OK with this duplication.  If you think about most projects, the changes in requirements are often more about logic than data.  The
data you are storing and managing has a much more stable definition than the process that manage that data.  So, this duplication is less
likely to run afoul of bugs since it’s not going to change as much as the logic around it.</p>

<p>That being said, you <em>do</em> have to have an understanding of what valid data is.  This means being clear about data integrity.</p>

<h2 id="what-is-data-integrity">What is Data Integrity?</h2>

<p>In the example above, my assumption is that the business owning this database of users absolutely requires that each user’s name have a
letter, a space, and a letter in it.  This isn’t something that’s required <em>sometimes</em> or something a programmer invented, but an
<em>invariant of the domain</em>.  This is exactly what you want to encode in database constraints.</p>

<p>What you <em>don’t</em> want to do is encode use-case-specific constraints that are not universal to your business domain.</p>

<p>Suppose that in some cases, we need to have a name that’s more than just a couple characters.  We can blame a third party integration
again—we need to generate an invoice and it requires a first and last name that are each two characters or more.</p>

<p>Since that is not a requirement of <em>our</em> domain, we don’t want this in our database.  This means we have to just deal with it:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">name_part1</span><span class="p">,</span><span class="n">rest_of_name</span> <span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/\s/</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">if</span> <span class="n">name_part1</span><span class="p">.</span><span class="nf">length</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">rest_of_name</span><span class="p">.</span><span class="nf">length</span> <span class="o">&gt;</span> <span class="mi">1</span>
  <span class="no">InvoiceService</span><span class="p">.</span><span class="nf">generate_invoice!</span><span class="p">(</span><span class="ss">first: </span><span class="n">name_part1</span><span class="p">,</span> <span class="ss">last: </span><span class="n">rest_of_name</span><span class="p">)</span>
<span class="k">else</span>
  <span class="c1"># ???</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Depending on where this code is, you might handle the problem in a variety of ways.  You could create an ActiveModel that uses
validations to check for this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">InvoiceUser</span>
  <span class="kp">include</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Validations</span>

  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">format: </span><span class="sr">/\A.*[a-z][a-z] [a-z][a-z].*\z/i</span>

  <span class="k">def</span> <span class="nf">user</span>
    <span class="no">User</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">name: </span><span class="nb">self</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="ss">email: </span><span class="nb">self</span><span class="p">.</span><span class="nf">email</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This works as advertised:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&gt; i = InvoiceUser.new
 =&gt; #&lt;InvoiceUser:0x007ff604d80b60&gt; 
&gt; i.name = 'a b'
 =&gt; "a b" 
&gt; i.valid?
 =&gt; false 
&gt; i.name = 'aa bb'
 =&gt; "aa bb" 
&gt; i.valid?
 =&gt; true 
&gt; i.user.save!
 =&gt; #&lt;User:0x007fcf817cc808&gt;
</code></pre>
</div>

<p>We could even use this in Rails’ form helpers by bringing in more Active Model modules.  This way, a user who has to enter their name as
part of some use-case to create invoices will have a good experience, but our database won’t need to grow extra constraints that aren’t
universally needed.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Think about Rails validations as purely something for user experience.  Think about check constraints as just being about data integrity.
Often they are the same thing, but not always.  And don’t fret about a bit of duplication.</p>

<p><em>Read more in my new book <a href="https://pragprog.com/book/dcbang/rails-angular-postgres-and-bootstrap">“Rails, Angular, Postgres, and Bootstrap
Powerful, Effective, and Efficient Full-Stack Web Development”</a></em></p>

<hr />

<footer class="footnotes">
<ol>
<li>
<a name="fn_1"></a>
<sup>1</sup>I realize this is not appropriate for a lot of people's names.  This isn't a post about that, so this example is quite
simplified to to illustrate the points.  When designing a system to store people's names, put a <strong>lot</strong> of thought into it,
especially if someone outside the United States might use it.
<a href="#back-1">↩</a>
</li>
<li>
<a name="fn_2"></a>
<sup>2</sup>This is also not a post about regular expressions.  Please craft them carefully. 
<a href="#back-2">↩</a>
</li>
</ol></footer>

  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2016, by David Bryant Copeland, All Rights Reserved
    </p>
  </footer>
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '56a22cd9c88d90284f000861');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>
</body></html>
