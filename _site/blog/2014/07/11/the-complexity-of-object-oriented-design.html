
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>The Complexity of Object-Oriented Design - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  

  
  <meta name="description" content="

  
    The Complexity of Object-Oriented Design
    
      July 11, 2014
    
  
  
    I can’t say what a codebase designed to Alan Kay’s idea o...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2014/07/11/the-complexity-of-object-oriented-design.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>The Complexity of Object-Oriented Design</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      July 11, 2014
    </h2>
  </header>
  <section class="blog-content">
    <p>I can’t say what a codebase designed to Alan Kay’s idea of “object-oriented” might look like.
I <em>can</em> say what your average developer (including myself) actually creates using object-oriented languages, tools, and techniques.
The result is a constant battle to tame complexity.
I’m going to lay out one source of that complexity, because it’s baked-in to object-orientation, and I debate that it provides any utility in making programs easy to understand or change.</p>

<!-- more -->

<p>Consider a procedural language in which no global symbols are possible:</p>

<p>```ruby
def salutation(first_name,last_name)
  if first_name != nil
    “Hey #{first_name}!”
  else
    “Hello, #{last_name}”
  end
end</p>

<p>salutation(“Dave”,”Copeland”) # =&gt; Hey Dave
salutation(nil,”Jones”)       # =&gt; Hello, Jones
```</p>

<p>Because there are no global symbols, we can easily (and totally) understand this routine.
Everything it requires to do its job is passed as parameter, and every affect it has is part of its return value.</p>

<p>Such a language would be unusable at any real complexity, because we could not decompose logic into smaller re-usable routines.
Consider if we are creating a message for someone:</p>

<p>```ruby
def create_message(first_name,last_name,message,from)
  salutation = if first_name != nil
                 “Hey #{first_name}!”
               else
                 “Hello, #{last_name}”
               end
  %{
#{salutation},</p>

<h1 id="message">{message}</h1>

<div class="highlighter-rouge"><pre class="highlight"><code>       Sincerely,

       #{from} } end ```
</code></pre>
</div>

<p>This routine, like <code class="highlighter-rouge">salutation</code>, is still simple to understand.
Everything it needs to do its job is passed as a parameter and its entire affect is described in its return value.</p>

<p>But, since we don’t have global symbols (or any other obvious way to share logic), we’ve had to duplicate <code class="highlighter-rouge">salutation</code>.
Although our hypothetical language encourages simple design, it’s not usable in its current state.</p>

<p>If we could wrap up the salutation logic, along with the data it needed, into a single package, that could allow re-use.</p>

<h2 id="objects-data--functionality">Objects: Data &amp; Functionality?</h2>

<p>In an object-oriented language, we have the ability to associate functionality with data, so we might logically have the <code class="highlighter-rouge">first_name</code> and <code class="highlighter-rouge">last_name</code> in some sort of object, and that object will implement the <code class="highlighter-rouge">salutation</code> method.</p>

<p><code class="highlighter-rouge">ruby
class Person
  def salutation
    if first_name != nil
      "Hey #{first_name}!"
    else
      "Hello, #{last_name}"
    end
  end
end
</code></p>

<p>Now, our <code class="highlighter-rouge">create_message</code> doesn’t need to reproduce the <code class="highlighter-rouge">salutation</code> logic, but can use it from the new <code class="highlighter-rouge">person</code> object:</p>

<p>```ruby
def create_message(person,message,from)
  %{
#{person.salutation},</p>

<h1 id="message-1">{message}</h1>

<div class="highlighter-rouge"><pre class="highlight"><code>       Sincerely,

       #{from} } end ```
</code></pre>
</div>

<p>This seems good, right?  We still don’t need global symbols, and we’ve found a way to encapsulate and re-use logic.</p>

<h2 id="why-are-global-symbols-bad">Why are global symbols bad?</h2>

<p>Suppose that instead of creating objects, we had the ability to define a global symbol.
We could re-use <code class="highlighter-rouge">salutation</code> by making in global, meaning that <code class="highlighter-rouge">create_message</code> could be implemented as follows:</p>

<p>```ruby
def create_message(first_name,last_name,message,from)
  %{
#{salutation(first_name,last_name},</p>

<h1 id="message-2">{message}</h1>

<div class="highlighter-rouge"><pre class="highlight"><code>       Sincerely,

       #{from} } end ```
</code></pre>
</div>

<p>We’ve successfully re-used <code class="highlighter-rouge">salutation</code>, but look at how complex <code class="highlighter-rouge">create_message</code> has become!  Before, <strong>all</strong> input to <code class="highlighter-rouge">create_message</code> was in its parameter list.
<em>Now</em>, its inputs are the parameter list and <strong>every global symbol</strong>.</p>

<p>Consider how we might send a message:</p>

<p><code class="highlighter-rouge">ruby
def send_message(email_addresses,message)
  for email_address in email_addresses
    email(email_address,message)
  end
end
</code></p>

<p>In addition to having all global state as its input, <code class="highlighter-rouge">send_message</code>’s <em>output</em> is also anything available in global state.
<code class="highlighter-rouge">send_message</code> returns nothing, but has an affect on the outside world nontheless.</p>

<p>All this means that any routine that has access to a shared global state is going to be more complex than one that doesn’t, and that, without discipline, a program making use of shared global state will be harder to understand, test, and modify.</p>

<p>This gives us a new insight into our object-oriented solution.  Although <code class="highlighter-rouge">send_message</code> retained its simplicity, we’ve actually created a miniature global state in our <code class="highlighter-rouge">Person</code> class.</p>

<h2 id="objects-are-their-own-shared-global-state">Objects Are Their Own Shared Global State</h2>

<p>Our <code class="highlighter-rouge">Person</code> class from above omitted a few details, namely where <code class="highlighter-rouge">first_name</code> and <code class="highlighter-rouge">last_name</code> came from.
In most OO languages, you’d assume they are instance variables, so let’s add a bit more code to make this a Ruby class.</p>

<p>```ruby
class Person
  def initialize(first_name,last_name)
    @first_name = first_name
    @last_name  = last_name
  end</p>

<p>def salutation
    if @first_name != nil
      “Hey #{@first_name}!”
    else
      “Hello, #{@last_name}”
    end
  end
end
```</p>

<p>This is now a working Ruby implementation of our <code class="highlighter-rouge">Person</code> class.
Look again at <code class="highlighter-rouge">salutation</code>.
What are its inputs?
It takes no parameters, but is freely able to reference instance variables.
So, its inputs are <strong>every instance variable of the object</strong>.
Currently, there are only two, but it’s entirely possible, and likely, that we’ll have objects with many more instance variables, and more functionality.</p>

<p>Let’s add the ability to change a person’s name, which is a reasonable operation to provide (I’m showing the entire class instead just of the changes):</p>

<p>```ruby
class Person
  def initialize(first_name,last_name)
    @first_name = first_name
    @last_name  = last_name
  end</p>

<p>def salutation
    if @first_name != nil
      “Hey #{@first_name}!”
    else
      “Hello, #{@last_name}”
    end
  end</p>

<p>def first_name=(new_first_name)
    @first_name = new_first_name
  end</p>

<p>def last_name=(new_last_name)
    @last_name = new_last_name
  end
end
```</p>

<p><code class="highlighter-rouge">first_name=</code> and <code class="highlighter-rouge">last_name=</code> take a parameter, but they don’t return a (useful) value.
The point of those methods is to change the internal state of the object, meaning that their affects are <em>not</em> part of their return value.</p>

<p>This is the same problem we had with global variables!
Certainly, instance variables, due to their natural proximity to the code that can access them, create <em>less</em> of a mess, but they still create the same type of complexity.</p>

<p>Now add inheritance and mixins to your toolbelt, and you have <em>even more</em> inputs and outputs to each routine.</p>

<p>This means that object-oriented designs encourage the creation of routines that have multiple, implicit inputs and have multiple, implicit outputs.
Object-oriented design, by its very nature, encourages writing complex routines.</p>

<p>To combat this complexity, we have had to develop a lot of “rules”, “laws”, and “principles”, and their application is a source of constant debate.
Even for someone with years of experience, it can be difficult to know how to best-factor an object-oriented codebase.</p>

<p>Let’s go back to the problem we were originally trying to solve.</p>

<h2 id="remove-all-implicit-state">Remove All Implicit State</h2>

<p>I’ve been using “global” a lot, but what we really mean is “implicit”.
It’s the ability of a routine to access symbols outside its scope that is the source of complexity here.
So let’s go back to our original routines and see how else we could solve the problem of sharing code, but without introducing implicit state.</p>

<p>Here are the two routines again:</p>

<p>```ruby
def salutation(first_name,last_name)
  if first_name != nil
    “Hey #{first_name}!”
  else
    “Hello, #{last_name}”
  end
end</p>

<p>def create_message(first_name,last_name,message,from)
  salutation = if first_name != nil
                 “Hey #{first_name}!”
               else
                 “Hello, #{last_name}”
               end
  %{
#{salutation},</p>

<h1 id="message-3">{message}</h1>

<div class="highlighter-rouge"><pre class="highlight"><code>       Sincerely,

       #{from} } end ```
</code></pre>
</div>

<p>Clearly, <code class="highlighter-rouge">create_message</code> needs to access the logic in <code class="highlighter-rouge">salutation</code>, so let’s allow that.
I’ll do this using valid Ruby syntax, where <code class="highlighter-rouge">&amp;foo</code> as a parameter denotes a passed function and <code class="highlighter-rouge">&amp;method(:foo)</code> turns a function into a passable function.</p>

<p>```ruby
def salutation(first_name,last_name)
  if first_name != nil
    “Hey #{first_name}!”
  else
    “Hello, #{last_name}”
  end
end</p>

<p>def create_message(first_name,last_name,message,from,&amp;salutation)
  %{
#{salutation.(first_name,last_name},</p>

<h1 id="message-4">{message}</h1>

<div class="highlighter-rouge"><pre class="highlight"><code>       Sincerely,

       #{from} } end
</code></pre>
</div>

<p>create_message(“Dave”,”Copeland”,”Nice blog post!”,”Yourself”,method(&amp;salutation))
```</p>

<p>Now, we’ve re-used our logic, and all the routines in question still maintain a single source of input and a single destination for output.
<code class="highlighter-rouge">create_message</code> has gotten slightly more complex, due to the additional parameter, but it’s also lost complexity due to being able to re-use <code class="highlighter-rouge">salutation</code>.</p>

<p>Can we build an entire system like this?
The functional programmers say we can (and they have certainly proved this).
Might be something to think about.</p>

  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2016, by David Bryant Copeland, All Rights Reserved
    </p>
  </footer>
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '56a22cd9c88d90284f000861');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>
</body></html>
