
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>Mocking Enumeration in Scala with EasyMock - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="XXX">

  
  <meta name="description" content="

  
  
    Mocking Enumeration in Scala with EasyMock
  
  
    
      








  




    
  


I'm working on a Scala url shortener (to be hoste...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2009/10/21/mocking-enumeration-in-scala.html">
  <link href="/favicon.png" rel="icon">
  <link href="" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <div>
<article role="article">
  <header>
  
    <h1 class="entry-title">Mocking Enumeration in Scala with EasyMock</h1>
  
  
    <p class="meta">
      








  



<time datetime="2009-10-21T00:00:00-04:00" pubdate data-updated="true"></time>
    </p>
  
</header>

<div>I'm working on a Scala url shortener (to be hosted at my awesomely problem-causing &#10106;&#10144;.ws domain).  Since this is such a small application, I'm rolling it ground-up from the Servlet spec only, to get a feel for Scala without having to worry about a lot of dependencies.  As such, one of the things I need to do is parse the requestor's "representation", i.e. determine if I'm serving JSON, XML, or HTML.  Since this comes from the <tt>Accept:</tt> header, my tests will need to mock <tt>HttpServletRequest</tt>.

```scala
val enumeration = createMock(
    classOf[java.util.Enumeration[String]])

expect(enumeration.hasMoreElements).andReturn(true)
expect(enumeration.nextElement).andReturn("TEXT/HTML")
expect(enumeration.hasMoreElements).andReturn(false)
// the following call doesn't compile!!!
expect(request.getHeaders(parser.ACCEPT_HEADER))
  .andReturn(enumeration)
expect(request.getParameter(parser.TYPE_PARAM))
  .andReturn(null)

replay(request)
replay(enumeration)

val t = parser.determineRepresentation(request)
t should equal (Some("text/html"))
```

When I compile this test, I get the following baffling error message:

```scala
TestRepresentationParser.scala:21: type mismatch;
found   : java.util.Enumeration[String]
required: java.util.Enumeration[?0] where type ?0
    EasyMock.expect(request.getHeaders(parser.ACCEPT_HEADER))
        .andReturn(enumeration)
```

Um, OK?  I tried zillions of ways to cast things, even creating my own implementation of <tt>Enumeration[String]</tt>, to no avail.  There seems to be
some problem with the fact that <tt>HttpServletRequest</tt> returns a non-parameterized <tt>Enumeration</tt> in its interface, but Scala won't
let me create such a thing.

I had given up on testing this for a while, but eventually the simple solution prevailed:
```scala
EasyMock.expect(request.getHeaders(parser.ACCEPT_HEADER))
// this call is obviously not type-checked, so it works
expectLastCall.andReturn(enumeration)
```

Kinda cheesy, and I kinda feel stupid for not thinking of it sooner.  
</div>


  <footer>
    <p class="meta">
      
  




      








  



<time datetime="2009-10-21T00:00:00-04:00" pubdate data-updated="true"></time>
    </p>
  </footer>
</article>
</div>

</body></html>
