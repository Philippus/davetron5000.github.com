
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>Introduction to GLI - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  

  
  <meta name="description" content="

  
    Introduction to GLI
    
      December 02, 2013
    
  
  
    Sitepoint recently published Introduction to Thor and, to be honest, I don...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2013/12/02/introduction-to-gli.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>Introduction to GLI</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      December 02, 2013
    </h2>
  </header>
  <section class="blog-content">
    <p>Sitepoint recently published <a href="http://www.sitepoint.com/introduction-thor/">Introduction to Thor</a> and, to be honest, I don’t think Thor is a great tool for writing
command-line apps.  Thor is a great for writing Rails generators (likely the only reasonable tool), but I wrote GLI
specifically because I wanted a tool tailor-made to write awesome command-line apps.</p>

<p>With the re-release of <a href="http://pragprog.com/book/dccar2/build-awesome-command-line-applications-in-ruby-2">my book</a>, which uses GLI to demonstrate how to build amazing command-line apps in Ruby, I thought
I’d mimic Sitepoint’s post with a GLI version, and let you decide for yourself.</p>

<!-- more -->

<h2 id="what-is-gli">What is GLI?</h2>

<p>GLI is a Ruby library designed to make writing a “command-based” application (which I call a “command suite”)
very easy.  It’s designed to make the simple things simple, but to not hide anything from the developer.</p>

<p>I won’t go back to getopt, but a fairly common way to create a command suite application is to use <code class="highlighter-rouge">OptionParser</code> to get command
line options, and then parse <code class="highlighter-rouge">ARGV</code> directly to figure out the “command”:</p>

<p>```ruby
include “optparse”</p>

<p>options[:file] = “~/.todo”</p>

<p>opts = OptionParser.new do |opts|
  # declare a new options
  opts.on(
      “-f FILE”,”–file”, # it can be -f or –file and requires an argument
      “Location of the todo list file (default ~/.todo)”) do |file|
    options[:file] = file # when the user specifies it, save the argument in options[:file]
  end</p>

<p>opts.on(
      “-l”,”–long”,
      “List todo elements in long form”) do |long|
    options[:long] = long
  end</p>

<p>opts.on(
      “-a”,”–all”,
      “List all todos, not just ones that haven’t been completed”) do |all|
    options[:all] = all
  end
end</p>

<p>opts.parse!  # parse the options, modifying ARGV</p>

<p>command = ARGV.shift</p>

<p>case command do
when ‘new’: 
  # Add a new todo to options[:file]
when ‘done’
  # complete a todo and rewrite options[:file]
when ‘list’
  # use options[:all] and options[:long] to output
  # the todo list in options[:file]
else
  # Print help
end
```</p>

<p>There are a few problems with this:</p>

<ul>
  <li>The <code class="highlighter-rouge">--all</code> and <code class="highlighter-rouge">--long</code> options are only relevant to the <code class="highlighter-rouge">list</code> command</li>
  <li>There’s no explicit documentation of the commands - we have to hope that the generic help will tell us what they do</li>
  <li>The option handling code is very duplicative and boilerplate</li>
  <li>Making this robust is tricky - if the user passes wrong options, we’ll get a bad message</li>
</ul>

<p>These are problems solvable by a framework more sophisticated than <code class="highlighter-rouge">OptionParser</code></p>

<h2 id="first-steps-with-gli">First Steps with GLI</h2>

<p>Typically, a new GLI app is generated for you by the <code class="highlighter-rouge">gli</code> command-line app:</p>

<p>```
&gt; gem install gli
Fetching: gli-2.8.1.gem (100%)
Successfully installed gli-2.8.1
&gt; gli init todo new done list
&gt; cd todo
&gt; bundle install
&gt; bundle exec bin/todo help
NAME
    todo - Describe your application here</p>

<p>SYNOPSIS
    todo [global options] command [command options] [arguments…]</p>

<p>VERSION
    0.0.1</p>

<p>GLOBAL OPTIONS
    -f, –flagname=The name of the argument - Describe some flag here (default: the default)
    –help                                  - Show this message
    -s, –[no-]switch                       - Describe some switch here
    –version                               - Display the program version</p>

<p>COMMANDS
    done - Describe done here
    help - Shows a list of commands or help for one command
    list - Describe list here
    new  - Describe new here
```</p>

<p>OK, so what happened?  We haven’t written any Ruby code, but we ran some commands, and had to use bundler.</p>

<p>GLI makes a few assumptions about how you want to work:</p>

<ul>
  <li>You want a canoncially set-up Ruby project structure</li>
  <li>You want to write tests</li>
  <li>You want to distribute via RubyGems</li>
</ul>

<p>None of these are requirements for GLI, so you could just as easily <code class="highlighter-rouge">gem install gli</code> and get to work.  The reason we are using
Bundler is because <code class="highlighter-rouge">bin/todo</code> does <em>not</em> hack the load path to load our files in <code class="highlighter-rouge">lib</code>.  At runtime, RubyGems will configure the
load path for our users, so everything in <code class="highlighter-rouge">lib</code> will be available.  In development, we don’t have that, so we use Bundler, which
does the same thing.  You could also do <code class="highlighter-rouge">RUBYLIB=lib bin/todo help</code> if you prefer.</p>

<p>Back to our app, you’ll notice that we have an application that produces a pretty decent help system already, so what does the code look like?</p>

<p>```ruby
#!/usr/bin/env ruby
require ‘gli’
require ‘todo’</p>

<p>include GLI::App</p>

<p>program_desc ‘Describe your application here’</p>

<p>version Todo::VERSION</p>

<p>desc ‘Describe some switch here’
switch [:s,:switch]</p>

<p>desc ‘Describe some flag here’
default_value ‘the default’
arg_name ‘The name of the argument’
flag [:f,:flagname]</p>

<p>desc ‘Describe new here’
arg_name ‘Describe arguments to new here’
command :new do |c|
  c.desc ‘Describe a switch to new’
  c.switch :s</p>

<p>c.desc ‘Describe a flag to new’
  c.default_value ‘default’
  c.flag :f
  c.action do |global_options,options,args|
    puts “new command ran”
  end
end</p>

<p>desc ‘Describe done here’
arg_name ‘Describe arguments to done here’
command :done do |c|
  c.action do |global_options,options,args|
    puts “done command ran”
  end
end</p>

<p>desc ‘Describe list here’
arg_name ‘Describe arguments to list here’
command :list do |c|
  c.action do |global_options,options,args|
    puts “list command ran”
  end
end</p>

<p>pre do |global,command,options,args|
  true
end</p>

<p>post do |global,command,options,args|
end</p>

<p>on_error do |exception|
  true
end</p>

<p>exit run(ARGV)
```</p>

<p>Since we specified <code class="highlighter-rouge">new done list</code> on the command line to <code class="highlighter-rouge">gli init</code>, it went ahead and created command blocks for us.  Notice
that each command block is configured in the style of rake - we describe the command, document its arguments, and declare that
it exists.  You’ll notice that each command has a generic <code class="highlighter-rouge">puts</code> in it, so we can see how our new app works right now:</p>

<p>```
&gt; bundle exec bin/todo list
list command ran</p>

<blockquote>
  <p>bundle exec bin/todo done
done command ran
```</p>
</blockquote>

<p>We can also get help for particular commands already:</p>

<p>```
&gt; bundle exec bin/todo help list
NAME
    list - Describe list here</p>

<p>SYNOPSIS
    todo [global options] list Describe arguments to list here
```</p>

<p>Not bad for having written absolutely no code!</p>

<h2 id="filling-it-in">Filling it in</h2>

<p>Let’s replace the boilerplate with what we need for our todo list app.</p>

<p>```ruby
desc ‘Location of todo file’
default_value ‘~/.todo’
arg_name ‘path_to_file’
flag [:f,:file]</p>

<p>desc ‘Create a new todo item’
arg_name ‘text_of_todo’
command :new do |c|
  c.action do |global_options,options,args|
    todo = args.join(‘ ‘)
    # Add todo to the file at global_options[:file]
  end
end</p>

<p>desc ‘Complete a todo’
arg_name ‘todo_id’
command :done do |c|
  c.action do |global_options,options,args|
    id = args.shift
    # Locate id in global_options[:file] and mark it completed
  end
end</p>

<p>desc ‘List todo items’
command :list do |c|
  c.desc ‘Use long format’
  c.switch [:l,:long]</p>

<p>c.desc ‘Show all items, even uncompleted ones’
  c.switch [:a,:all]</p>

<p>c.action do |global_options,options,args|
    # Read todos from global_options[:file]
    # and then use options[:long] and
    # options[:all] to figure out what
    # to display
  end
end
```</p>

<p>Basically, we’ve just replaced boilerplate text with our app-, command-, and option-specific help text.  We also removed the
example flags and switches and replaced them with the ones we’ll actually need.</p>

<p>Notice that we specified <code class="highlighter-rouge">--file</code> outside of any command block, thus making it a global flag.  This is because all commands need access to the todo file.  Note also that the options <code class="highlighter-rouge">--long</code> and <code class="highlighter-rouge">--all</code>, which are specified inside the <code class="highlighter-rouge">list</code> command block, will only be available for the <code class="highlighter-rouge">list</code> command.</p>

<p>```
&gt; bundle exec bin/todo help 
NAME
    todo - Describe your application here</p>

<p>SYNOPSIS
    todo [global options] command [command options] [arguments…]</p>

<p>VERSION
    0.0.1</p>

<p>GLOBAL OPTIONS
    -f, –file=path_to_file - Location of todo file (default: ~/.todo)
    –help                  - Show this message
    –version               - Display the program version</p>

<p>COMMANDS
    done - Complete a todo
    help - Shows a list of commands or help for one command
    list - List todo items
    new  - Create a new todo item</p>

<blockquote>
  <p>bundle exec bin/todo help new
NAME
    new - Create a new todo item</p>
</blockquote>

<p>SYNOPSIS
    todo [global options] new text_of_todo</p>

<blockquote>
  <p>bundle exec bin/todo help list
NAME
    list - List todo items</p>
</blockquote>

<p>SYNOPSIS
    todo [global options] list [command options]</p>

<p>COMMAND OPTIONS
    -a, –[no-]all  - Show all items, even uncompleted ones
    -l, –[no-]long - Use long format
```</p>

<p>Notice how we see the documentation relevant to the command, and not in one global space?  Handy.</p>

<p>What I like about this design is that, although it’s not “object-oriented”, it’s obvious and clear.  A command-line
interface isn’t OO, it’s declarative and command-oriented, so it makes sense to me that we describe our UI in the same way.</p>

<p>Also notice the structure of the command line.  In a Thor app, all command-line options must come at the end of the command line.
In a GLI app, the position of the switches determines their interpretation.</p>

<p><code class="highlighter-rouge">
&gt; bin/todo -f ~/.todo.txt -l list
error: Unknown options -l
&gt; bin/todo list -l -f ~/.todo.txt
error: Unknown option -f
&gt; bin/todo -f ~/.todo.txt list -l
# lists in long form from ~/.todo.txt
</code></p>

<p>This creates namespaces for our options, which allows the creation of a rich user interface, if needed. I borrowed this design
from <code class="highlighter-rouge">git</code> (and, in fact, GLI stands for “Git-Like Interface”).</p>

<p>Our application code would likely <em>not</em> live inside this file, but instead be delegated to classes located under <code class="highlighter-rouge">lib</code>, designed
and unit tested as you would in any application.  The file generated by <code class="highlighter-rouge">gli init</code> is already primed to look there.</p>

<h2 id="digging-deeper">Digging Deeper</h2>

<p>This example only scratches the surface.  Let’s go over a few different handy features for managing our command suite.</p>

<h3 id="powerful-option-parsing">Powerful option parsing</h3>

<p>It’s usually good practice for switches (options that take no arguments) to have both a positive and “negative” version.  For
example, we’d want to be able to use <code class="highlighter-rouge">--no-long</code> or <code class="highlighter-rouge">--long</code>, as appropriate.  You can see from our help output that GLI supports this by default.  If the user
specifies <code class="highlighter-rouge">--no-all</code> on the command line, <code class="highlighter-rouge">options[:all]</code> will be false.</p>

<p>GLI makes this work because it’s using <code class="highlighter-rouge">OptionParser</code> underneath.  This opens up some other powerful features.</p>

<p>Suppose we want to give our new todo items a “category” and that we want to require the category to be one of “chore”, “feature”, or “bug”.   The naive approach would be to examine <code class="highlighter-rouge">options[:category]</code> inside our <code class="highlighter-rouge">action</code> block and raise an error if it’s not one of the three allowed values, GLI, via <code class="highlighter-rouge">OptionParser</code>, provides this for us:</p>

<p>```ruby
command :new do |c|
  c.desc “The category of the new todo”
  c.default_value ‘chore’
  c.flag :category, must_match: %w(chore feature bug)</p>

<p># …</p>

<p>c.action do |global_options, options, args|
    # options[:category] will always be one of chore, feature, or bug
  end
end
```</p>

<p><code class="highlighter-rouge">must_match</code> takes a wide variety of values, including an <code class="highlighter-rouge">Array</code>, <code class="highlighter-rouge">Hash</code>, or <code class="highlighter-rouge">Regexp</code>.</p>

<p>Flags also accept the option <code class="highlighter-rouge">:type</code> that can be used to do a type conversion.  <code class="highlighter-rouge">OptionParser</code> has some <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/optparse/rdoc/OptionParser.html">conversions built-in</a>, but we could do very sophisticated things if we wanted to:</p>

<p>```ruby
accept(Todo::Type) do |string|
  Todo.const_get(string.capitalize)
end</p>

<p>command :new do |c|
  c.desc “The type of the new todo”
  c.default_value ‘chore’
  c.flag :type, must_match: %w(chore feature bug), type: Todo::Type</p>

<p># …</p>

<p>c.action do |global_options, options, args|
    # options[:type] will always be Todo::Chore, Todo::Feature, or Todo::Bug
  end
end
```</p>

<p>Nice!</p>

<h3 id="default-values">Default Values</h3>

<p>You’ve probably noticed <code class="highlighter-rouge">default_value</code> being used.  This not only documents in our help text what the default of a flag is, but
it’s also the default value in <code class="highlighter-rouge">global_options</code> or <code class="highlighter-rouge">options</code>.  You don’t have to manage it yourself.</p>

<h3 id="aliases">Aliases</h3>

<p>By default, GLI will identify a command based on the shortest unambiguous string.  In our case, <code class="highlighter-rouge">bundle exec bin/todo n</code> would be
recognized as the “new” command, because no other command starts with “n”.</p>

<p>We can also provide explicit aliases by passing an array to <code class="highlighter-rouge">command</code>, much as we did with our flags and switches:</p>

<p>```ruby
command [:list,:show] do |c|</p>

<p># …</p>

<p>end
```</p>

<h3 id="global-hooks">Global Hooks</h3>

<p>If we were to fill in the three actions with actual code, you’d see that they all have some need to access the to-do list.  We
might create a class like <code class="highlighter-rouge">TodoList</code> and use it like so:</p>

<p>```ruby
c.command :list do 
  c.action do |global_options,options,args|
    todo_list = TodoList.load(global_options[:file])
    todo_list.tasks.each do |todo|
      puts todo
    end
  end
end</p>

<p>c.command :done do
  c.action do |global_options,options,args|
    todo_list = TodoList.load(global_options[:file])
    todo_list.complete!(args.shift)
    todo_list.save!(global_options[:file])
  end
end</p>

<p>c.command :new do
  c.action do |global_options,options,args|
    todo_list = TodoList.load(global_options[:file])
    todo_list.add(args.join(‘ ‘)
    todo_list.save!(global_options[:file])
  end
end
```</p>

<p>This can get repetitive.  Although we have a way to specify that all commands have the flag <code class="highlighter-rouge">--file</code>, it would be nice if we
could globally translate that filename into a real object and have it managed outside our commands.</p>

<p>That’s where <code class="highlighter-rouge">pre</code> and <code class="highlighter-rouge">post</code> come in:</p>

<p>```ruby
pre do |global_options,command,options,args|
  $todo_list = TodoList.load(global_options[:file])
  true
end</p>

<p>post do |global_options,command,options,args|
  $todo_list.save!(global_options[:file])
end</p>

<p>c.command :list do 
  c.action do |global_options,options,args|
    $todo_list.tasks.each do |todo|
      puts todo
    end
  end
end</p>

<p>c.command :done do
  c.action do |global_options,options,args|
    $todo_list.complete!(args.shift)
  end
end</p>

<p>c.command :new do
  c.action do |global_options,options,args|
    $todo_list.add(args.join(‘ ‘)
  end
end
```</p>

<p>Here, <code class="highlighter-rouge">pre</code> receives the parsed command and options.  The <code class="highlighter-rouge">pre</code> block’s code will execute before the contents of our <code class="highlighter-rouge">action</code> block.
<code class="highlighter-rouge">post</code>, too, receives this information and runs <em>after</em> our action block.  Our todo list app commands always have access to the parsed todo list file, and can be sure that any changes they make will
be saved to disk after.</p>

<h3 id="subcommands">Subcommands</h3>

<p>GLI allows infinitely nested subcommands.  For example, if we wanted to have our <code class="highlighter-rouge">list</code> command work a bit differently, such as
<code class="highlighter-rouge">todo list done</code> or <code class="highlighter-rouge">todo list inprogress</code>, we can model <code class="highlighter-rouge">done</code> and <code class="highlighter-rouge">inprogress</code> as subcommands:</p>

<p>```ruby
desc “List todo items”
command :list do |list|</p>

<p>list.desc “Show only completed items”
  list.command :done do |done|
    done.action do |global_options,options,args|
      $todo_list.completed.each do |todo|
        puts todo
      end
    end
  end</p>

<p>list.desc “Show only in-progress items”
  list.command :inprogress do |done|
    done.action do |global_options,options,args|
      $todo_list.in_progress.each do |todo|
        puts todo
      end
    end
  end
end
```</p>

<p>Subcommands have their own “option space”, so you can create a very sophisticated UI if you need to.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I’ve tried a lot of command-line libraries for Ruby and GLI is the most featureful, compact, and powerful one I’ve seen—I created
it to be that way.  The thing I like about it is that simple applications have simple source code, but if you need more complex
features, they are there for you.  The “shape” of your binfile mimics the shape of your app.  The bootstrapping from <code class="highlighter-rouge">gli init</code>
also sets you up to have a properly organized, easily distributable application—all hallmarks of an awesome command-line app.</p>

<p>“Build Awesome Command-Line Applications in Ruby 2” is <a href="http://pragprog.com/book/dccar2/build-awesome-command-line-applications-in-ruby-2">on sale now</a> (and is a free upgrade for purchasers of the first version).
It covers the generic aspects of command-line development with Ruby, using GLI to demonstrate how to do it with command suites.
It’s also a much deeper dive on <code class="highlighter-rouge">OptionParser</code>, which is a powerful tool you should learn for writing non-command-based
command-line apps.  The appendix covers Thor, Main, and Methadone as well.</p>


  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2016, by David Bryant Copeland, All Rights Reserved
    </p>
  </footer>
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '56a22cd9c88d90284f000861');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>
</body></html>
