
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>It's not Naming That's Hard—It's Types - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  

  
  <meta name="description" content="

  
    It's not Naming That's Hard—It's Types
    
      March 15, 2016
    
  
  
    Katrina Owen wrote an interesting piece on SitePoint Ruby ...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2016/03/15/its-not-naming-its-types.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>It's not Naming That's Hard—It's Types</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      March 15, 2016
    </h2>
  </header>
  <section class="blog-content">
    <p>Katrina Owen wrote an interesting piece on SitePoint Ruby called <a href="http://www.sitepoint.com/whats-in-a-name-anti-patterns-to-a-hard-problem/">“What’s in a Name? Anti-Patterns to a Hard Problem”</a>.  She identifies a lot of pitfalls around naming and method design, but the solutions to the problems she’s identified aren’t as much about naming as they are about using data types effectively.</p>

<!-- more -->

<p>I’m having a hard time with this statement from her post:</p>

<blockquote>
  <p>Type information is just not that compelling.</p>
</blockquote>

<p>Type information is <em>everything</em>.  Every line of code is filled with types, and the correctness of code, as well as our ability to use it properly, relies
on knowing type information.  Just because Ruby has “duck typing” doesn’t mean it has <em>no</em> types.</p>

<p>And, types are a better way to solve the problems Katrina identifies in her post.</p>

<p>She starts with this routine, arguing that the names are bad since they encode type information:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">anagrams</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">string_array</span><span class="p">)</span>
  <span class="n">string_array</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">str</span><span class="o">|</span>
    <span class="n">str</span> <span class="o">!=</span> <span class="n">string</span> <span class="o">&amp;&amp;</span> <span class="n">same_alphagram?</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">str</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>For me, it’s plainly obvious how to properly use this method: I pass in a string and an array of strings.  Katrina’s improved version makes it harder to
know what I’m expected to pass in:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">anagrams</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">candidates</span><span class="p">)</span>
  <span class="n">candidates</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">candidate</span><span class="o">|</span>
    <span class="n">subject</span> <span class="o">!=</span> <span class="n">candidate</span> <span class="o">&amp;&amp;</span> <span class="n">same_alphagram?</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>What is a “subject”?  What is a “candidate”?  My first guess would be some sort of <code class="highlighter-rouge">Subject</code> or <code class="highlighter-rouge">Candidate</code> class.  The author of this code had <em>something</em>
in mind that I should be passing in, but it’s no longer clear.  With no guidance I would have to read the source to <code class="highlighter-rouge">same_alphagram?</code> (and whatever its dependencies are).</p>

<p>The real problem is that a string is not a word and an array of strings is not a set of words.  We shouldn’t be using strings to solve this problem, and no
efforts of naming will change that.  What the <code class="highlighter-rouge">anagrams</code> method is trying to do is tell us if one word has anagrams in a set of other words.  That says to me we might need a word class.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Word</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="vi">@string</span> <span class="o">=</span> <span class="n">word</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="vi">@string</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This may seem superfluous, but we have now named the thing we are operating on.  We’ve also created a place for ourselves to put code about this type of
data.  For example, a word should only contain alphabetics and spaces.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Word</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">unless</span> <span class="n">string</span> <span class="o">=~</span> <span class="sr">/^[\a\s]+$/</span>
      <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="n">string</span><span class="si">}</span><span class="s2"> is not a word"</span> 
    <span class="k">end</span>
    <span class="vi">@string</span> <span class="o">=</span> <span class="n">word</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We’ve now described—in code—what a word is.  We’ve written code that explains what the parameters to <code class="highlighter-rouge">anagrams</code> actually are supposed to be.  And we
communicate that by naming the parameters after the data type:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">anagrams</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">candidate_words</span><span class="p">)</span>
  <span class="n">candidate_words</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">candidate_word</span><span class="o">|</span>
    <span class="n">word</span> <span class="o">!=</span> <span class="n">candidate_word</span> <span class="o">&amp;&amp;</span> <span class="n">same_alphagram?</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">candidate_word</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>With an actual data type available to us—instead of a string—we can also get rid of that pesky <code class="highlighter-rouge">same_alphagram?</code> free-floating method.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Word</span>

  <span class="k">def</span> <span class="nf">letters</span>
    <span class="vi">@string</span><span class="p">.</span><span class="nf">chars</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">same_alphagram?</span><span class="p">(</span><span class="n">other_word</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">letters</span><span class="p">.</span><span class="nf">sort</span> <span class="o">==</span> <span class="n">other_word</span><span class="p">.</span><span class="nf">letters</span><span class="p">.</span><span class="nf">sort</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Now, our <code class="highlighter-rouge">anagrams</code> routine is a bit better:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">anagrams</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">candidate_words</span><span class="p">)</span>
  <span class="n">candidate_words</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">candidate_word</span><span class="o">|</span>
    <span class="n">word</span> <span class="o">!=</span> <span class="n">candidate_word</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">.</span><span class="nf">same_alphagram?</span><span class="p">(</span><span class="n">candidate_word</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>While the names in the original routine weren’t great, the solution wasn’t to mask the method’s intent and proper use by using different names.  The
solution is use code to describe the parameters.</p>

<p>But wait.  <code class="highlighter-rouge">letters</code> is returning an array of strings.  Shouldn’t it return a <code class="highlighter-rouge">Letter</code>?</p>

<p>Yup.  Let’s do that.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Letter</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="k">unless</span> <span class="n">char</span> <span class="o">=~</span> <span class="sr">/^[\a\s]$/</span>
      <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span><span class="s2">"'</span><span class="si">#{</span><span class="n">char</span><span class="si">}</span><span class="s2">' is not a letter"</span> 
    <span class="k">end</span>
    <span class="vi">@char</span> <span class="o">=</span> <span class="n">char</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="vi">@char</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">==</span><span class="p">(</span><span class="n">other_letter</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">to_s</span> <span class="o">==</span> <span class="n">other_letter</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">&lt;</span><span class="o">=&gt;</span><span class="p">(</span><span class="n">other_letter</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">to_s</span> <span class="o">&lt;=&gt;</span> <span class="n">other_letter</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Before we re-implement <code class="highlighter-rouge">letters</code>, let’s take a moment.  We have duplicated code now in the initializers of these two classes.  Because we now have a
<code class="highlighter-rouge">Letter</code> class that describes a letter, and we know that a <code class="highlighter-rouge">Word</code> is an ordered list of <code class="highlighter-rouge">Letters</code>, we can change our implementation of <code class="highlighter-rouge">Word</code> to make that
abundandtly clear.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Word</span>

  <span class="kp">attr_reader</span> <span class="ss">:letters</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="vi">@letters</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="nf">chars</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">char</span><span class="o">|</span>
      <span class="no">Letter</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">rescue</span> <span class="n">ex</span> <span class="o">=&gt;</span> <span class="no">ArgumentError</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"'</span><span class="si">#{</span><span class="n">string</span><span class="si">}</span><span class="s2">' is not a word: </span><span class="si">#{</span><span class="n">ex</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_s</span>
    <span class="vi">@letters</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="s2">""</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">same_alphagram?</span><span class="p">(</span><span class="n">other_word</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">letters</span><span class="p">.</span><span class="nf">sort</span> <span class="o">==</span> <span class="n">other_word</span><span class="p">.</span><span class="nf">letters</span><span class="p">.</span><span class="nf">sort</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This may seem like a lot of code, and possibly even ridiculous, but if we really <em>are</em> writing code that does anagrams, doesn’t it make sense to have classes to describe the building blocks of our domain?</p>

<p>Strings (and Hashes) are great for exploring your domain, but once you understand your domain, data types will make your code easier to
understand and easier to change. It also alleviates you from stressing about parameter names.  <a href="http://naildrivin5.com/blog/2014/06/30/thinking-in-types.html">Thinking in Types</a> will make your code better and make you a better programmer.  They also help <em>greatly</em> in naming things.</p>

  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2017, by David Bryant Copeland, All Rights Reserved
    </p>
  </footer>
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '56a22cd9c88d90284f000861');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>
</body></html>
