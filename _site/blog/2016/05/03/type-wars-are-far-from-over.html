
<!DOCTYPE html>
<html language="en"><head>
  <meta charset="utf-8">
  <title>The 'Type Wars' Are Far From Over - naildrivin5.com - David Bryant Copeland's Website</title>
  <meta name="author" content="David Bryant Copeland">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  

  
  <meta name="description" content="

  
    The 'Type Wars' Are Far From Over
    
      May 03, 2016
    
  
  
    Uncle Bob penned an interesting piece called Type Wars.  It’s ost...">
  

  
  <link rel="canonical" href="http://naildrivin5.com/blog/2016/05/03/type-wars-are-far-from-over.html">
  <link href="/favicon.png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="naildrivin5.com - David Bryant Copeland's Website" type="application/atom+xml">
  <link href="/css/styles.css" rel="stylesheet">
  <script src="https://use.typekit.net/ylm4zpa.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
            
  <meta name="google-site-verification" content="h_yTpXa6N3ebHj8DYmgX4lIFGHBW1NtGMVHfXuu7i_4" />
</head>
<body>
  <header class="site-header pb2 mb2 center">
    <h1 class="uc ls2 f1"><a href="/">naildrivin5.com</a></h1>
    <h2 class="ls1"><small class="uc h4">Website of</small> David Bryant Copeland</h2>
    <nav>
      <ul>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/">Blog</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/bio">About</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/books">Books</a></li>
        <li class="text-c w-1-3"><a class="ib w-100 button" href="/talks">Talks</a></li>
      </ul>
      <div style="clear: both"></div>
    </nav>
  </header>
  <main>
    <section>
      <div>
<article role="article" class="blog-post">
  <header class="border-bottom border-light">
    <h1>The 'Type Wars' Are Far From Over</h1>
    <h2 class="f5 ls2 fw-bold mtnone uc ib">
      May 03, 2016
    </h2>
  </header>
  <section class="blog-content">
    <p>Uncle Bob penned an <a href="http://blog.cleancoder.com/uncle-bob/2016/05/01/TypeWars.html">interesting piece called Type Wars</a>.  It’s ostensibly a history of the fashion around how types are handled in programming languages.  It, unfortunately, comes to the conclusion that “TDD and unit tests means you don’t need statically-enforced types”.  This is not true.</p>

<p>He initially describes how C had types, but they weren’t enforced at compile- or run-time.  This is bad (he says and I agree) and then talks about two ways to enforce type safety (i.e. require that the you are using the correct types).  In Java, the compiler requires it or the code won’t even run.  In Smalltalk, the runtime requires it only at runtime.  And, according to Uncle Bob, the latter is preferable because you have unit tests.  This is not true (he also overstates the burden required in having types enforced at compile time—just because Java is terrible doesn’t mean the concept is).</p>

<p>In particular, he creates a false equivalence between unit testing and static type checking:</p>

<blockquote>
  <p>You don’t need static type checking if you have 100% unit test coverage.</p>
</blockquote>

<p>Not true.</p>

<!-- more -->

<h2 id="its-not-true-but-suppose-it-is">It’s Not True, but Suppose It IS</h2>

<p>If this is true (it’s not), it doesn’t imply that 100% test coverage is a better method of ensuring program correctness than static type checking.  Consider a routine to format a name for a person in the US:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UsaNameFormatter</span>
  <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span>
    <span class="n">first_name</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="n">last_name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Here is a test that achieves 100% test coverage (I’m assuming Uncle Bob means “statement coverage” due to his assertion that “unit test coverage close to 100% can, and is, being achieved”; <a href="https://en.wikipedia.org/wiki/Code_coverage">other types of coverage</a> are very difficult to achieve at 100% and very difficult to measure.).</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_format</span>
  <span class="n">formatter</span> <span class="o">=</span> <span class="no">UsaNameFormatter</span><span class="p">.</span><span class="nf">new</span>
  <span class="n">assert_equals</span> <span class="s2">"Dave Copeland"</span><span class="p">,</span> <span class="n">formatter</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="s2">"Dave"</span><span class="p">,</span><span class="s2">"Copeland"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Despite 100% test coverage, our <code class="highlighter-rouge">format</code> call still feels buggy, especially around the types of data we pass in.  If we pass in <code class="highlighter-rouge">nil</code> for either value, it blows up.  If we pass in non-strings, it blows up (unless those values support <code class="highlighter-rouge">+</code> in all the ways it’s being used, in which case it returns a possibly unexpected value).</p>

<p>In order to ensure we aren’t making these type errors, it’s not sufficient to just test <code class="highlighter-rouge">UsaNameFormatter</code>, we must ensure that the unit tests of very single <em>use</em> of this class pass in the correct arguments. This means at least one test per callsite and those tests must be carefully written so that if future changes to the code pass in nil or non-Strings, those tests fail.</p>

<p>Now consider if we had static type-checking, particularly something like Swift that prevents nil values if you haven’t opted into them:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">format</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">lastName</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">firstName</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">lastName</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We still need a test that the name is formatted correct, but <em>that’s it</em>.  We never have to worry about this being called incorrectly, and we don’t have to test the <em>use</em> of this function, because it’s impossible to mis-use.</p>

<p>So, I would say that even <em>if</em> you could obviate the need for static type checking by having 100% unit test coverage, it’s not the best way to model correctness: it’s difficult and costly.</p>

<p>Of course, it’s not actually true that 100% unit test coverage obviates the need for static type checking.</p>

<h2 id="its-not-true">It’s Not True</h2>

<p>Consider <code class="highlighter-rouge">UsaNameFormatter</code> above.  Suppose that it’s part of a name-formatting library.  In that case, our existing unit test provides 100% test coverage for our library.  If the “you” is “the person that wrote the library” then, I guess you could say that we don’t need static type checks, because our hands are clean.  If you use the code the way we told you, it’s fine.</p>

<p>If “you” is “the user of the library” then things don’t look so good.  First, you don’t have any way to know what you are supposed to pass in.  You could look at the code or unit tests to see what you <em>can</em> pass in, but you can’t possibly know what the intention is of the routine or library.  The library author has to tell you, with words and text and prose and hopefully in a way that you can understand.  And even then, if you mess it up, you can get cryptic runtime errors.  It’s hard to think of this situation as “the program is correct”.</p>

<p>Our unit tests should not test the correctness of our third-party name-formatting library.  This is a common rule of thumb and I don’t know of any reasonable guidance that says the consumer of a third-party library should write unit tests for that library.  Instead, we tend to mock our use of said third-party library.</p>

<p>Suppose we used <code class="highlighter-rouge">UsaNameFormatter</code> in a presenter to format the name of our <code class="highlighter-rouge">Person</code> object.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Presenter</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>
    <span class="vi">@person</span> <span class="o">=</span> <span class="n">person</span>
  <span class="k">end</span>
  
  <span class="k">def</span> <span class="nf">display_name</span>
    <span class="no">UsaNameFormatter</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="nf">given_name</span><span class="p">,</span><span class="n">person</span><span class="p">.</span><span class="nf">sirname</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>To test it, we mock <code class="highlighter-rouge">UsaNameFormatter</code>, because again, we don’t normally test our third-party code in <em>our</em> unit tests.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">person</span> <span class="o">=</span> <span class="no">Person</span><span class="p">.</span><span class="nf">new</span>
<span class="n">presenter</span> <span class="o">=</span> <span class="no">Presenter</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>

<span class="n">expect_any_instance_of</span><span class="p">(</span><span class="no">UsaNameFormatter</span><span class="p">).</span>
  <span class="nf">to</span> <span class="n">receive</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">).</span><span class="nf">and_return</span><span class="p">(</span><span class="s2">"Dave Copeland"</span><span class="p">)</span>

<span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="nf">display_name</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="s2">"Dave Copeland"</span><span class="p">)</span>
</code></pre>
</div>

<p>100% (passing) test coverage!  Unless the constructor of <code class="highlighter-rouge">Person</code> sets default names (and in almost all cases, it wouldn’t), we have a passing test where we pass in <code class="highlighter-rouge">nil</code> to <code class="highlighter-rouge">UsaNameFormatter#format</code>—a situation that would certainly cause a runtime error.  We have a bug.  How could this be?  Both our code and the third-party library have 100% unit test coverage.  What could static typing have done here that we have not already done?</p>

<p>Consider a Swift version of this.  The compiler would see that our Person’s <code class="highlighter-rouge">last_name</code> field is of type “nullable String”, and that our formatter requires the type “non-nullable String”.  It would refuse to compile or execute the code.  The bug would be impossible to write.</p>

<p>Therefore, it’s still possible to write bugs (bad ones!) that would be caught by static type-checking, despite having 100% unit test coverage.</p>

<p>But it gets worse.</p>

<h2 id="everything-is-a-string-right">Everything is A String, Right?</h2>

<p>When you write code with the notion that “you don’t need types because you have 100% unit test coverage” (a flawed, but not unreasonable, interpretation of what Uncle Bob is saying), you end up not using types, and instead making everything a String or a Hashtable.  And isn’t this the problem with our name-formatting in the first place?</p>

<p>Think of every possible <code class="highlighter-rouge">first_name</code> a person in the US could possible have.  Is this the <strong>exact same list</strong> as every possible string in the known universe?  No it’s not.  So why are we using Strings?!?!?  And if if that <em>were</em> true, the formatter code says that everyone must have a first name, so <code class="highlighter-rouge">nil</code> is not a valid first name, yet we have chosen types that allow it.</p>

<p>We do this all the time, because in dynamic languages, we don’t get the full benefits of static type checking, and thus there is less incentive to create custom data types.  In some static languages, like Java or C#, the type system is weak and verbose, so this, too, puts up a barrier to using custom data types.  Instead, we use Strings for everything.  This is terrible.</p>

<p>Static type checking <em>can</em> be a benefit.  It can identify bugs that are difficult or impossible to detect with 100% unit test coverage, and do so much more simply and easily.  The Type Wars are far from over.</p>


  </section>
</article>
</div>

    </section>
  </main>
  <footer class="center">
    <p class="f6">
      Copyright &copy; 2006-2017, by David Bryant Copeland, All Rights Reserved
    </p>
  </footer>
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '56a22cd9c88d90284f000861');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://d36ee2fcip1434.cloudfront.net/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>
</body></html>
